<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java多线程-ThreadLocal</title>
    <link href="/2023/07/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ThreadLocal/"/>
    <url>/2023/07/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h1 id="1、ThreadLocal是什么？"><a href="#1、ThreadLocal是什么？" class="headerlink" title="1、ThreadLocal是什么？"></a>1、ThreadLocal是什么？</h1><ul><li>提供线程内局部变量，不同线程之间不会相互干扰。</li><li>ThreadLocal 实例通常来说都是 <code>private static</code> 修饰的，用于关联线程和线程的上下文。</li><li><code>减少同一个线程内的函数 或 组件之间传递变量的复杂性</code>。</li></ul><p>小结：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 线程并发：在多线程并发的场景<br><span class="hljs-bullet">2.</span> 传递数据：通过ThreadLocal在同一线程不同组件中传递公共变量。<br><span class="hljs-bullet">3.</span> 线程隔离：每个线程的变量都是独立的，不会互相影响<br></code></pre></td></tr></table></figure><h2 id="1-1、举例-线程隔离"><a href="#1-1、举例-线程隔离" class="headerlink" title="1.1、举例-线程隔离"></a>1.1、举例-线程隔离</h2><ul><li><p>不使用ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span> &#123;<br>        <span class="hljs-built_in">this</span>.content= content;<br>    &#125;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    demo.setContent(Thread.currentThread().getName() + <span class="hljs-string">&quot;的数据&quot;</span>);<br>                    System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;----&gt;&quot;</span> + demo.getContent());<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;线程&quot;</span> + i).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/image-20230722155750292.png" alt="image-20230722155750292"></p></li><li><p>使用ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span> &#123;<br>        threadLocal.set(content);<br>    &#125;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> threadLocal.get();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    demo.setContent(Thread.currentThread().getName() + <span class="hljs-string">&quot;的数据&quot;</span>);<br>                    System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;----&gt;&quot;</span> + demo.getContent());<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;线程&quot;</span> + i).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/image-20230722155708884.png" alt="image-20230722155708884"></p></li></ul><h2 id="1-2、对比synchronized"><a href="#1-2、对比synchronized" class="headerlink" title="1.2、对比synchronized"></a>1.2、对比synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">synchronizedDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span> &#123;<br>        <span class="hljs-built_in">this</span>.content= content;<br>    &#125;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">synchronizedDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">synchronizedDemo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">synchronized</span> (synchronizedDemo.class) &#123;<br>                        demo.setContent(Thread.currentThread().getName() + <span class="hljs-string">&quot;的数据&quot;</span>);<br>                        System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;----&gt;&quot;</span> + demo.getContent());<br>                    &#125;<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;线程&quot;</span> + i).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/image-20230722161534672.png" alt="image-20230722161534672"></p><p>虽然 <code>ThreadLocal</code> 和 <code>Synchronized</code> 关键字都是用于处理多线程并发访问变量的问题，不过两者处理问题的角度和思路不同。</p><table><thead><tr><th align="center"></th><th align="center">Synchronized</th><th align="center">ThreadLocal</th></tr></thead><tbody><tr><td align="center">原理</td><td align="center">同步机制采用“以时间换空间”的方式，只提供了一份变量，让不同的线程排队访问。</td><td align="center">采用 “以空间换时间”的方式，为每一个线程都提供了一份变量的副本，从而实现同时访问而不互相干扰。</td></tr><tr><td align="center">侧重点</td><td align="center">多个线程之间访问资源的<strong>同步</strong>。</td><td align="center">并发情况下让每个线程之间数据相互<strong>隔离</strong>。</td></tr></tbody></table><h2 id="1-3、ThreadLocal的好处"><a href="#1-3、ThreadLocal的好处" class="headerlink" title="1.3、ThreadLocal的好处"></a>1.3、ThreadLocal的好处</h2><ol><li>传递数据：保证每个线程保定的数据在需要的地方可以直接使用，这样避免了进行参数传递而带来的代码耦合问题。</li><li>线程隔离：各个线程之间的数据相互隔离但有具备并发性，同事避免了使用synchronized加锁带来的性能损耗问题。</li></ol><h1 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/image.png" alt="img"></p><p>那么可以看到在service到Dao层的时候，都会使用connection，那么此时将connection对象和当前线程进行绑定，这样就能保证数据的一致性，并且避免传参导致的代码耦合问题。</p><h2 id="2-1、Service层"><a href="#2-1、Service层" class="headerlink" title="2.1、Service层"></a>2.1、Service层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.transfer.service;<br><br><span class="hljs-keyword">import</span> com.itheima.transfer.dao.AccountDao;<br><span class="hljs-keyword">import</span> com.itheima.transfer.utils.JdbcUtils;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String outUser, String inUser, <span class="hljs-type">int</span> money)</span> &#123;<br>        <span class="hljs-type">AccountDao</span> <span class="hljs-variable">ad</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountDao</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> JdbcUtils.getConnection();<br>            <span class="hljs-comment">//开启事务</span><br>            conn.setAutoCommit(<span class="hljs-literal">false</span>);<br>            <span class="hljs-comment">// 转出 ： 这里不需要传参了 ！</span><br>            ad.out(outUser, money);<br>            <span class="hljs-comment">// 模拟转账过程中的异常</span><br><span class="hljs-comment">//            int i = 1 / 0;</span><br>            <span class="hljs-comment">// 转入</span><br>            ad.in(inUser, money);<br>            <span class="hljs-comment">//事务提交</span><br>            JdbcUtils.commitAndClose();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-comment">//事务回滚</span><br>           JdbcUtils.rollbackAndClose();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-2、Dao层"><a href="#2-2、Dao层" class="headerlink" title="2.2、Dao层"></a>2.2、Dao层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.transfer.dao;<br><br><span class="hljs-keyword">import</span> com.itheima.transfer.utils.JdbcUtils;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountDao</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">out</span><span class="hljs-params">(String outUser, <span class="hljs-type">int</span> money)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = money - ? where name = ?&quot;</span>;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> JdbcUtils.getConnection();<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstm</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>        pstm.setInt(<span class="hljs-number">1</span>,money);<br>        pstm.setString(<span class="hljs-number">2</span>,outUser);<br>        pstm.executeUpdate();<br>        <span class="hljs-comment">//照常使用</span><br><span class="hljs-comment">//        JdbcUtils.release(pstm,conn);</span><br>        JdbcUtils.release(pstm);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">in</span><span class="hljs-params">(String inUser, <span class="hljs-type">int</span> money)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = money + ? where name = ?&quot;</span>;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> JdbcUtils.getConnection();<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstm</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>        pstm.setInt(<span class="hljs-number">1</span>,money);<br>        pstm.setString(<span class="hljs-number">2</span>,inUser);<br>        pstm.executeUpdate();<br><span class="hljs-comment">//        JdbcUtils.release(pstm,conn);</span><br>        JdbcUtils.release(pstm);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-3、Utils方法"><a href="#2-3、Utils方法" class="headerlink" title="2.3、Utils方法"></a>2.3、Utils方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.transfer.utils;<br><br><span class="hljs-keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcUtils</span> &#123;<br>    <span class="hljs-comment">//ThreadLocal对象 : 将connection绑定在当前线程中</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br><br>    <span class="hljs-comment">// c3p0 数据库连接池对象属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br><br>    <span class="hljs-comment">// 获取连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-comment">//取出当前线程绑定的connection对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> tl.get();<br>        <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//如果没有，则从连接池中取出</span><br>            conn = ds.getConnection();<br>            <span class="hljs-comment">//再将connection对象绑定到当前线程中</span><br>            tl.set(conn);<br>        &#125;<br>        <span class="hljs-keyword">return</span> conn;<br>    &#125;<br><br>    <span class="hljs-comment">//释放资源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(AutoCloseable... ios)</span> &#123;<br>        <span class="hljs-keyword">for</span> (AutoCloseable io : ios) &#123;<br>            <span class="hljs-keyword">if</span> (io != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    io.close();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commitAndClose</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> getConnection();<br>            <span class="hljs-comment">//提交事务</span><br>            conn.commit();<br>            <span class="hljs-comment">//解除绑定</span><br>            tl.remove();<br>            <span class="hljs-comment">//释放连接</span><br>            conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollbackAndClose</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> getConnection();<br>            <span class="hljs-comment">//回滚事务</span><br>            conn.rollback();<br>            <span class="hljs-comment">//解除绑定</span><br>            tl.remove();<br>            <span class="hljs-comment">//释放连接</span><br>            conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，在Utils方法中，getConnection的时候，此时使用了一个ThreadLocal对象，将当前Connection对象和当前线程进行绑定了；如果是第一次获取connection对象，那么就从连接池中获取，不是的话，那么直接从ThreadLocal中获取。</p><h1 id="3、内部结构探索"><a href="#3、内部结构探索" class="headerlink" title="3、内部结构探索"></a>3、内部结构探索</h1><h2 id="3-1、内部结构"><a href="#3-1、内部结构" class="headerlink" title="3.1、内部结构"></a>3.1、内部结构</h2><p>在JDK8中ThreadLocal的设计：每个<code>Thread</code>维护一个<code>ThreadLocalMap</code>，这个Map的<code>key</code>是<code>ThreadLocal</code>对象本身，而<code>value</code>就是真正需要存储的值。</p><p>具体：</p><blockquote><p>（1） 每个Thread线程内部都有一个Map (ThreadLocalMap)<br>（2） Map里面存储ThreadLocal对象（key）和线程的变量副本（value）<br>（3）Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。<br>（4）对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</p></blockquote><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/image-20230722171217698.png" alt="image-20230722171217698"></p><p>由于每个Thread中维护一个ThreadLocalMap，Map的key为ThreadLocal对象本身，value为设置的值，这样的优势：</p><ol><li>每个<code>Map</code>存储的<code>Entry</code>数量就会变少，JDK7中的存储数量由<code>Thread</code>的数量决定，现在是由<code>ThreadLocal</code>的数量决定。（ThreadLocal的数量远远小于Thread数量）</li><li>当<code>Thread</code>销毁之后，对应的<code>ThreadLocalMap</code>也会随之销毁，能减少内存的使用。</li></ol><h2 id="3-2、核心方法"><a href="#3-2、核心方法" class="headerlink" title="3.2、核心方法"></a>3.2、核心方法</h2><h3 id="3-2-1、set"><a href="#3-2-1、set" class="headerlink" title="3.2.1、set"></a>3.2.1、set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br><span class="hljs-comment">// 1）拿到当前线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-comment">// 2）通过线程内部的 threadLocals 变量，拿到对应 ThreadLocalMap 对象。对应着分析1</span><br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        <span class="hljs-comment">// 3）判断如果不为 null ,则直接调用 ThreadLocalMap 中的 set 方法，传入 当前的 ThreadLocal 对象和要指定修改的值 value，对应着分析2</span><br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>            map.set(<span class="hljs-built_in">this</span>, value);<br>        <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 4）创建 map 为 null，就创建 map, 对应着分析3</span><br>            createMap(t, value);<br>    &#125; <br><br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br><br><span class="hljs-comment">// Thread类中持有一个ThreadLocalMap类型的对象threadLocals</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p>真正进行赋值：</p><blockquote><p>set方法可以进行修改或者新建的操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    <span class="hljs-comment">// 将ThreadLocal对象的存储表table赋值给局部变量tab</span><br>        Entry[] tab = table;<br>    <span class="hljs-comment">// 计算tab的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-comment">// 先找到对应Entry的数组下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 循环查找存储表中能匹配的Entry对象，从索引位置开始一直到链表末尾</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>             e != <span class="hljs-literal">null</span>;<br>             e = tab[i = nextIndex(i, len)]) &#123;<br>            <span class="hljs-comment">// 取出当前的ThreadLocal对象</span><br>            ThreadLocal&lt;?&gt; k = e.get();<br>            <span class="hljs-comment">// 判断与Key，即是否是一个ThreadLocal对象，如果是，那么就进行以及修改</span><br>            <span class="hljs-keyword">if</span> (k == key) &#123;<br>                e.value = value;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当前Entry的ThreadLocal对象为空，说明该Entry无效，可能在之前被GC掉了</span><br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 传入key, value, i创建一个新的Entry，存储在数组tab的位置</span><br>                replaceStaleEntry(key, value, i);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-comment">// 循环找都没有匹配ThreadLocal对象</span><br>    <span class="hljs-comment">// 新建一个Entry，</span><br>        tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br><span class="hljs-comment">// 增加存储表中的Entry数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <span class="hljs-comment">// 判断是否需要清理一些无效的Entry&amp;&amp;是否需要去扩容</span><br>        <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>            <span class="hljs-comment">// 进行扩容</span><br>            rehash();<br>    &#125;<br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>        t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>    &#125;<br>    <br>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>        <span class="hljs-comment">// 创建一个默认长度大小为 16 的 Entry 数组</span><br>        table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>        <span class="hljs-comment">// 计算对应的数组的下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 插入节点</span><br>        table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>        size = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 设置扩容阈值</span><br>        setThreshold(INITIAL_CAPACITY);<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-2-2、get"><a href="#3-2-2、get" class="headerlink" title="3.2.2、get"></a>3.2.2、get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前的线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 获取当前线程的ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 通过 getEntry 找到线程对应着的 Entry 对象, 对应着分析1</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">// 如果不为 null 则直接拿到返回</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// map为空，进行initialValue</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-comment">// 计算出 index 的值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 获取当前tab下表为i的Entry</span><br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-comment">// 如果存在, 判断是不是相同的对象，是就直接返回</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 清空 key 为 null 的对象</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 会进行初始化, 如果我们重写了就会调用我们自己重写的，否则就调用默认的。</span><br>    <span class="hljs-comment">// protected T initialValue() &#123;return null;&#125;</span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>     <span class="hljs-comment">// 如果 map 不为 null ，就直接添加本地变量，key 为当前线程，值为添加的本地变量值</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// 如果 map 为 null，说明首次添加，需要首先创建出对应的 map</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-3、remove"><a href="#3-2-3、remove" class="headerlink" title="3.2.3、remove"></a>3.2.3、remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程绑定的 threadLocals</span><br>     <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>     <span class="hljs-comment">// 如果 map 不为 null，就移除当前线程中指定 ThreadLocal 实例的本地变量</span><br>     <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)<br>         m.remove(<span class="hljs-built_in">this</span>);<br> &#125;<br><br></code></pre></td></tr></table></figure><h1 id="4、ThreadLocal内存泄漏"><a href="#4、ThreadLocal内存泄漏" class="headerlink" title="4、ThreadLocal内存泄漏"></a>4、ThreadLocal内存泄漏</h1><h2 id="4-1、内存泄漏是什么？"><a href="#4-1、内存泄漏是什么？" class="headerlink" title="4.1、内存泄漏是什么？"></a>4.1、内存泄漏是什么？</h2><blockquote><p>不再会使用的对象或者变量占用的内存不能被回收，就是内存泄漏。</p></blockquote><h2 id="4-2、四种引用"><a href="#4-2、四种引用" class="headerlink" title="4.2、四种引用"></a>4.2、四种引用</h2><h3 id="4-2-1、强引用"><a href="#4-2-1、强引用" class="headerlink" title="4.2.1、强引用"></a>4.2.1、强引用</h3><p>一般我们 new 关键字创建的对象就是 Reference（强引用），当内存不足时，JVM 开始垃圾回收，对于强引用对象，就算是出现 OOM 也不会对该对象进行回收。</p><h3 id="4-2-2、软引用"><a href="#4-2-2、软引用" class="headerlink" title="4.2.2、软引用"></a>4.2.2、软引用</h3><p>软引用是一种相对相对于强引用弱化了一些的引用，需要用 SoftReference 类实现，对于软引用来说，当系统内存充足时，软引用对象不会被垃圾回收，不充足时，会被回收。软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收！</p><h3 id="4-2-3、弱引用"><a href="#4-2-3、弱引用" class="headerlink" title="4.2.3、弱引用"></a>4.2.3、弱引用</h3><p>弱引用需要用 WeakReference 类实现，它比软引用的生存期更短，对于弱引用对象来说，只要垃圾回收器运行，不管 JVM 内存空间是否足够，都会回收该对象占用的内存。</p><h3 id="4-2-4、虚引用"><a href="#4-2-4、虚引用" class="headerlink" title="4.2.4、虚引用"></a>4.2.4、虚引用</h3><p>虚引用需要 PhantomReference 类来实现，如果一个对象持有虚引用，那么它就和没有任何引用一样，在任何时候都可能会垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列（ReferenceQueue）联合使用。</p><h2 id="4-3、Entry"><a href="#4-3、Entry" class="headerlink" title="4.3、Entry"></a>4.3、Entry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        Object value;<br><br>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>            <span class="hljs-built_in">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码中可以得知，</p><ul><li>ThreadLocalMap是ThreadLocal的一个内部静态类，用来存储每个线程对应的变量值。Entry类来管理每个线程本地变量的key-value。</li><li><code>Entry</code>是<code>ThreadLocalMap</code>的一个内部静态类，继承自<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>。<code>Entry</code>表示一个键值对，用于将<code>ThreadLocal</code>对象与其对应的变量值关联起来。<ul><li>表明：<code>ThreadLocal</code>对象在没有其他强引用对象的时候会被垃圾回收器进行回收，而<code>Entry</code>的声明周期也会随着结束，进而避免了内存泄漏。</li></ul></li></ul><h3 id="4-3-1、为什么是弱引用"><a href="#4-3-1、为什么是弱引用" class="headerlink" title="4.3.1、为什么是弱引用"></a>4.3.1、为什么是弱引用</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/20210219124533810.png" alt="图一"></p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    ThreadLocal&lt;Integer&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    tl .set(<span class="hljs-number">2021</span>);<br>    tl .get();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当调用method的时候，会向栈中插入一条栈帧。</li><li>new关键字创建一个ThreadLocal对象，此时tl是对象的引用<ul><li>new出的对象是一个强引用，通过set方法进行存储值，Key是ThreadLocal对象本身，Value为需要存储的值。</li><li>Entry继承WeakReference，那么Key是弱引用指向了ThreadLocal对象。</li></ul></li><li>当method方法执行完毕之后，栈帧销毁，此时强引用tl就不存在了。<ul><li>但是Thread的ThreadLocalMap中的某一个Entry的key的引用还指向了ThreadLocal对象</li><li>如果这个Key引用是强引用，会导致Key指向的ThreadLocal对象是强引用对象不能被GC，会造成内存泄漏</li><li>如果这个Key引用是弱引用，会大概率减少内存泄漏的问题。使用了弱引用，就可以使ThreadLocal对象在方法执行完毕之后顺利被回收，并且Key的引用会被指向为null。</li></ul></li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/20210219131444101.png" alt="图二"></p><blockquote><p>总结：</p><ul><li>new一个ThreadLocal对象的时候，就会有一个强引用指向这个对象。</li><li>调用set方法之后，线程中的ThreadLocalMap中的Entry对象中的Key指向ThreadLocal对象。</li><li>如果Key是强引用的话，当方法执行完，栈帧中的强引用销毁了，对象还不能被回收，此时就会造成内存泄漏。</li></ul></blockquote><h3 id="4-3-2、为什么还是会泄漏"><a href="#4-3-2、为什么还是会泄漏" class="headerlink" title="4.3.2、为什么还是会泄漏"></a>4.3.2、为什么还是会泄漏</h3><p>虽然Entry继承了弱引用，保证了Key指向的ThreadLocal对象能被及时回收，但是此时v指向的Value对象需要再ThreadLocalMap调用get、set的时候发现Key为null的时候才能回收整个的entry、Value。</p><blockquote><p>为什么value还持有引用？</p><p>解答：ThreadLocal作为Thread的一个属性，如果当前线程没有手动销毁，那么ThreadLocalMap也还是存在，同理Entry的引用也持有。</p></blockquote><p><code>所以泄露的根本原因就是因为ThreadLocal的生命周期和Thread的生命周期一样，如果线程没有主动销毁，那么entry就不会被销毁。</code><br><img src="https://workspace-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/image-20230725174415384.png" alt="image-20230725174415384"></p><p>所以：弱引用只是帮助我们降低了内存泄漏的概率，并不能完全避免，在使用完成之后，<code>必须手动remove</code>这个对象。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/20210219134347416.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Java多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis-01</title>
    <link href="/2023/07/10/redis-01/"/>
    <url>/2023/07/10/redis-01/</url>
    
    <content type="html"><![CDATA[<h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><blockquote><p>为什么学习Redis?</p></blockquote><p><img src="https://workspace-1313021454.cos.ap-beijing.myqcloud.com/Redis-01/image-20230710110803521.png" alt="image-20230710110803521"></p><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li></ul></li></ul><ul><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul><h1 id="1、Redis常见命令"><a href="#1、Redis常见命令" class="headerlink" title="1、Redis常见命令"></a>1、Redis常见命令</h1><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p><p><img src="https://workspace-1313021454.cos.ap-beijing.myqcloud.com/Redis-01/image-20230710111123811.png" alt="image-20230710111123811"></p><blockquote><p>当然更推荐自行查阅<a href="https://redis.io/commands/">官方</a>或者使用终端(前提先启动redis-server、redis-cli)，通过help命令来查看各种不同group的命令。</p></blockquote><p>同时需要注意的是，redis是基于内存的，因此在set的时候，需要给每个key添加一个过期时间：</p><p><code>expire key time</code>，通过使用<code>ttl key</code>查看该key的剩余时间。</p><blockquote><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看keys命令的帮助信息：</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">help</span> keys<br><br>KEYS pattern<br>summary: Find all keys matching the given pattern<br>since: 1.0.0<br>group: generic<br></code></pre></td></tr></table></figure></blockquote><h2 id="1-1、String"><a href="#1-1、String" class="headerlink" title="1.1、String"></a>1.1、String</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增.自减操作</li><li>float：浮点类型，可以做自增.自减操作</li></ul><hr><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长（<code>不常用</code>）</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><h2 id="1-2、Key的层级结构"><a href="#1-2、Key的层级结构" class="headerlink" title="1.2、Key的层级结构"></a>1.2、Key的层级结构</h2><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">项目名:业务名:类型:<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据</p><p><img src="https://workspace-1313021454.cos.ap-beijing.myqcloud.com/Redis-01/image-20230710133129047.png" alt="image-20230710133129047"></p><h2 id="1-3、Hash"><a href="#1-3、Hash" class="headerlink" title="1.3、Hash"></a>1.3、Hash</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="https://workspace-1313021454.cos.ap-beijing.myqcloud.com/Redis-01/image-20230710133244234.png" alt="image-20230710133244234"></p><p>即：key:value，这个value又对应field:value结构</p><hr><p><strong>Hash类型的常见命令</strong></p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li><p>HKEYS：获取一个hash类型的key中的所有的field</p></li><li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p></li><li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p></li></ul><h2 id="1-4、List"><a href="#1-4、List" class="headerlink" title="1.4、List"></a>1.4、List</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><blockquote><p>特点：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>使用场景：</p><p>例如：朋友圈点赞列表，评论列表等。</p></blockquote><hr><p><strong>List的常见命令有：</strong></p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p><img src="https://workspace-1313021454.cos.ap-beijing.myqcloud.com/Redis-01/1652943604992.png" alt="1652943604992"></p><h2 id="1-5、Set"><a href="#1-5、Set" class="headerlink" title="1.5、Set"></a>1.5、Set</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。</p><blockquote><p>特点：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集.并集.差集等功能</li></ul></blockquote><hr><p><strong>Set类型的常见命令</strong></p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li><li>SDIFF key1 key2 … ：求key1与key2的差集</li><li>SUNION key1 key2 ..：求key1和key2的并集</li></ul><h2 id="1-6、SortedSet类型"><a href="#1-6、SortedSet类型" class="headerlink" title="1.6、SortedSet类型"></a>1.6、SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><blockquote><p>特点：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>使用场景：</p><p>由于每个key自带一个score，那么通常可以实现一个榜单、排行榜的功能</p></blockquote><hr><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加<code>REV</code>即可，例如：</p><ul><li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p></li><li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p></li></ul><h1 id="2、Redis的Java客户端"><a href="#2、Redis的Java客户端" class="headerlink" title="2、Redis的Java客户端"></a>2、Redis的Java客户端</h1><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p>推荐使用：</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h2 id="2-1、Jedis"><a href="#2-1、Jedis" class="headerlink" title="2.1、Jedis"></a>2.1、Jedis</h2><ul><li>引入依赖：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jedis--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--单元测试--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>使用Test建立连接:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;<br><br><span class="hljs-meta">@BeforeEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.建立连接</span><br>    <span class="hljs-comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span><br>    jedis = JedisConnectionFactory.getJedis();<br>    <span class="hljs-comment">// 2.设置密码</span><br>    jedis.auth(<span class="hljs-string">&quot;123321&quot;</span>);<br>    <span class="hljs-comment">// 3.选择库</span><br>    jedis.select(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 存入数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 插入hash数据</span><br>    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);<br>    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);<br><br>    <span class="hljs-comment">// 获取</span><br>    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="hljs-string">&quot;user:1&quot;</span>);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>资源释放：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-1、Jedis连接池"><a href="#2-1-1、Jedis连接池" class="headerlink" title="2.1.1、Jedis连接池"></a>2.1.1、Jedis连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</p><ul><li>创建连接池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFacotry</span> &#123;<br><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> JedisPool jedisPool;<br><br>     <span class="hljs-keyword">static</span> &#123;<br>         <span class="hljs-comment">//配置连接池</span><br>         <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>         poolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>         poolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>         poolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>         poolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>         <span class="hljs-comment">//创建连接池对象</span><br>         jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig,<br>                 <span class="hljs-string">&quot;192.168.150.101&quot;</span>,<span class="hljs-number">6379</span>,<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;123321&quot;</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>&#123;<br>          <span class="hljs-keyword">return</span> jedisPool.getResource();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>修改之前创建对象的方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BeforeEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//建立连接</span><br>    <span class="hljs-comment">/*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/</span><br>    jedis = JedisConnectionFacotry.getJedis();<br>     <span class="hljs-comment">//选择库</span><br>    jedis.select(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-meta">@AfterEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2、SpringDataRedis"><a href="#2-2、SpringDataRedis" class="headerlink" title="2.2、SpringDataRedis"></a>2.2、SpringDataRedis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis。</p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化(如果使用Jedis的话，那么需要自己实现序列化操作)</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="https://workspace-1313021454.cos.ap-beijing.myqcloud.com/Redis-01/1652976773295.png" alt="1652976773295"></p><h3 id="2-2-1、使用"><a href="#2-2-1、使用" class="headerlink" title="2.2.1、使用"></a>2.2.1、使用</h3><ul><li>引入依赖：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redis-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>redis-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--redis依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--common-pool--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--Jackson依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>配置文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span>  <span class="hljs-comment">#最大连接</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span>   <span class="hljs-comment">#最大空闲连接</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span>   <span class="hljs-comment">#最小空闲连接</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">100ms</span> <span class="hljs-comment">#连接等待时间</span><br></code></pre></td></tr></table></figure><ul><li>测试：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisDemoApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate; <span class="hljs-comment">//注入redisTemplate</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 写入一条String数据</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);<br>        <span class="hljs-comment">// 获取string数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2、自定义序列化"><a href="#2-2-2、自定义序列化" class="headerlink" title="2.2.2、自定义序列化"></a>2.2.2、自定义序列化</h3><p>RedisTemplate可以接收任意Object作为值写入Redis。但因为在写入之前会把Object对象序列化为字节的形式，在底层采用的是JDK序列化。</p><p><img src="https://workspace-1313021454.cos.ap-beijing.myqcloud.com/Redis-01/image-20230711082054025.png" alt="image-20230711082054025"></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><blockquote><p>主要是创建JSON序列化工具</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span>&#123;<br>        <span class="hljs-comment">// 创建RedisTemplate对象</span><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置连接工厂</span><br>        template.setConnectionFactory(connectionFactory);<br>        <span class="hljs-comment">// 创建JSON序列化工具</span><br>        <span class="hljs-type">GenericJackson2JsonRedisSerializer</span> <span class="hljs-variable">jsonRedisSerializer</span> <span class="hljs-operator">=</span> <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>();<br>        <span class="hljs-comment">// 设置Key的序列化</span><br>        template.setKeySerializer(RedisSerializer.string());<br>        template.setHashKeySerializer(RedisSerializer.string());<br>        <span class="hljs-comment">// 设置Value的序列化</span><br>        template.setValueSerializer(jsonRedisSerializer);<br>        template.setHashValueSerializer(jsonRedisSerializer);<br>        <span class="hljs-comment">// 返回</span><br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://workspace-1313021454.cos.ap-beijing.myqcloud.com/Redis-01/image-20230711083639664.png" alt="image-20230711083639664"></p><p>这个<code>@class</code>就是记录了序列化的时候对应类，方便在查询的时候实现反序列化。缺点：会带来额外的内存开销。</p><h3 id="2-2-3、StringRedisTemplate"><a href="#2-2-3、StringRedisTemplate" class="headerlink" title="2.2.3、StringRedisTemplate"></a>2.2.3、StringRedisTemplate</h3><p>对比使用JSON工具进行序列化，StringRedisTemplate需要手动完成序列化和反序列化，最后在存储的时候就不会将class信息写入Redis了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><span class="hljs-comment">// JSON序列化工具（常用的有fastJson等）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>    <span class="hljs-comment">// 创建对象</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;虎哥&quot;</span>, <span class="hljs-number">21</span>);<br>    <span class="hljs-comment">// 手动序列化</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(user);<br>    <span class="hljs-comment">// 写入数据</span><br>    stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:200&quot;</span>, json);<br><br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">jsonUser</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;user:200&quot;</span>);<br>    <span class="hljs-comment">// 手动反序列化</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.readValue(jsonUser, User.class);<br>    System.out.println(<span class="hljs-string">&quot;user1 = &quot;</span> + user1);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-线程交替打印</title>
    <link href="/2023/07/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/"/>
    <url>/2023/07/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<p>今日复习来自极海Channel的一个面试</p><blockquote><p>如何实现两个线程实现交替打印，线程A打印A，线程B打印B？</p></blockquote><p>讲真当时看到的时候，脑子里面第一反应就是信号量和synchronized解法，那有synchronized就会有ReentrantLock，那就尝试用这三个解法回答一下吧。</p><p>代码地址：<a href="https://github.com/baijiangLai/LearnOfJUC/tree/master/alternatePrint">线程交替打印</a></p><h2 id="1、synchronized实现"><a href="#1、synchronized实现" class="headerlink" title="1、synchronized实现"></a>1、synchronized实现</h2><p>synchronized的方式实现主要是进行加锁，通过一把对象锁，在代码块内只允许一个线程执行后续操作。</p><p>核心：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 持有的lock锁</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-comment">// 打印顺序就是A--&gt;B--&gt;C</span><br>        <span class="hljs-keyword">while</span> (currentOrder % <span class="hljs-number">3</span> != order) &#123;<br>            lock.wait(); <span class="hljs-comment">// 当前线程等待，直到轮到自己打印</span><br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;------&quot;</span> + message);<br>        currentOrder++;<br>        lock.notifyAll(); <span class="hljs-comment">// 唤醒其他等待的线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、ReentrantLock实现"><a href="#2、ReentrantLock实现" class="headerlink" title="2、ReentrantLock实现"></a>2、ReentrantLock实现</h2><p>ReentrantLock实现，同样会传入锁，但是lock和unlock是自己规定，所以当需要判断打印的时候，进行枷锁操作，同时每个线程进去之后判断是否是自己需要打印，如果不是，那么就唤醒下一个线程。</p><p>核心：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-comment">// 某个线程持有锁，只有一个线程进入后续部分</span><br>    lock.lock();<br>    <span class="hljs-comment">// 条件判断，如果不满足，当前线程等待，</span><br>    <span class="hljs-keyword">while</span> (currentOrder % <span class="hljs-number">3</span> != order) &#123;<br>        current.await();<br>    &#125;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;------&quot;</span> + message);<br>    currentOrder++;<br>    <span class="hljs-comment">// 使用signal()唤醒下一个线程</span><br>    next.signal();<br>    <span class="hljs-comment">// 锁释放</span><br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：Condition对象是与锁（<strong>ReentrantLock</strong>）关联的条件对象，用于线程间的等待和通知机制。因此锁的类型不并不是Object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>lock.newContional();    <span class="hljs-comment">//ConditionalA</span><br>lock.newContional();    <span class="hljs-comment">//ConditionalB</span><br>lock.newContional();    <span class="hljs-comment">//ConditionalC</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="3、信号量实现"><a href="#3、信号量实现" class="headerlink" title="3、信号量实现"></a>3、信号量实现</h2><p>在使用信号量实现的时候，需要指定谁最先拥有许可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphoreA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">//信号量A最先拥有许可，所以从他开始</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphoreB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphoreC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>核心：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 核心：通过获取当前线程的信号量来确定是否轮到自己执行。</span><br><span class="hljs-comment">     * 在执行完打印操作后，释放下一个线程的信号量，从而实现线程的交叉打印。</span><br><span class="hljs-comment">     */</span><br>    current.acquire();      <span class="hljs-comment">// 获取当前线程的信号量</span><br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;------&quot;</span> + message);<br>    currentOrder++;<br>    next.release();         <span class="hljs-comment">//释放下一个线程的信号量</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
