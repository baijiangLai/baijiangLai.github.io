<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试-Java并发</title>
    <link href="/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91/12dfa50ad646/"/>
    <url>/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91/12dfa50ad646/</url>
    
    <content type="html"><![CDATA[<h1 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h1><h2 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h2><ul><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程</li><li>一个进程可以被划分为多个线程</li></ul><h2 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h2><ul><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li></ul><blockquote><p>区别：</p><ul><li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li><li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li></ul></blockquote><h1 id="2-并行并发"><a href="#2-并行并发" class="headerlink" title="2. 并行并发"></a>2. 并行并发</h1><ul><li>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</li><li>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</li></ul><h1 id="3-创建线程的方式"><a href="#3-创建线程的方式" class="headerlink" title="3. 创建线程的方式"></a>3. 创建线程的方式</h1><h2 id="3-1-继承Thread类"><a href="#3-1-继承Thread类" class="headerlink" title="3.1 继承Thread类"></a>3.1 继承Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyThread...run...&quot;</span>);<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 创建MyThread对象</span><br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>() ;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>() ;<br><br>        <span class="hljs-comment">// 调用start方法启动线程</span><br>        t1.start();<br>        t2.start();<br><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-实现Runnable接口"><a href="#3-2-实现Runnable接口" class="headerlink" title="3.2 实现Runnable接口"></a>3.2 实现Runnable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyRunnable...run...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 创建MyRunnable对象</span><br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">mr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>() ;<br><br>        <span class="hljs-comment">// 创建Thread对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mr) ;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mr) ;<br><br>        <span class="hljs-comment">// 调用start方法启动线程</span><br>        t1.start();<br>        t2.start();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-实现Callable接口"><a href="#3-3-实现Callable接口" class="headerlink" title="3.3 实现Callable接口"></a>3.3 实现Callable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyCallable...call...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        <span class="hljs-comment">// 创建MyCallable对象</span><br>        <span class="hljs-type">MyCallable</span> <span class="hljs-variable">mc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>() ;<br><br>        <span class="hljs-comment">// 创建F</span><br>        FutureTask&lt;String&gt; ft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;String&gt;(mc) ;<br><br>        <span class="hljs-comment">// 创建Thread对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ft) ;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ft) ;<br><br>        <span class="hljs-comment">// 调用start方法启动线程</span><br>        t1.start();<br><br>        <span class="hljs-comment">// 调用ft的get方法获取执行结果</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ft.get();<br><br>        <span class="hljs-comment">// 输出</span><br>        System.out.println(result);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>Callable要配合 FutureTask使用</li><li>Callable能取得执行结果</li><li>可以抛出异常</li></ul></blockquote><h2 id="3-4-线程池创建"><a href="#3-4-线程池创建" class="headerlink" title="3.4 线程池创建"></a>3.4 线程池创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyExecutors</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyRunnable...run...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 创建线程池对象</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        threadPool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyExecutors</span>()) ;<br><br>        <span class="hljs-comment">// 关闭线程池</span><br>        threadPool.shutdown();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>start和run启动线程：</p><ul><li>start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</li><li>run(): 封装了要被线程执行的代码，可以被调用多次。</li></ul></blockquote><h1 id="4-线程状态"><a href="#4-线程状态" class="headerlink" title="4. 线程状态"></a>4. 线程状态</h1><h2 id="4-1-状态定义"><a href="#4-1-状态定义" class="headerlink" title="4.1 状态定义"></a>4.1 状态定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>  <span class="hljs-comment">//尚未启动的线程的线程状态  </span><br>  NEW,<br>  <span class="hljs-comment">//可运行线程的线程状态</span><br>  RUNNABLE,<br>  <span class="hljs-comment">//线程阻塞等待监视器锁的线程状态</span><br>  BLOCKED,<br>  <span class="hljs-comment">//等待线程的线程状态</span><br>  WAITING,<br>  <span class="hljs-comment">//具有指定等待时间的等待线程的线程状态</span><br>  TIMED_WAITING,<br>  <span class="hljs-comment">//已终止线程的线程状态。线程已完成执行</span><br>  TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-状态转换"><a href="#4-2-状态转换" class="headerlink" title="4.2 状态转换"></a>4.2 状态转换</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505162813814.png" alt="image-20240505162813814"></p><blockquote><ul><li>创建线程对象是新建状态</li><li>调用了start()方法转变为可执行状态</li><li>线程获取到了CPU的执行权，执行结束是终止状态</li><li>在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态<ul><li>如果没有获取锁（synchronized或lock）进入阻塞状态，获得锁再切换为可执行状态</li><li>如果线程调用了wait()方法进入等待状态，其他线程调用notify()唤醒后可切换为可执行状态</li><li>如果线程调用了sleep(50)方法，进入计时等待状态，到时间后可切换为可执行状态</li></ul></li></ul></blockquote><h1 id="5-线程交替打印"><a href="#5-线程交替打印" class="headerlink" title="5. 线程交替打印"></a>5. 线程交替打印</h1><h2 id="5-1-使用synchronized"><a href="#5-1-使用synchronized" class="headerlink" title="5.1 使用synchronized"></a>5.1 使用synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedPrintThread</span>(lock, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>), <span class="hljs-string">&quot;线程A&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedPrintThread</span>(lock, <span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-number">1</span>), <span class="hljs-string">&quot;线程B&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedPrintThread</span>(lock, <span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-number">2</span>), <span class="hljs-string">&quot;线程C&quot;</span>);<br><br>threadA.start();<br>threadB.start();<br>threadC.start();<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedPrintThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String message;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> order;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentOrder</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SynchronizedPrintThread</span><span class="hljs-params">(Object lock, String message, <span class="hljs-type">int</span> order)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lock = lock;<br>        <span class="hljs-built_in">this</span>.message = message;<br>        <span class="hljs-built_in">this</span>.order = order;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                    <span class="hljs-comment">// 打印顺序就是A--&gt;B--&gt;C</span><br>                    <span class="hljs-keyword">while</span> (currentOrder % <span class="hljs-number">3</span> != order) &#123;<br>                        lock.wait(); <span class="hljs-comment">// 当前线程等待，直到轮到自己打印</span><br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;------&quot;</span> + message);<br>                    currentOrder++;<br>                    lock.notifyAll(); <span class="hljs-comment">// 唤醒其他等待的线程</span><br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-使用reentrantlock"><a href="#5-2-使用reentrantlock" class="headerlink" title="5.2 使用reentrantlock"></a>5.2 使用reentrantlock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-type">Condition</span> <span class="hljs-variable">conditionA</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">conditionB</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">conditionC</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLockPrintThread</span>(lock, conditionA, conditionB, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>));<br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLockPrintThread</span>(lock, conditionB, conditionC, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">1</span>));<br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLockPrintThread</span>(lock, conditionC, conditionA, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">2</span>));<br><br>threadA.start();<br>threadB.start();<br>threadC.start();<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockPrintThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition current;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition next;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String message;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> order;<br><br>    <span class="hljs-comment">// 多个线程共享，如果没有static的话，那么会造成只有第一个线程执行了，其余线程还在等待第一个线程执行。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentOrder</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLockPrintThread</span><span class="hljs-params">(Lock lock, Condition currentCondition, Condition nextCondition, String message, <span class="hljs-type">int</span> order)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lock = lock;<br>        <span class="hljs-built_in">this</span>.current = currentCondition; <span class="hljs-comment">//当前线程信号量</span><br>        <span class="hljs-built_in">this</span>.next = nextCondition;      <span class="hljs-comment">//下一个线程信号量</span><br>        <span class="hljs-built_in">this</span>.message = message;<br>        <span class="hljs-built_in">this</span>.order = order;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-comment">// 某个线程持有锁，只有一个线程进入后续部分</span><br>                lock.lock();<br>                <span class="hljs-comment">// 条件判断，如果不满足，当前线程等待，</span><br>                <span class="hljs-keyword">while</span> (currentOrder % <span class="hljs-number">3</span> != order) &#123;<br>                    current.await();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;------&quot;</span> + message);<br>                currentOrder++;<br>                <span class="hljs-comment">// 使用signal()唤醒下一个线程</span><br>                next.signal();<br>                <span class="hljs-comment">// 锁释放</span><br>                lock.unlock();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-3-使用信号量"><a href="#5-3-使用信号量" class="headerlink" title="5.3 使用信号量"></a>5.3 使用信号量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphoreA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphoreB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphoreC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SemaphorePrintThread</span>(semaphoreA, semaphoreB, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>));<br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SemaphorePrintThread</span>(semaphoreB, semaphoreC, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">1</span>));<br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SemaphorePrintThread</span>(semaphoreC, semaphoreA, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">2</span>));<br><br>threadA.start();<br>threadB.start();<br>threadC.start();<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphorePrintThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Semaphore current;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Semaphore next;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentOrder</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String message;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> order;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SemaphorePrintThread</span><span class="hljs-params">(Semaphore current, Semaphore next, String message, <span class="hljs-type">int</span> order)</span> &#123;<br>        <span class="hljs-built_in">this</span>.current = current;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.message = message;<br>        <span class="hljs-built_in">this</span>.order = order;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 核心：通过获取当前线程的信号量来确定是否轮到自己执行。</span><br><span class="hljs-comment">                 * 在执行完打印操作后，释放下一个线程的信号量，从而实现线程的交叉打印。</span><br><span class="hljs-comment">                 */</span><br>                current.acquire();      <span class="hljs-comment">// 获取当前线程的信号量</span><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;------&quot;</span> + message);<br>                currentOrder++;<br>                next.release();         <span class="hljs-comment">//释放下一个线程的信号量</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-按照顺序打印线程"><a href="#6-按照顺序打印线程" class="headerlink" title="6. 按照顺序打印线程"></a>6. 按照顺序打印线程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 创建线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;t1&quot;</span>);<br>        &#125;) ;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t1.join();                          <span class="hljs-comment">// 加入线程t1,只有t1线程执行完毕以后，再次执行该线程</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;t2&quot;</span>);<br>        &#125;) ;<br><br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t2.join();                              <span class="hljs-comment">// 加入线程t2,只有t2线程执行完毕以后，再次执行该线程</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;t3&quot;</span>);<br>        &#125;) ;<br><br>        <span class="hljs-comment">// 启动线程</span><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>xx.join()：会等到xx线程执行完毕之后，当前线程才能执行</p></blockquote><h1 id="7-notify和notifyAll"><a href="#7-notify和notifyAll" class="headerlink" title="7. notify和notifyAll"></a>7. notify和notifyAll</h1><ul><li>notifyAll：唤醒所有wait的线程</li><li>notify：只随机唤醒一个 wait 线程</li></ul><h1 id="8-wait和sleep"><a href="#8-wait和sleep" class="headerlink" title="8. wait和sleep"></a>8. wait和sleep</h1><ul><li><p>相同点：</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞1状态</li></ul></li><li><p>不同点：</p><ul><li><p>方法归属不同</p><ul><li><p>sleep(long) 是 Thread 的静态方法</p></li><li><p>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</p></li><li><p>醒来时机不同</p><ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li><li>它们都可以被打断唤醒</li></ul></li></ul></li><li><p>锁特性不同（重点）</p><ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制<ul><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ul></li><li><p>wait必须要配合synchronized使用</p></li></ul></li></ul><h1 id="9-synchornized底层原理"><a href="#9-synchornized底层原理" class="headerlink" title="9. synchornized底层原理"></a>9. synchornized底层原理</h1><ul><li><p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住</p></li><li><p>使用<code>javap -v xx.class</code>  查看class字节码信息</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505164915549.png" alt="image-20240505164915549"></p><p>可以看到有两次解锁的行为，即：防止在加锁之后执行出现异常而没有正常的释放掉锁</p></li></ul><h2 id="9-1-Monitor"><a href="#9-1-Monitor" class="headerlink" title="9.1 Monitor"></a>9.1 Monitor</h2><ul><li>Monitor 被翻译为监视器，是由jvm提供，c++语言实现。</li><li>lMonitor实现的锁属于重量级锁，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</li></ul><h3 id="9-1-1-Monitor结构"><a href="#9-1-1-Monitor结构" class="headerlink" title="9.1.1. Monitor结构"></a>9.1.1. Monitor结构</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505165432986.png" alt="image-20240505165432986"></p><ul><li>Owner：存储当前获取锁的线程的，只能有一个线程可以获取</li><li>EntryList：关联没有抢到锁的线程，处于Blocked状态的线程</li><li>WaitSet：关联调用了wait方法的线程，处于Waiting状态的线程</li></ul><h3 id="9-1-3-如何将对象关联到Monitor"><a href="#9-1-3-如何将对象关联到Monitor" class="headerlink" title="9.1.3 如何将对象关联到Monitor"></a>9.1.3 如何将对象关联到Monitor</h3><ul><li><p>在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505165755790.png" alt="image-20240505165755790"></p></li><li><p>即：通过对象头的mark word就可以实现和monitor关联</p></li></ul><h4 id="9-1-3-1-MarkWord"><a href="#9-1-3-1-MarkWord" class="headerlink" title="9.1.3.1 MarkWord"></a>9.1.3.1 MarkWord</h4><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505165825925.png" alt="image-20240505165825925"></p><ul><li>hashcode：25位的对象标识Hash码</li><li>age：对象分代年龄占4位（表示GC之后存活的次数）</li><li>biased_lock：偏向锁标识，占1位 ，0表示没有开始偏向锁，1表示开启了偏向锁</li><li>thread：持有偏向锁的线程ID，占23位</li><li>epoch：偏向时间戳，占2位（获得锁的时间戳）</li><li>ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针，占30位</li><li>ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针，占30位</li></ul><h2 id="9-2-偏向锁"><a href="#9-2-偏向锁" class="headerlink" title="9.2 偏向锁"></a>9.2 偏向锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>      <span class="hljs-comment">// 同步块 A</span><br>      method2();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>      <span class="hljs-comment">// 同步块 B</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。（CAS消耗CPU）</li><li>如果这个锁只被一个线程持有，没有与任何其他线程形成竞争，那么此时锁为偏向锁</li><li>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505173521643.png" alt="image-20240505173521643"></p><ul><li>第一次使用CAS将当前线程id设置到对象头的markword中，当第二次再进入的时候，当前线程发现对象头中markword中的线程id是自己的，就不会再进行CAS了</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505173715463.png" alt="image-20240505173715463"></p><h2 id="9-3-轻量级锁"><a href="#9-3-轻量级锁" class="headerlink" title="9.3 轻量级锁"></a>9.3 轻量级锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>      <span class="hljs-comment">// 同步块 A</span><br>      method2();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>      <span class="hljs-comment">// 同步块 B</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="9-3-1-加锁过程"><a href="#9-3-1-加锁过程" class="headerlink" title="9.3.1 加锁过程"></a>9.3.1 加锁过程</h3><ol><li><p>在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505172734245.png" alt="image-20240505172734245"></p><blockquote><p>如果此时对象没有被任何线程持有作为锁，那么<strong>后面三位是001</strong></p></blockquote></li><li><p>通过CAS指令将Lock Record的地址存储在对象头的mark word中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505172833608.png" alt="image-20240505172833608"></p><blockquote><p>发现obj对象没有被作为锁，那么就进行CAS交换，与obj的markword交换lock record第一部分</p></blockquote></li><li><p>如果是当前线程已经持有该锁了，代表这是一次锁重入。还是会进行一次CAS，但是不会真修改对象头中markword中的地址，只是将Lock Record的markwork设为null，起到了一个重入计数器的作用。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505173036180.png" alt="image-20240505173036180"></p></li><li><p>如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁。</p></li></ol><h3 id="9-3-2-解锁过程"><a href="#9-3-2-解锁过程" class="headerlink" title="9.3.2 解锁过程"></a>9.3.2 解锁过程</h3><ol><li>遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record。</li><li>如果Lock Record的Mark Word为null，代表这是一次重入，将obj设置为null后continue。</li><li>如果Lock Record的 Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为无锁状态。如果失败则膨胀为重量级锁。</li></ol><h2 id="9-4-锁升级"><a href="#9-4-锁升级" class="headerlink" title="9.4 锁升级"></a>9.4 锁升级</h2><ul><li>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</li><li>锁升级：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁<ul><li>倾向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</li><li>轻量级锁：线程加锁的时间是错开的（不会形成竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</li><li>重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</li></ul></li><li>只要发生了锁竞争就一定会升级为重量级锁</li></ul><h1 id="10-Java内存模型"><a href="#10-Java内存模型" class="headerlink" title="10. Java内存模型"></a>10. Java内存模型</h1><ul><li>JMM(Java Memory Model)Java内存模型，定义了共享内存中多线程程序读写操作的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</li><li>JMM把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）</li><li>线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505174210333.png" alt="image-20240505174210333"></p><h1 id="11-CAS"><a href="#11-CAS" class="headerlink" title="11. CAS"></a>11. CAS</h1><ul><li>CAS的全称是： Compare And Swap(比较再交换)，它体现的一种乐观锁的思想，在无锁情况下保证线程操作共享数据的原子性。</li><li>一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当旧的预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</li><li>如果CAS操作失败，通过自旋的方式等待并再次尝试，直到成功</li><li>cas的底层：CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的CAS（原子操作）</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505174806520.png" alt="image-20240505174806520"></p><ul><li>CAS使用到的地方很多：AQS框架、AtomicXXX类</li></ul><h1 id="12-volatile"><a href="#12-volatile" class="headerlink" title="12. volatile"></a>12. volatile</h1><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p><ul><li>保证线程间的可见性</li><li>禁止进行指令重排序</li></ul><h2 id="12-1-线程间可见性"><a href="#12-1-线程间可见性" class="headerlink" title="12.1 线程间可见性"></a>12.1 线程间可见性</h2><ul><li><p>用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</p></li><li><pre><code class="java">static volatile boolean stop = false;    public static void main(String[] args) &#123;        new Thread(() -&gt; &#123;            try &#123;                Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            stop = true;            System.out.println(Thread.currentThread().getName()+&quot;：modify stop to true...&quot;);        &#125;,&quot;t1&quot;).start();        new Thread(() -&gt; &#123;            try &#123;                Thread.sleep(200);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName()+&quot;：&quot;+stop);        &#125;,&quot;t2&quot;).start();        new Thread(() -&gt; &#123;            int i = 0;            while (!stop) &#123;                i++;            &#125;            System.out.println(&quot;stopped... c:&quot;+ i);        &#125;,&quot;t3&quot;).start();    &#125;<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>  - 在该断代码中，t2线程能在t1线程修改完之后打印stop为<span class="hljs-literal">true</span>，但是t3线程不会停止，因为因为在JVM虚拟机中有一个JIT（即时编译器）给代码做了优化。将代码`<span class="hljs-keyword">while</span> (!stop)`优化为了`<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)`<br>  - 因此如果想让t3线程在stop修改为<span class="hljs-literal">true</span>之后停止，那么在修饰stop变量的时候加上**<span class="hljs-keyword">volatile</span>**,当前告诉 jit，不要对 <span class="hljs-keyword">volatile</span> 修饰的变量做优化<br><br><br><br>## <span class="hljs-number">12.2</span> 禁止指令重排<br><br>- 用 <span class="hljs-keyword">volatile</span> 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果<br><br>- ```java<br>  @JCStressTest<br>  @<span class="hljs-built_in">Outcome</span>(id = &#123;<span class="hljs-string">&quot;0, 0&quot;</span>, <span class="hljs-string">&quot;1, 1&quot;</span>, <span class="hljs-string">&quot;0, 1&quot;</span>&#125;, expect = Expect.ACCEPTABLE, desc = <span class="hljs-string">&quot;ACCEPTABLE&quot;</span>)<br>  @<span class="hljs-built_in">Outcome</span>(id = <span class="hljs-string">&quot;1, 0&quot;</span>, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="hljs-string">&quot;INTERESTING&quot;</span>)<br>  @State<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReorderTest</span> &#123;<br>  <br>      <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> x;<br>      <span class="hljs-type">int</span> y;<br>  <br>      @<span class="hljs-function">Actor</span><br><span class="hljs-function">      <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">()</span> </span>&#123;<br>          x = <span class="hljs-number">1</span>;<br>          y = <span class="hljs-number">1</span>;<br>      &#125;<br>  <br>      @<span class="hljs-function">Actor</span><br><span class="hljs-function">      <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(II_Result r)</span> </span>&#123;<br>          r.r1 = y;<br>          r.r2 = x;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>- 可能得执行结果：  - 先执行actor2获取结果，结果：0,0  - 先执行actor1中的第一行代码，然后执行actor2获取结果，结果：0,1  - 先执行actor1中所有代码，然后执行actor2获取结果，结果：1,1  - 先执行actor1中第二行代码，然后执行actor2获取结果，结果：1,0（此时已经发生指令重排了）</code></pre></li><li><p>那么将变量添加到volatile可以防止指令重排</p><ul><li><p>写操作：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505180751663.png" alt="image-20240505180751663"></p></li><li><p>读操作：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505180803504.png" alt="image-20240505180803504"></p></li></ul></li><li><p>加volatile的技巧：</p><ul><li>写变量的时候让volatile修饰的变量的在代码最后位置</li><li>读变量的时候让volatile修饰的变量的在代码最开始位置</li></ul></li></ul><h1 id="13-AQS"><a href="#13-AQS" class="headerlink" title="13. AQS"></a>13. AQS</h1><ul><li><p>全称是 AbstractQueuedSynchronizer，即抽象队列同步器。它是构建锁或者其他同步组件的基础框架</p></li><li><p>常见的实现类：</p><ul><li>ReentrantLock      阻塞式锁</li><li>Semaphore        信号量</li><li>CountDownLatch   倒计时锁</li></ul></li><li><p>与synchronized区别：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505181024516.png" alt="image-20240505181024516"></p></li></ul><h2 id="13-1-工作机制"><a href="#13-1-工作机制" class="headerlink" title="13.1 工作机制"></a>13.1 工作机制</h2><ul><li>在该类中存在一个state变量，每个线程通过CAS的方式去改变state的值</li><li>state为0表示无锁、state为1表示有锁 </li><li>在AQS内部还有一个队列，当有线程A持有了锁，其他线程会加入到队列中，并且使用HEAD和TAIL进行标记，HEAD指向进入队列最早的元素，TAIL指向进入队列最晚的元素</li><li>新的线程与队列中的线程共同来抢资源，是非公平锁</li><li>新的线程到队列中等待，只让队列中的head线程获取锁，是公平锁</li></ul><h1 id="14-ReentrantLock原理"><a href="#14-ReentrantLock原理" class="headerlink" title="14. ReentrantLock原理"></a>14. ReentrantLock原理</h1><ul><li><p>特点：</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置公平锁</li><li>支持多个条件变量</li><li>与synchronized一样，都支持重入</li></ul></li><li><pre><code class="java">//创建锁对象ReentrantLock lock = new ReentrantLock();try &#123;      // 获取锁  lock.lock();&#125; finally &#123;  // 释放锁  lock.unlock();&#125;<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">ReentrantLock</span>主要利用<span class="hljs-selector-tag">CAS</span>+<span class="hljs-selector-tag">AQS</span>队列来实现。它支持公平锁和非公平锁，两者的实现类似<br><br>  构造方法接受一个可选的公平参数（默认非公平锁），<br><br>  <span class="hljs-selector-tag">-</span> 当设置为<span class="hljs-selector-tag">true</span>时，表示公平锁，否则为非公平锁。<br>  <span class="hljs-selector-tag">-</span> 公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量<br><br><span class="hljs-selector-tag">-</span> !<span class="hljs-selector-attr">[image-20240505191418263]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505191418263.png)</span><br><br>  - 线程来抢锁后使用cas的方式修改state状态，修改状态成功为<span class="hljs-number">1</span>，则让exclusiveOwnerThread属性指向当前线程，获取锁成功<br>  - 假如修改状态失败，则会进入双向队列中等待，head指向双向队列头部，tail指向双向队列尾部<br>  - 当exclusiveOwnerThread为null的时候，则会唤醒在双向队列中等待的线程<br>  - 公平锁则体现在按照先后顺序获取锁，非公平体现在不在排队的线程也可以抢锁<br><br># <span class="hljs-number">15</span>. synchoronized和lock区别<br><br>- 语法层面<br>  - synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现<br>  - Lock 是接口，源码由 jdk 提供，用 java 语言实现<br>  - 使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁<br>- 功能层面<br>  - 二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能<br>  - Lock 提供了许多 synchronized 不具备的功能，例如公平锁、可打断、可超时、多条件变量<br>  - Lock 有适合不同场景的实现，如 ReentrantLock， <span class="hljs-built_in">ReentrantReadWriteLock</span>(读写锁)<br>- 性能层面<br>  - 在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能还行<br>  - 在竞争激烈时，Lock 的实现通常会提供更好的性能<br><br># <span class="hljs-number">16</span>. 死锁<br><br>- 死锁：一个线程需要同时获取多把锁，这时就容易发生死锁<br><br>  <span class="hljs-built_in">``</span>`java<br>  Object A = new <span class="hljs-built_in">Object</span>();<br>          Object B = new <span class="hljs-built_in">Object</span>();<br>          Thread t1 = new <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br>              synchronized (A) &#123;<br>                  System.out.<span class="hljs-built_in">println</span>(Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">getName</span>()+<span class="hljs-string">&quot;-lock A&quot;</span>);<br>                  try &#123;<br>                      <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>                  &#125; catch (InterruptedException e) &#123;<br>                      throw new <span class="hljs-built_in">RuntimeException</span>(e);<br>                  &#125;<br>                  synchronized (B) &#123;<br>                      System.out.<span class="hljs-built_in">println</span>(Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">getName</span>()+<span class="hljs-string">&quot;-lock B&quot;</span>);<br>                      System.out.<span class="hljs-built_in">println</span>(Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">getName</span>()+<span class="hljs-string">&quot;-操作...&quot;</span>);<br>                  &#125;<br>              &#125;<br>          &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>  <br>          Thread t2 = new <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br>              synchronized (B) &#123;<br>                  System.out.<span class="hljs-built_in">println</span>(Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">getName</span>()+<span class="hljs-string">&quot;-lock B&quot;</span>);<br>                  try &#123;<br>                      <span class="hljs-built_in">sleep</span>(<span class="hljs-number">500</span>);<br>                  &#125; catch (InterruptedException e) &#123;<br>                      throw new <span class="hljs-built_in">RuntimeException</span>(e);<br>                  &#125;<br>                  synchronized (A) &#123;<br>                      System.out.<span class="hljs-built_in">println</span>(Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">getName</span>()+<span class="hljs-string">&quot;-lock A&quot;</span>);<br>                      System.out.<span class="hljs-built_in">println</span>(Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">getName</span>()+<span class="hljs-string">&quot;-操作...&quot;</span>);<br>                  &#125;<br>              &#125;<br>          &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>          t1.<span class="hljs-built_in">start</span>();<br>          t2.<span class="hljs-built_in">start</span>();<br></code></pre></td></tr></table></figure></code></pre></li><li><p>当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack</p><ul><li><p>jps：输出JVM中运行的进程状态信息</p></li><li><p>jstack：查看java进程内线程的堆栈信息</p></li><li><p>第一步：输入jps查看运行的线程</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505191842040.png" alt="image-20240505191842040"></p></li><li><p>第二步：使用jstack查看线程运行的情况，<code>jstack -I tid</code></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505191853641.png" alt="image-20240505191853641"></p></li></ul></li></ul><h1 id="17-ConcurrentHasMap"><a href="#17-ConcurrentHasMap" class="headerlink" title="17. ConcurrentHasMap"></a>17. ConcurrentHasMap</h1><ul><li><p>ConcurrentHashMap 是一种线程安全的高效Map集合</p><p>底层数据结构：</p><ul><li>JDK1.7底层采用分段的数组+链表实现</li><li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。</li></ul></li><li><p>在JDK1.7中：分段数组大小是不能变的</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505192021063.png" alt="image-20240505192021063"></p><ul><li><p>当有元素PUT的时候，会经过hash计算找到在Segment数组中的下标，然后使用ReentrantLock锁住当前Segment（如果在高并发的时候，多个线程就使用CAS的方式尝试获取锁 ），再经过hash值判断要放在hashEntry的哪个位置</p><p> <img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505192423221.png" alt=" "></p></li></ul></li><li><p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：数组+红黑树+链表，采用 CAS + Synchronized来保证并发安全进行实现</p><ul><li><p>使用CAS的方式控制相乘对数组节点的添加</p></li><li><p>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题 , 效率得到提升</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505192647499.png" alt="image-20240505192647499"></p></li></ul></li></ul><h1 id="18-并发三大特性"><a href="#18-并发三大特性" class="headerlink" title="18. 并发三大特性"></a>18. 并发三大特性</h1><h2 id="18-1-原子性"><a href="#18-1-原子性" class="headerlink" title="18.1 原子性"></a>18.1 原子性</h2><ul><li>一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行</li><li>解决：使用sychronized加锁或者使用lock锁，保证只有一个线程操作临界区</li></ul><h2 id="18-2-可见性"><a href="#18-2-可见性" class="headerlink" title="18.2 可见性"></a>18.2 可见性</h2><ul><li>让一个线程对共享变量的修改对另一个线程可见</li><li>解决：volatile关键字</li></ul><h2 id="18-3-有序性"><a href="#18-3-有序性" class="headerlink" title="18.3 有序性"></a>18.3 有序性</h2><ul><li>指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</li><li>解决：volatile关键字</li></ul><h1 id="19-线程池"><a href="#19-线程池" class="headerlink" title="19. 线程池"></a>19. 线程池</h1><ul><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure></li><li><p>核心参数：</p><ul><li>corePoolSize 核心线程数目</li><li>maximumPoolSize 最大线程数目 &#x3D; (核心线程+非核心线程的最大数目)</li><li>keepAliveTime 生存时间 - 非核心线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit 时间单位 - 非核心线程的生存时间单位，如秒、毫秒等</li><li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</li></ul></li><li><p>执行流程：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505193832756.png" alt="image-20240505193832756"></p><ul><li><p>当有任务提交过来的时候，首先看核心线程是否有可用的，</p><ul><li>如果核心线程还有可用的，直接是使用核心线程处理</li><li>如果核心线程没有可用的，此时查看阻塞队列是否已满<ul><li>阻塞队列没有满，那么将任务存入阻塞队列</li><li>阻塞队列已经满了，<ul><li>如果当前线程数已经大于最大线程数了，那么直接采用对应的拒绝策略处理</li><li>如果当前线程数小于等于最大线程数，那么就创建非核心线程执行任务。</li></ul></li></ul></li><li>在核心线程和非核心线程执行完成任务之后，都会检测阻塞队列是否有任务需要执行</li></ul></li><li><p>常见的拒绝策略：</p><ul><li>AbortPolicy：直接抛出异常，默认策略；</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li><li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li>DiscardPolicy：直接丢弃任务；</li></ul></li></ul></li></ul><h1 id="20-阻塞队列"><a href="#20-阻塞队列" class="headerlink" title="20. 阻塞队列"></a>20. 阻塞队列</h1><ul><li>ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。</li><li>LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。</li><li>DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</li><li>SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</li><li>ArrayBlockingQueue和LinkedBlockingQueue的区别：<ul><li>LinkedBlockingQueue默认无界，支持有界；ArrayBlockingQueue强制有界</li><li>底层是链表；底层是数组</li><li>有头尾两把锁，只会锁住这两个位置；一把锁，锁住整个数组</li></ul></li></ul><h1 id="21-如何确定线程池中核心线程数"><a href="#21-如何确定线程池中核心线程数" class="headerlink" title="21. 如何确定线程池中核心线程数"></a>21. 如何确定线程池中核心线程数</h1><ul><li>高并发、任务执行时间短（ CPU核数+1 ），减少线程上下文的切换并发不高、任务执行时间长</li><li>IO密集型（文件读写、DB读写、网络请求等）任务(CPU核数 * 2 + 1)</li><li>计算密集型（计算型代码、Bitmap转换、Gson转换等）任务（ CPU核数+1 ）</li></ul><h1 id="22-线程池种类"><a href="#22-线程池种类" class="headerlink" title="22. 线程池种类"></a>22. 线程池种类</h1><ul><li><p>newFixedThreadPool：固定线程数的线程池</p><ul><li><pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads) &#123;          return new ThreadPoolExecutor(nThreads,                                   nThreads,                                  0L,                                  TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());&#125;<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><br>  - 核心线程数与最大线程数一样，没有救急线程<br><br>  - 阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE<br><br>  - 不推荐使用：原因：因为阻塞队列是LinkedBlockingQueue，会无线扩容，会造成堆内存溢出问题。<br><br>- <span class="hljs-keyword">new</span><span class="hljs-type">SingleThreadExecutor</span>：单线程化的线程池，只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO)执行<br><br>  ```java<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">SingleThreadExecutor</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">FinalizableDelegatedExecutorService</span>(<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                               <span class="hljs-number">0</span>L, <br>                               TimeUnit.MILLISECONDS,                                <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>核心线程数和最大线程数都是1</p></li><li><p>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</p></li><li><p>不推荐使用：原因：因为阻塞队列是LinkedBlockingQueue，会无线扩容，会造成堆内存溢出问题。</p></li></ul></li><li><p>newCachedThreadPool：可缓存线程池；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>核心线程数为0</li><li>最大线程数是Integer.MAX_VALUE</li><li>阻塞队列为SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</li><li>不推荐使用：原因：因为可以大量线程，导致栈溢。</li></ul></li><li><p>ScheduledThreadPoolExecutor：延迟&#x2F;周期任务线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>  <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, ThreadFactory threadFactory)</span> &#123;<br>  <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, RejectedExecutionHandler handler)</span> &#123;<br>  <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), handler);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                                   ThreadFactory threadFactory,</span><br><span class="hljs-params">                                   RejectedExecutionHandler handler)</span> &#123;<br><span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>(), threadFactory, handler);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="23-CountdownLatch"><a href="#23-CountdownLatch" class="headerlink" title="23. CountdownLatch"></a>23. CountdownLatch</h1><ul><li><p>CountDownLatch（闭锁&#x2F;倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）</p></li><li><p>其中构造参数用来初始化等待计数值</p></li><li><p>await() 用来等待计数归零</p></li><li><p>countDown() 用来让计数减一</p></li><li><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240505195814336.png" alt="image-20240505195814336"></p></li><li><pre><code class="java">public class CountDownLatchDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        //初始化了一个倒计时锁 参数为 3        CountDownLatch latch = new CountDownLatch(3);        new Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName()+&quot;-begin...&quot;);            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            //count--            latch.countDown();            System.out.println(Thread.currentThread().getName()+&quot;-end...&quot; +latch.getCount());        &#125;).start();        new Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName()+&quot;-begin...&quot;);            try &#123;                Thread.sleep(2000);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            //count--            latch.countDown();            System.out.println(Thread.currentThread().getName()+&quot;-end...&quot; +latch.getCount());        &#125;).start();        new Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName()+&quot;-begin...&quot;);            try &#123;                Thread.sleep(1500);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            //count--            latch.countDown();            System.out.println(Thread.currentThread().getName()+&quot;-end...&quot; +latch.getCount());        &#125;).start();        String name = Thread.currentThread().getName();        System.out.println(name + &quot;-waiting...&quot;);        //等待其他线程完成        latch.await();        System.out.println(name + &quot;-wait end...&quot;);    &#125;    &#125;<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-meta"># 24. Semaphore</span><br><br>- 使用Semaphore，可以通过其限制执行的线程数量<br><br>- 使用步骤：<br><br>  - 创建Semaphore对象，可以给一个容量<br>  - semaphore.acquire()： 请求一个信号量，这时候的信号量个数<span class="hljs-number">-1</span>（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）<br>  - semaphore.release()：释放一个信号量，此时信号量个数+<span class="hljs-number">1</span><br><br>- ```java<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreCase</span> &#123;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>          <span class="hljs-comment">// 1. 创建 semaphore 对象</span><br>          Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);<br>          <span class="hljs-comment">// 2. 10个线程同时运行</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>              <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                  <span class="hljs-keyword">try</span> &#123;<br>                      <span class="hljs-comment">// 3. 获取许可，计数-1</span><br>                      semaphore.acquire();<br>                  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                      e.printStackTrace();<br>                  &#125;<br>                  <span class="hljs-keyword">try</span> &#123;<br>                      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>                      <span class="hljs-keyword">try</span> &#123;<br>                          Thread.sleep(<span class="hljs-number">1000</span>);<br>                      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                          e.printStackTrace();<br>                      &#125;<br>                      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;end...&quot;</span>);<br>                  &#125; <span class="hljs-keyword">finally</span> &#123;<br>                      <span class="hljs-comment">// 4. 释放许可  计数+1</span><br>                      semaphore.release();<br>                  &#125;<br>              &#125;).start();<br>          &#125;<br>      &#125;<br>  <br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul><h1 id="25-ThreadLocal"><a href="#25-ThreadLocal" class="headerlink" title="25. ThreadLocal"></a>25. ThreadLocal</h1><ul><li>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离</li><li>每个线程持有一个ThreadLocalMap对象，ThreadLocalMap中为每一个线程都维护了一个数组table(存储数据)</li><li><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20230722171217698.png" alt="image-20230722171217698"></li></ul><h2 id="25-1-set"><a href="#25-1-set" class="headerlink" title="25.1 set"></a>25.1 set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">//获取当前线程对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//根据当前线程对象，获取ThreadLocal中的ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>  <span class="hljs-comment">//如果map存在</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>       <span class="hljs-comment">//执行map中的set方法，进行数据存储</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//否则创建ThreadLocalMap，并存值</span><br>        createMap(t, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>  <span class="hljs-comment">//内部成员数组，INITIAL_CAPACITY值为16的常量</span><br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>  <span class="hljs-comment">//位运算，结果与取模相同，计算出需要存放的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>    table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>    size = <span class="hljs-number">1</span>;<br>    setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-2-get"><a href="#25-2-get" class="headerlink" title="25.2 get"></a>25.2 get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//获取当前线程对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>  <span class="hljs-comment">//获取当前线程对象</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//获取ThreadLocalMap中对应的Entry对象</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>          <span class="hljs-comment">//获取并返回value</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>  <span class="hljs-comment">//确定数组下标位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">//得到该位置上的Entry</span><br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-3-remove"><a href="#25-3-remove" class="headerlink" title="25.3 remove"></a>25.3 remove</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>  <span class="hljs-comment">//确定数组下标位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 遍历该索引位置下的所有Entry。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>      <span class="hljs-comment">// 检查每个Entry中的值是否与键相等。如果找到相等的值，将其清除</span><br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            e.clear();<br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-4-ThreadLocal的内存泄漏"><a href="#25-4-ThreadLocal的内存泄漏" class="headerlink" title="25.4 ThreadLocal的内存泄漏"></a>25.4 ThreadLocal的内存泄漏</h2><ul><li><p>每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中<strong>key为使用弱引用</strong>，value为强引用</p></li><li><pre><code class="java">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;  /** The value associated with this ThreadLocal. */  Object value;  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;      super(k);      value = v;  &#125;&#125;</code></pre></li><li><p>因此在GC的时候就会进行回收掉key，而value不会被回收，因此造成内存泄漏</p></li><li><p>解决：每次使用完成之后都调用remove方法</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试-JVM</title>
    <link href="/%E9%9D%A2%E8%AF%95-JVM/594ac1719190/"/>
    <url>/%E9%9D%A2%E8%AF%95-JVM/594ac1719190/</url>
    
    <content type="html"><![CDATA[<h1 id="1-JVM是什么"><a href="#1-JVM是什么" class="headerlink" title="1. JVM是什么"></a>1. JVM是什么</h1><ul><li>Java Virtual Machine Java程序的运行环境（java二进制字节码的运行环境）</li><li>优点：<ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制（对比C）</li></ul></li></ul><h1 id="2-JVM组成"><a href="#2-JVM组成" class="headerlink" title="2. JVM组成"></a>2. JVM组成</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504164337076.png" alt="image-20240504164337076"></p><ul><li>在运行数据区中，分为：<ul><li>元空间</li><li>堆</li><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul></li><li>在运行数据区中，浅粉色是线程私有的，其他是线程共享</li></ul><h2 id="2-1-方法区-元空间"><a href="#2-1-方法区-元空间" class="headerlink" title="2.1 方法区&#x2F;元空间"></a>2.1 方法区&#x2F;元空间</h2><ul><li>主要存储类的信息、运行时常量池</li><li>虚拟机启动的时候创建，关闭虚拟机时释放</li><li>如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504165801894.png" alt="image-20240504165801894"></p><ul><li>从JDK8之后，将方法区就从堆移至本地内存。</li><li>默认情况，元空间大小只会受到本地内存限制。</li></ul><h3 id="2-1-1-常量池"><a href="#2-1-1-常量池" class="headerlink" title="2.1.1 常量池"></a>2.1.1 常量池</h3><ul><li>可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li><li>可以使用命令<code>javap -v xxx.class</code>查看字节码结构（类的基本信息、常量池、方法定义）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HxdsMisApiApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        SpringApplication.run(HxdsMisApiApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>经过javap之后，代码会被解释为机器指令</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504170307447.png" alt="image-20240504170307447"></p><ul><li><p>左边：字节码行号，当处于cpu切片的时候，程序计数器会记录当前运行的位置。</p></li><li><p>右边：符号引用，指向常量池中的内容。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504170643663.png" alt="image-20240504170643663"></p></li></ul><h3 id="2-1-2-运行常量池"><a href="#2-1-2-运行常量池" class="headerlink" title="2.1.2 运行常量池"></a>2.1.2 运行常量池</h3><ul><li>当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址（内存地址）。</li></ul><h2 id="2-2-堆"><a href="#2-2-堆" class="headerlink" title="2.2 堆"></a>2.2 堆</h2><ul><li>主要用来保存对象实例，数组等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504171001857.png" alt="image-20240504171001857"></p><ul><li>年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到老年代区间。</li><li>老年代主要保存生命周期长的对象，一般是一些老的对象</li></ul><h2 id="2-3-程序计数器"><a href="#2-3-程序计数器" class="headerlink" title="2.3 程序计数器"></a>2.3 程序计数器</h2><ul><li>线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。</li><li>同样通过命令<code>javap -v xxx.class</code>打印堆栈大小，局部变量的数量和方法的参数。</li></ul><h2 id="2-4-虚拟机栈"><a href="#2-4-虚拟机栈" class="headerlink" title="2.4 虚拟机栈"></a>2.4 虚拟机栈</h2><ul><li><p>每个线程运行时所需要的内存，称为虚拟机栈，先进后出</p></li><li><p>每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存</p></li><li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p></li><li><p>当栈帧弹出之后，栈内存会释放；如果有持有的引用，对应的堆内存会被回收</p></li><li><p>栈内存并非越大越好，栈帧过大会导致线程数变少；默认为1024K</p></li><li><p>如何判断方法内的局部变量是否线程安全？</p><ul><li><p>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504171823999.png" alt="image-20240504171823999"></p><p>虽然方法内部创建一个对象，但是每个线程进入这个方法都会创建对应的栈帧，每个栈帧中有自己的对象。</p></li><li><p>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504171953061.png" alt="image-20240504171953061"></p><ul><li>m2方法有接收参数，如果在外部使用不同对象操作这个对象，会引起线程不安全</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504172058019.png" alt="image-20240504172058019"></p><ul><li>m3方法最后变量进行了返回，逃离了作用范围，也会引起线程安全问题。</li></ul></li><li><p>当进行递归调用，没有设置对应的break时，会造成栈溢出。如果栈帧过大，也会引起栈溢出（概率很低）</p></li></ul></li></ul><h3 id="2-4-1-堆栈区别"><a href="#2-4-1-堆栈区别" class="headerlink" title="2.4.1 堆栈区别"></a>2.4.1 堆栈区别</h3><ul><li><p>栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。</p></li><li><p>堆会GC垃圾回收，而栈不会。</p></li><li><p>栈内存是线程私有的，而堆内存是线程共有的。</p></li><li><p>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p><p>   栈空间不足：java.lang.StackOverFlowError。</p><p>   堆空间不足：java.lang.OutOfMemoryError。</p></li></ul><h2 id="2-5-本地方法栈"><a href="#2-5-本地方法栈" class="headerlink" title="2.5 本地方法栈"></a>2.5 本地方法栈</h2><ul><li>保存的是native方法的信息，当一个jvm创建的线程调用native方法后，jvm不会在虚拟机栈中为该线程创建栈帧，而是简单的动态链接并直接调用该方法；</li></ul><h1 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3. 类加载器"></a>3. 类加载器</h1><ul><li>JVM只会运行二进制文件，类加载器的作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。</li><li>从上到下：<ul><li>启动类加载器</li><li>扩展类加载器</li><li>应用类加载器</li><li>自定义类加载器</li></ul></li><li><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504173349026.png" alt="image-20240504173349026"></li></ul><h2 id="3-1-双亲委派"><a href="#3-1-双亲委派" class="headerlink" title="3.1 双亲委派"></a>3.1 双亲委派</h2><ul><li>加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类。</li><li>即：在加载一个类的时候，首先会一层层向上请求加载，当上层无法加载的时候，才会让下层进行加载。</li><li>使用双亲委派的优点：<ul><li>通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</li><li>为了安全，保证类库API不会被修改</li></ul></li></ul><h2 id="3-2-类加载流程"><a href="#3-2-类加载流程" class="headerlink" title="3.2 类加载流程"></a>3.2 类加载流程</h2><ul><li><p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：<strong>加载、验证、准备、解析、初始化、使用和卸载</strong>这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504173826153.png" alt="image-20240504173826153"></p></li></ul><h3 id="3-2-1-加载"><a href="#3-2-1-加载" class="headerlink" title="3.2.1 加载"></a>3.2.1 加载</h3><ul><li><p>通过全类名，获取类的二进制数据流。</p></li><li><p>解析类的二进制数据流为方法区内的数据结构（Java类模型） </p></li><li><p>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</p></li><li><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504174116013.png" alt="image-20240504174116013"></p><blockquote><ul><li><p>现在有一个Person类，被类加载器加载之后进入运行时数据区。</p></li><li><p>在方法区&#x2F;元空间存储这个类的信息 （构造函数、方法、字段…  ）</p></li><li><p>在堆中开辟一块空间存储Person.class的Class对象，同时会作为这个类的各种数据的访问入口。</p></li><li><p>以后创建Person类的时候就会基于这个Class对象进行创建，创建出来的每个Person的对象头都会指向这个Class对象。但是Class对象中的信息存储在元空间，</p></li></ul></blockquote></li></ul><h3 id="3-2-2-验证"><a href="#3-2-2-验证" class="headerlink" title="3.2.2 验证"></a>3.2.2 验证</h3><ul><li><strong>验证类是否符合</strong> <strong>JVM****规范，安全性检查</strong></li><li>验证的内容：<ul><li>文件格式是否错误、语法是否错误、字节码是否合规</li><li>符号引用验证，即：Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法，检查它们是否存在；也就是验证常量池中的符号引用的内容是否存在</li></ul></li></ul><h3 id="3-2-3-准备"><a href="#3-2-3-准备" class="headerlink" title="3.2.3 准备"></a>3.2.3 准备</h3><ul><li><strong>为类变量分配内存并设置类变量初始值</strong><ul><li>static变量，分配空间在准备阶段完成（设置默认值），赋值在初始化阶段完成</li><li>static变量是final的基本类型，以及字符串常量，值已确定，赋值在准备阶段完成</li><li>static变量是final的引用类型，那么赋值也会在初始化阶段完成</li></ul></li></ul><h3 id="3-2-4-解析"><a href="#3-2-4-解析" class="headerlink" title="3.2.4 解析"></a>3.2.4 解析</h3><ul><li><strong>把类中的符号引用转换为直接引用</strong></li><li>例如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。</li></ul><h3 id="3-2-5-初始化"><a href="#3-2-5-初始化" class="headerlink" title="3.2.5 初始化"></a>3.2.5 初始化</h3><ul><li><strong>对类的静态变量，静态代码块执行初始化操作</strong></li><li>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</li><li>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</li></ul><h3 id="3-2-6-使用"><a href="#3-2-6-使用" class="headerlink" title="3.2.6 使用"></a>3.2.6 使用</h3><ul><li>JVM 开始从入口方法开始执行用户的程序代码</li><li>调用静态类成员信息（比如：静态字段、静态方法）</li><li>使用new关键字为其创建对象实例</li></ul><h3 id="3-2-7-卸载"><a href="#3-2-7-卸载" class="headerlink" title="3.2.7 卸载"></a>3.2.7 卸载</h3><ul><li>当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象。</li></ul><h1 id="4-垃圾回收算法"><a href="#4-垃圾回收算法" class="headerlink" title="4. 垃圾回收算法"></a>4. 垃圾回收算法</h1><h2 id="4-1-堆中对象如何判定可以被回收"><a href="#4-1-堆中对象如何判定可以被回收" class="headerlink" title="4.1 堆中对象如何判定可以被回收"></a>4.1 堆中对象如何判定可以被回收</h2><ul><li>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</li></ul><h3 id="4-1-1-引用计数法"><a href="#4-1-1-引用计数法" class="headerlink" title="4.1.1 引用计数法"></a>4.1.1 引用计数法</h3><ul><li><p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p></li><li><p>但是这样存在一个问题：如果对象直接循环引用的话，对象的引用计数永远不会归零</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504180640921.png" alt="image-20240504180640921"></p><p>最后哪怕设置为了null，但是在堆中，两个对象互相引用。</p></li></ul><h3 id="4-1-2-可达性分析法"><a href="#4-1-2-可达性分析法" class="headerlink" title="4.1.2 可达性分析法"></a>4.1.2 可达性分析法</h3><ul><li>现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾</li><li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看是否能够沿着 GC Root 对象 为起点的引用链找到该对象，找不到，表示可以回收</li></ul><h4 id="4-1-2-1-什么对象可以做为GC-Root"><a href="#4-1-2-1-什么对象可以做为GC-Root" class="headerlink" title="4.1.2.1 什么对象可以做为GC Root"></a>4.1.2.1 什么对象可以做为GC Root</h4><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul><h2 id="4-2-标记清除法"><a href="#4-2-标记清除法" class="headerlink" title="4.2 标记清除法"></a>4.2 标记清除法</h2><ul><li>标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除。<ul><li>根据可达性分析算法得出的垃圾进行标记</li><li>对这些标记为可回收的内容进行垃圾回收</li></ul></li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504181232584.png" alt="image-20240504181232584"></p><ul><li>优点：标记和清除速度较快</li><li>缺点：碎片化较为严重，内存不连贯的</li></ul><h2 id="4-3-复制法"><a href="#4-3-复制法" class="headerlink" title="4.3 复制法"></a>4.3 复制法</h2><ul><li>在清除的时候，会申请另外同样大小的内存空间，把存活的对象进行整理并移动至新申请的内存空间中。</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504181703730.png" alt="image-20240504181703730"></p><ul><li>优点：<ul><li>在垃圾对象多的情况下，效率较高</li><li>清理后，内存无碎片</li></ul></li><li>缺点：<ul><li>分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低</li></ul></li></ul><h2 id="4-4-标记整理法"><a href="#4-4-标记整理法" class="headerlink" title="4.4 标记整理法"></a>4.4 标记整理法</h2><ul><li>同标记清除法，只是最后会将所有的存活对象移动，使内存中尽可能多的连续空间</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504181539469.png" alt="image-20240504181539469"></p><h2 id="4-4-分代收集法"><a href="#4-4-分代收集法" class="headerlink" title="4.4 分代收集法"></a>4.4 分代收集法</h2><ul><li>在java8时，堆被分为了两份：新生代和老年代【1：2】</li><li>新生代划分为三个区域<ul><li>伊甸园区Eden，新生的对象都分配到这里</li><li>幸存者区survivor(分成from和to)</li><li>Eden区，from区，to区【8：1：1】</li></ul></li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504182148869.png" alt="image-20240504182148869"></p><h3 id="4-4-1-流程"><a href="#4-4-1-流程" class="headerlink" title="4.4.1 流程"></a>4.4.1 流程</h3><ul><li>第一步：</li></ul><blockquote><ul><li>新创建的对象，都会先分配到eden区</li><li>当伊甸园内存不足，标记伊甸园与 from的存活对象</li><li>将存活对象采用<strong>复制算法</strong>复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li><li>因为使用了复制算法，所以清除之后form和to区交换，原来的from就是下一步的to，原来的to就是下一步的from</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504182512875.png" alt="image-20240504182512875"></p></blockquote><ul><li><p>第二步：</p><blockquote><ul><li>经过一段时间后伊甸园的内存又出现不足，标记eden区域以及from区存活的对象，将存活的对象复制到to区</li><li>再次交换from和to区</li></ul></blockquote></li><li><p>第三步：</p><blockquote><ul><li>当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li></ul></blockquote></li><li><p>MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短（STW）</p></li><li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p></li><li><p>FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长（STW），应尽力避免</p></li></ul><h1 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5. 垃圾收集器"></a>5. 垃圾收集器</h1><h2 id="5-1-串行垃圾收集器"><a href="#5-1-串行垃圾收集器" class="headerlink" title="5.1 串行垃圾收集器"></a>5.1 串行垃圾收集器</h2><ul><li><p>Serial和Serial Old串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑</p></li><li><p>Serial 作用于新生代，采用复制算法</p></li><li><p>Serial Old 作用于老年代，采用标记-整理算法</p></li><li><p>垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。</p></li></ul><h2 id="5-2-并行垃圾收集器"><a href="#5-2-并行垃圾收集器" class="headerlink" title="5.2 并行垃圾收集器"></a>5.2 并行垃圾收集器</h2><ul><li>Parallel New和Parallel Old是一个并行垃圾回收器，<strong>JDK8****默认使用此垃圾回收器</strong></li><li>Parallel New作用于新生代，采用复制算法</li><li>Parallel Old作用于老年代，采用标记-整理算法</li><li>垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。</li></ul><h2 id="5-3-G1垃圾收集器"><a href="#5-3-G1垃圾收集器" class="headerlink" title="5.3 G1垃圾收集器"></a>5.3 G1垃圾收集器</h2><ul><li>应用于新生代和老年代，<strong>在JDK9之后默认使用G1</strong></li><li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li><li>采用<strong>复制算法</strong></li><li>响应时间与吞吐量兼顾</li><li>分成三个阶段：<strong>新生代回收、并发标记、混合收集</strong></li><li>如果并发失败（即<strong>回收速度赶不上创建新对象速度</strong>），会触发 <strong>Full GC</strong></li></ul><h3 id="5-3-1-新生代回收"><a href="#5-3-1-新生代回收" class="headerlink" title="5.3.1 新生代回收"></a>5.3.1 新生代回收</h3><ul><li><p>初始时，所有区域都处于空闲状态</p></li><li><p>创建了一些对象，随机挑出一些空闲区域作为伊甸园区存储这些对象</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504184611981.png" alt="image-20240504184611981"></p></li><li><p>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504184559841.png" alt="image-20240504184559841"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504184628944.png" alt="image-20240504184628944"></p></li><li><p>随着时间流逝，伊甸园的内存又有不足</p></li><li><p>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504184723552.png" alt="image-20240504184723552"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504184735175.png" alt="image-20240504184735175"></p></li></ul><h3 id="5-3-2-并发标记"><a href="#5-3-2-并发标记" class="headerlink" title="5.3.2 并发标记"></a>5.3.2 并发标记</h3><ul><li><p>当老年代占用内存超过阈值(默认是45%)后，触发并发标记，这时无需暂停用户线程（去老年代中找到存活对象进行标记 ）</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504185119426.png" alt="image-20240504185119426"></p></li><li><p>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。</p></li></ul><h3 id="5-3-3-混合收集"><a href="#5-3-3-混合收集" class="headerlink" title="5.3.3 混合收集"></a>5.3.3 混合收集</h3><ul><li><p>此时不会对所有老年代区域进行回收，而是根据暂停时间目标优先回收价值高（存活对象少就意味着能释放更多的内存）的区域（这也是 Gabage First 名称的由来）。 </p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504185851744.png" alt="image-20240504185851744"></p></li><li><p>混合收集阶段中，参与复制的有 eden、survivor、old</p></li><li><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504185838224.png" alt="image-20240504185838224"></p></li><li><p>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504185905970.png" alt="image-20240504185905970"></p></li></ul><h1 id="6-四种引用"><a href="#6-四种引用" class="headerlink" title="6. 四种引用"></a>6. 四种引用</h1><h2 id="6-1-强引用"><a href="#6-1-强引用" class="headerlink" title="6.1 强引用"></a>6.1 强引用</h2><ul><li>通过GC ROOT通过可达性分析之后，在这个链上的所有对象都不会被回收</li><li>最简单的就是手动new的对象</li></ul><h2 id="6-2-弱引用"><a href="#6-2-弱引用" class="headerlink" title="6.2 弱引用"></a>6.2 弱引用</h2><ul><li><p>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><span class="hljs-type">SoftReference</span> <span class="hljs-variable">softReference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>(user);<br></code></pre></td></tr></table></figure></li></ul><h2 id="6-3-弱引用"><a href="#6-3-弱引用" class="headerlink" title="6.3 弱引用"></a>6.3 弱引用</h2><ul><li><p>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><span class="hljs-type">WeakReference</span> <span class="hljs-variable">weakReference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>(user);<br></code></pre></td></tr></table></figure></li><li><p>ThreadLocal的entry的key是弱引用，但是其value是强引用，因此会造成内存泄漏</p></li></ul><h2 id="6-4-虚引用"><a href="#6-4-虚引用" class="headerlink" title="6.4 虚引用"></a>6.4 虚引用</h2><ul><li><p>必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p></li><li><p>当发生了垃圾回收的时候，会将虚引用对象加入到引用 队列中，Reference Handler 线程释放虚引用对象关联的外部资源（直接内存）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">referenceQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br><span class="hljs-type">PhantomReference</span> <span class="hljs-variable">phantomReference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>(user,queue);<br></code></pre></td></tr></table></figure></li><li><p>用的太少，了解即可</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试-RabbitMQ</title>
    <link href="/%E9%9D%A2%E8%AF%95-RabbitMQ/6a1379042a62/"/>
    <url>/%E9%9D%A2%E8%AF%95-RabbitMQ/6a1379042a62/</url>
    
    <content type="html"><![CDATA[<h1 id="1-同步和异步调用"><a href="#1-同步和异步调用" class="headerlink" title="1. 同步和异步调用"></a>1. 同步和异步调用</h1><h2 id="1-1-同步"><a href="#1-1-同步" class="headerlink" title="1.1 同步"></a>1.1 同步</h2><ul><li>优点：<ul><li>时效性较强，可以立即得到结果</li></ul></li><li>缺点：<ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul></li></ul><h2 id="1-2-异步"><a href="#1-2-异步" class="headerlink" title="1.2 异步"></a>1.2 异步</h2><ul><li><p>优点：</p><ul><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li><p>调用间没有阻塞，不会造成无效的资源占用</p></li><li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p></li><li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p></li></ul></li><li><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul></li></ul><h1 id="2-RabbitMQ角色"><a href="#2-RabbitMQ角色" class="headerlink" title="2. RabbitMQ角色"></a>2. RabbitMQ角色</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504074954754.png" alt="image-20240504074954754"></p><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><h1 id="3-RabbitMQ的6中模式"><a href="#3-RabbitMQ的6中模式" class="headerlink" title="3. RabbitMQ的6中模式"></a>3. RabbitMQ的6中模式</h1><ul><li>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</li><li>特点：<ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul></li></ul><h2 id="3-1-BasicQueue"><a href="#3-1-BasicQueue" class="headerlink" title="3.1 BasicQueue"></a>3.1 BasicQueue</h2><ul><li><p>简单模式的中没有交换机，只有队列。生产者发送消息，消费者接收消息，完全是一对一的关系。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504083159474.png" alt="image-20240504083159474"></p></li></ul><h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2 WorkQueue"></a>3.2 WorkQueue</h2><ul><li><p>让<strong>多个消费者绑定到一个队列</strong>，共同消费队列中的消息</p></li><li><p>这些消费者是竞争关系，也就是一条消息只能被其中一个消费者消费。</p></li><li><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504075738054.png" alt="image-20240504075738054"></p></li><li><p>如果不希望消息被均分给每个消费者，而是根据每个消费者实际能力进行消费，修改配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span><br></code></pre></td></tr></table></figure><p>通过增加prefetch配置控制消费者的预取数量。</p></li></ul><h2 id="3-3-发布订阅"><a href="#3-3-发布订阅" class="headerlink" title="3.3 发布订阅"></a>3.3 发布订阅</h2><ul><li><p>有如下几个角色：</p><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>Exchange：交换机，图中的exchange。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：路由定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504083459143.png" alt="image-20240504083459143"></p></li><li><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p></li></ul><h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4 Fanout"></a>3.4 Fanout</h2><ul><li>Fanout模式中，一条消息，会被所有订阅的队列都消费。</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504083917675.png" alt="image-20240504083917675"></p><ul><li><p>声明交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title function_">fanoutExchange</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(<span class="hljs-string">&quot;itcast.fanout&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以有多个队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">fanoutQueue1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>每个队列都要绑定到Exchange（交换机）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">bindingQueue1</span><span class="hljs-params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;<br>    <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFanoutExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 队列名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itcast.fanout&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, everyone!&quot;</span>;<br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>交换机把消息发送给绑定过的所有队列</p></li><li><p>订阅队列的消费者都能拿到消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenFanoutQueue1</span><span class="hljs-params">(String msg)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-5-Direct"><a href="#3-5-Direct" class="headerlink" title="3.5 Direct"></a>3.5 Direct</h2><ul><li>也称为路由模式</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504084445243.png" alt="image-20240504084445243"></p><ul><li><p>队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(value = @Queue(name =&quot;direct.queue1&quot;),exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue1</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(value = @Queue(name = &quot;direct.queue2&quot;),exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue2</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消息的发送方在向 Exchange发送消息时，也必须指定消息的 RoutingKey。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSend2DirectExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itcast.direct&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello i am direct exchange blue&quot;</span>;<br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;blue&quot;</span>, message);<span class="hljs-comment">//只有消费者1能接收到消息</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息。(类似于对暗号)。</p></li><li><p>这里注意一个队列可以绑定多个BindingKey，如果两个队列的BindingKey相同，那么交换机发送的时候，会两者都发。</p></li></ul><h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6 Topic"></a>3.6 Topic</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504090126542.png" alt="image-20240504090126542"></p><ul><li><p>也成为通配符模式</p></li><li><p>Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！</p></li><li><p>Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，</p><ul><li>例如： item.insert</li></ul></li><li><p>通配符规则：</p><ul><li>#：匹配一个或多个词</li><li>*：匹配不多不少恰好1个词</li></ul></li><li><p>发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* topicExchange</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendTopicExchange</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 交换机名称</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itcast.topic&quot;</span>;<br>  <span class="hljs-comment">// 消息</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;<br>  <span class="hljs-comment">// 发送消息</span><br>  rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;china.news&quot;</span>, message);<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>绑定对列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">    key = &quot;china.#&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenTopicQueue1</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">    key = &quot;#.news&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenTopicQueue2</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="4-消息转换器"><a href="#4-消息转换器" class="headerlink" title="4. 消息转换器"></a>4. 消息转换器</h1><ul><li><p>Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p></li><li><p>转换的时候使用的JDK序列化，存在一下问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul></li><li><p>可以使用JSON方式来做序列化和反序列化</p></li><li><p>发送方MQConfig中增加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">jsonMessageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接收方Config中增加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="5-如何保证消息不丢失"><a href="#5-如何保证消息不丢失" class="headerlink" title="5. 如何保证消息不丢失"></a>5. 如何保证消息不丢失</h1><ul><li>MQ可以用来异步发送通知</li><li>在整个的发送流程中：<ul><li>发送方生产消息</li><li>发送方将消息发送给交换机</li><li>交换机将消息转发给队列</li><li>消费方从队列中读取队列</li><li>消费方消费信息</li></ul></li><li>因此在上面流程中每个都过程都会经历消息丢失。</li><li><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504091201001.png" alt="image-20240504091201001"></li><li>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功</li><li><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504091228269.png" alt="image-20240504091228269"></li></ul><h2 id="5-1-消息失败如何处理"><a href="#5-1-消息失败如何处理" class="headerlink" title="5.1 消息失败如何处理"></a>5.1 消息失败如何处理</h2><ul><li>可以通过回调方法触发重试</li><li>记录日志</li><li>保存到数据库然后定时重发，成功发送后即刻删除表中的数据（专门使用一张表记录失败的，定时扫描然后发送）</li></ul><h2 id="5-2-消息持久化"><a href="#5-2-消息持久化" class="headerlink" title="5.2 消息持久化"></a>5.2 消息持久化</h2><ul><li><p>MQ默认是内存存储消息，开启持久化功能可以确保缓存在MQ中的消息不丢失。</p></li><li><p>因此可以在消息转发的各个阶段将消息持久化</p><ul><li><p>交换机持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">simpleExchange</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除    </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;simple.direct&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>队列持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">simpleQueue</span><span class="hljs-params">()</span>&#123;    <br>    <span class="hljs-comment">// 使用QueueBuilder构建队列，durable就是持久化的</span><br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;simple.queue&quot;</span>).build();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消息持久化（SpringAMQP中的的消息默认是持久的，可以通过MessageProperties中的DeliveryMode来指定）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> MessageBuilder<br>      .withBody(message.getBytes(StandardCharsets.UTF_8)) <span class="hljs-comment">// 消息体</span><br>      .setDeliveryMode(MessageDeliveryMode.PERSISTENT) <span class="hljs-comment">// 持久化</span><br>      .build();<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="5-3-消费者确认"><a href="#5-3-消费者确认" class="headerlink" title="5.3 消费者确认"></a>5.3 消费者确认</h2><ul><li>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而SpringAMQP则允许配置三种确认模式：<ul><li>manual：手动ack，需要在业务代码结束后，调用api发送ack。</li><li>auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</li><li>none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li></ul></li><li>可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504092026512.png" alt="image-20240504092026512"></p><h1 id="6-消息重复消费"><a href="#6-消息重复消费" class="headerlink" title="6. 消息重复消费"></a>6. 消息重复消费</h1><ul><li>产生重复消费的原因：<ul><li>网络抖动</li><li>消费者挂掉</li></ul></li><li><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504092144544.png" alt="image-20240504092144544"></li><li>只需要给每个消息设置一个唯一id去标识这个消息，在消费者方处理消息的时候，首先根据id查库看消息是否存在，不存在就进行消费，如果存在表示已经消费过数据，就不在进行消费了。</li></ul><h1 id="7-消息堆积"><a href="#7-消息堆积" class="headerlink" title="7. 消息堆积"></a>7. 消息堆积</h1><ul><li>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题</li><li>解决：<ul><li>增加更多消费者，提高消费速度</li><li>在消费者内开启线程池加快消息处理速度</li><li>扩大队列容积，提高堆积上限（惰性队列）</li></ul></li></ul><h2 id="7-1-惰性队列"><a href="#7-1-惰性队列" class="headerlink" title="7.1 惰性队列"></a>7.1 惰性队列</h2><ul><li><p>惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存</li><li>支持数百万条的消息存储</li></ul></li><li><p>创建惰性队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">lazyQueue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>      .durable(<span class="hljs-string">&quot;lazy.queue&quot;</span>) <span class="hljs-comment">//指定队列名称并持久化</span><br>      .lazy()<br>      .build();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接收方接收消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(value = @Queue(name = &quot;lazy.queue&quot;, durable = &quot;true&quot;, arguments = @Argument(name = &quot;x-queue-mode&quot;,value = &quot;lazy&quot;)))</span><br><span class="hljs-meta">public void lazyQueue (String msg)&#123;</span><br><span class="hljs-meta">log.info(&quot;接收到 lazy.queue的延迟消息:&#123;&#125;&quot;,msg);</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="8-延迟队列"><a href="#8-延迟队列" class="headerlink" title="8.延迟队列"></a>8.延迟队列</h1><h2 id="8-1-死信交换机"><a href="#8-1-死信交换机" class="headerlink" title="8.1 死信交换机"></a>8.1 死信交换机</h2><ul><li>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：<ul><li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信</li></ul></li></ul><h2 id="8-2-延迟队列"><a href="#8-2-延迟队列" class="headerlink" title="8.2 延迟队列"></a>8.2 延迟队列</h2><ul><li><p>进入队列的消息会被延迟消费的队列</p></li><li><p>场景：</p><ul><li>下单限时支付</li><li>限时优惠</li><li>定时发布</li></ul></li><li><p>延迟队 &#x3D; 死信交换机 + TTL</p></li><li><p>声明死信交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">simpleQueue</span><span class="hljs-params">()</span>&#123;    <br>    <span class="hljs-keyword">return</span> QueueBuilder<br>      .durable(<span class="hljs-string">&quot;simple.queue&quot;</span>) <span class="hljs-comment">//指定队列名称并持久化</span><br>      .ttl(<span class="hljs-number">10000</span>)<br>      .deadLetterExchange(<span class="hljs-string">&quot;dl.direct&quot;</span>)<br>      .build();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="8-3-死信交换机"><a href="#8-3-死信交换机" class="headerlink" title="8.3 死信交换机"></a>8.3 死信交换机</h2><ul><li>如果该队列配置了<code>dead-letter-exchange</code>属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为死信交换机（Dead Letter Exchange，简称DLX）。</li></ul><h2 id="8-4-TTL"><a href="#8-4-TTL" class="headerlink" title="8.4 TTL"></a>8.4 TTL</h2><ul><li><p>Time-To-Live。如果一个队列中的消息TTL结束仍未消费，则会变为死信，ttl超时分为两种情况：</p><ul><li>消息所在的队列设置了存活时间</li><li>消息本身设置了存活时间</li></ul></li><li><p>发送方创建消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> MessageBuilder<br>      .withBody(message.getBytes(StandardCharsets.UTF_8)) <span class="hljs-comment">// 消息体</span><br>      .setDeliveryMode(MessageDeliveryMode.PERSISTENT) <span class="hljs-comment">// 持久化</span><br>  .setExpration(<span class="hljs-string">&quot;1000&quot;</span>) <span class="hljs-comment">//消息存活时间为1000ms</span><br>      .build();<br><br><span class="hljs-comment">//消息ID,需要封装到CorrelationData中</span><br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationDaata</span>(UUID.randomUUID().toString<br>                                                       <br><span class="hljs-comment">//发送消息</span><br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;ttl.direct&quot;</span>, <span class="hljs-string">&quot;ttl&quot;</span>,message, correlationData);<br></code></pre></td></tr></table></figure></li></ul><h2 id="8-5-延迟队列插件"><a href="#8-5-延迟队列插件" class="headerlink" title="8.5 延迟队列插件"></a>8.5 延迟队列插件</h2><ul><li><p>DelayExchange插件</p></li><li><p><a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> </p></li><li><p>DelayExchange的本质还是官方的三种交换机，只是添加了延迟功能。因此使用时只需要声明一个交换机，交换机的类型可以是任意类型，然后设定delayed属性为true即可。</p></li><li><p>消息接收方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),exchange = @Exchange(name = &quot;delay.direct&quot;,delayed = &quot;true&quot;),key = &quot;delay&quot;))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDelayedQueue</span> <span class="hljs-params">(String msg)</span>&#123;<br>log.info(<span class="hljs-string">&quot;接收到 delay.queue的延迟消息:&#123;&#125;&quot;</span>,msg);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> MessageBuilder<br>      .withBody(message.getBytes(StandardCharsets.UTF_8)) <span class="hljs-comment">// 消息体</span><br>      .setDeliveryMode(MessageDeliveryMode.PERSISTENT) <span class="hljs-comment">// 持久化</span><br>  .setHeader(<span class="hljs-string">&quot;x-dealy&quot;</span>, <span class="hljs-number">10000</span>) <span class="hljs-comment">//设置超时时间</span><br>      .build();<br><br><span class="hljs-comment">//消息ID,需要封装到CorrelationData中</span><br><span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationDaata</span>(UUID.randomUUID().toString<br>                                                       <br><span class="hljs-comment">//发送消息</span><br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;ttl.direct&quot;</span>, <span class="hljs-string">&quot;ttl&quot;</span>,message, correlationData);<br></code></pre></td></tr></table></figure></li></ul><h1 id="10-集群"><a href="#10-集群" class="headerlink" title="10. 集群"></a>10. 集群</h1><h2 id="10-1-普通集群"><a href="#10-1-普通集群" class="headerlink" title="10.1 普通集群"></a>10.1 普通集群</h2><ul><li>特点：<ul><li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息（其他MQ中存放的是这个队列的地址）。不包含队列中的消息。</li><li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li><li>队列所在节点宕机，队列中的消息就会丢失</li></ul></li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504095204856.png" alt="image-20240504095204856"></p><h2 id="10-2-镜像集群"><a href="#10-2-镜像集群" class="headerlink" title="10.2 镜像集群"></a>10.2 镜像集群</h2><ul><li>特点：<ul><li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。</li><li>创建队列的节点被称为该队列的<strong>主节点，</strong>备份到的其它节点叫做该队列的<strong>镜像</strong>节点。</li><li>一个队列的主节点可能是另一个队列的镜像节点</li><li>所有操作都是主节点完成，然后同步给镜像节点</li><li>主宕机后，镜像节点会替代成新的主</li></ul></li><li>但是这样的话，主从之间是会有数据延时</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240504095309382.png" alt="image-20240504095309382"></p><h2 id="10-3-仲裁队列"><a href="#10-3-仲裁队列" class="headerlink" title="10.3 仲裁队列"></a>10.3 仲裁队列</h2><ul><li>特点：<ul><li>与镜像队列一样，都是主从模式，支持主从数据同步</li><li>使用非常简单，没有复杂的配置</li><li>主从同步基于Raft协议，强一致</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试-spring系列</title>
    <link href="/%E9%9D%A2%E8%AF%95-spring%E7%B3%BB%E5%88%97/6b21e99ac714/"/>
    <url>/%E9%9D%A2%E8%AF%95-spring%E7%B3%BB%E5%88%97/6b21e99ac714/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试-MySQL</title>
    <link href="/%E9%9D%A2%E8%AF%95-MySQL/ac030fe2dab2/"/>
    <url>/%E9%9D%A2%E8%AF%95-MySQL/ac030fe2dab2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-优化"><a href="#1-优化" class="headerlink" title="1. 优化"></a>1. 优化</h1><h2 id="1-1-定位慢查询"><a href="#1-1-定位慢查询" class="headerlink" title="1.1 定位慢查询"></a>1.1 定位慢查询</h2><ul><li><p>当对接口做压测时候，接口响应时间超过指定时间就可以认定为慢查询。</p></li><li><p>运维监控：Skywalking</p></li><li><p><strong>MySQL****自带慢日志</strong></p><ul><li><p>如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 开启MySQL慢日志查询开关<br>slow_query_log=1<br># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志long_query_time=2 (默认为10s)<br></code></pre></td></tr></table></figure></li><li><p>配置完毕之后，通过重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息<code>（/var/lib/mysql/localhost-slow.log。）</code></p></li></ul></li></ul><h2 id="1-2-SQL执行计划"><a href="#1-2-SQL执行计划" class="headerlink" title="1.2 SQL执行计划"></a>1.2 SQL执行计划</h2><ul><li><p>可以采用EXPLAIN获取 MySQL 如何执行 SELECT 语句的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/**直接在select语句之前加上关键字 explain / desc*/</span><br>EXPLAIN   <span class="hljs-keyword">SELECT</span>   字段列表   <span class="hljs-keyword">FROM</span>   表名   <span class="hljs-keyword">WHERE</span>  条件 ;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503101602476.png" alt="image-20240503101602476"></p></li><li><p>字段解释：</p><ul><li>type 这条sql的连接的类型，性能由好到差为NULL、system、const、eq_ref、ref、range、 index、all <ul><li>system：查询系统中的表</li><li>const：根据主键查询</li><li>eq_ref：主键索引查询或唯一索引查询</li><li>ref：索引查询</li><li>range：范围查询</li><li>index：索引树扫描</li><li>all：全盘扫描</li></ul></li><li>possible_key 当前sql可能会使用到的索引</li><li>key 当前sql实际命中的索引</li><li>key_len 索引占用的大小</li><li>Extra 额外的优化建议<ul><li>Using where; Using Index：查找使用了索引，需要的数据都在索引列中能找到，不需要回表查询数据</li><li>Using index condition：查找使用了索引，但是需要回表查询数据</li></ul></li></ul></li></ul><blockquote><p>总结：使用explain</p><ul><li>通过key和key_len检查是否命中了索引（索引本身存在是否有失效的情况）</li><li>通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描</li><li>通过extra建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</li></ul></blockquote><h2 id="1-3-索引"><a href="#1-3-索引" class="headerlink" title="1.3 索引"></a>1.3 索引</h2><h3 id="1-3-1-存储引擎"><a href="#1-3-1-存储引擎" class="headerlink" title="1.3.1 存储引擎"></a>1.3.1 存储引擎</h3><ul><li><p><strong>存储引擎</strong>就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</p></li><li><p>不同存储引擎区别：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503103743368.png" alt="image-20240503103743368"></p></li></ul><h4 id="1-3-1-1-MySQL体系结构"><a href="#1-3-1-1-MySQL体系结构" class="headerlink" title="1.3.1.1 MySQL体系结构"></a>1.3.1.1 MySQL体系结构</h4><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/f03c4f71cb4ce6825ef6a882188bd481.png" alt="image-20230409010508341"></p><ul><li>连接层：最上层是一些客户端和链接服务，包含本地 sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于 TCP&#x2F;IP的通信。</li><li>服务层：在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。</li><li>引擎层：数据库中的索引是在存储引擎层实现的。</li><li>存储层：要是将数据**(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)<strong>存储在文件系统之上，并完成与存储引擎的交互</strong>。</li></ul><h4 id="1-3-1-2-Innodb存储特点"><a href="#1-3-1-2-Innodb存储特点" class="headerlink" title="1.3.1.2 Innodb存储特点"></a>1.3.1.2 Innodb存储特点</h4><ul><li>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，<strong>InnoDB****是默认的</strong> <strong>MySQL</strong> <strong>存储引擎</strong>。</li><li>DML操作遵循ACID模型，支持事务。</li><li>提高并发访问性能。</li><li>支持FOREIGN KEY约束，保证数据的完整性和正确性。</li><li>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li><li>xxx.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li></ul><h4 id="1-3-1-3-逻辑存储结构"><a href="#1-3-1-3-逻辑存储结构" class="headerlink" title="1.3.1.3 逻辑存储结构"></a>1.3.1.3 逻辑存储结构</h4><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/985ce499239706abee669cca091101ff.png" alt="image-20230409221419123"></p><ul><li>表空间 : InnoDB存储引擎逻辑结构的最高层，<strong>ibd文件其实就是表空间文件</strong>，在表空间中可以包含多个Segment段。</li><li>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的 理，都是引擎自身完成，不需要人为对其控制，<strong>一个段中包含多个区</strong>。</li><li>区 : <strong>区是表空间的单元结构，每个区的大小为1M</strong>。 默认情况下， <strong>InnoDB存储引擎页大小为 16K</strong>， 即一个区中一共有64个连续的页。</li><li>页 : <strong>页是组成区的最小单元</strong>，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li><li>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，<strong>在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段</strong>。</li></ul><h3 id="1-3-2-什么是索引"><a href="#1-3-2-什么是索引" class="headerlink" title="1.3.2 什么是索引"></a>1.3.2 什么是索引</h3><ul><li>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构（B+树），这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</li></ul><h3 id="1-3-3-索引底层结构"><a href="#1-3-3-索引底层结构" class="headerlink" title="1.3.3 索引底层结构"></a>1.3.3 索引底层结构</h3><ul><li><p>MySQL默认使用的索引底层数据结构是B+树。</p></li><li><p>B树是一种<strong>多叉路衡查找树</strong>，相对于二叉树，<strong>B树每个节点可以有多个分支，即多叉。</strong></p><ul><li>以一颗最大度数（max-degree）为<strong>5(5阶)的b-tree</strong>为例，那这个B树<strong>（每个节点最多存储4个key，5个指针）</strong></li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/cde74cc64474f37b88548b78a1bb2e19.png" alt="image-20230410224950819"></p></li><li><p>B+Tree是在BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/338e4d70bc77603b7c1b9a4d91d3d42b.png" alt="image-20230410230124036"></p></li><li><p><strong>在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</strong></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/06b719f39658f474f214e158afc3b292.png" alt="image-20230410230844291"></p><blockquote><ul><li>B树中非叶子节点也会存储数据，B+树叶子节点才会存储数据</li><li>使用链表将所有叶子节点连接，这样形成带顺序的指针，可以提高范围查找速度。</li></ul></blockquote></li></ul><h3 id="1-3-4-聚簇和非聚簇索引"><a href="#1-3-4-聚簇和非聚簇索引" class="headerlink" title="1.3.4 聚簇和非聚簇索引"></a>1.3.4 聚簇和非聚簇索引</h3><ul><li>聚簇索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据。必须有且只有一个。</li><li>非举簇索引：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键。可以没有，也可以有多个。</li></ul><h4 id="1-3-4-1-聚簇索引选取规则"><a href="#1-3-4-1-聚簇索引选取规则" class="headerlink" title="1.3.4.1 聚簇索引选取规则"></a>1.3.4.1 聚簇索引选取规则</h4><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503105336583.png" alt="image-20240503105336583"></p><ul><li><p>有一个<code>tb_user</code>，id作为主键，创建了一个<code>index_user_name</code>索引。</p></li><li><p>那么<code>id</code>就是聚簇索引，<code>index_user_name</code>就是非聚簇索引。</p></li><li><p><code>select * from user where name = ‘Arm’;</code></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503105554055.png" alt="image-20240503105554055"></p><p>此时会使用<code>index_user_name</code>索引，查询得到id为10，进行回表查询，最后得到行数据。</p></li></ul><h3 id="1-3-5-索引覆盖"><a href="#1-3-5-索引覆盖" class="headerlink" title="1.3.5 索引覆盖"></a>1.3.5 索引覆盖</h3><ul><li><p><strong>覆盖索引</strong>是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503105758103.png" alt="image-20240503105758103"></p></li><li><p>所以在查询的时候尽量少使用<code>select *</code></p></li></ul><h4 id="1-3-5-1-MySQL超大分页处理"><a href="#1-3-5-1-MySQL超大分页处理" class="headerlink" title="1.3.5.1 MySQL超大分页处理"></a>1.3.5.1 MySQL超大分页处理</h4><ul><li><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503110016469.png" alt="image-20240503110016469"></p></li><li><p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> tb_sku t,     <br>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">9000000</span>,<span class="hljs-number">10</span>) a<br><span class="hljs-keyword">where</span> <br>t.id <span class="hljs-operator">=</span> a.id;<br></code></pre></td></tr></table></figure></li><li><p>在数据量比较大时，limit分页查询，需要对数据进行排序，效率低；解决方案：覆盖索引+子查询</p></li></ul><h3 id="1-3-6-索引创建原则"><a href="#1-3-6-索引创建原则" class="headerlink" title="1.3.6 索引创建原则"></a>1.3.6 索引创建原则</h3><ul><li>针对于数据量较大，且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立<strong>前缀索引</strong>（<strong>此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</strong>）。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li></ul><h3 id="1-3-7-索引失效"><a href="#1-3-7-索引失效" class="headerlink" title="1.3.7 索引失效"></a>1.3.7 索引失效</h3><ul><li><p>索引列运算</p></li><li><p>字符串不加引号</p></li><li><p>模糊查询：如果仅仅是<strong>尾部模糊匹配，索引不会失效</strong>。如果是<strong>头部模糊匹配，索引失效</strong>。</p></li><li><p>范围查询右边的列，不能使用索引 。即：&gt; &lt;在进行范围查询的时候，右边的列不会用到索引。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503114936277.png" alt="image-20240503114936277"></p></li><li><p>数据分布影响</p></li></ul><h2 id="1-4-SQL优化"><a href="#1-4-SQL优化" class="headerlink" title="1.4 SQL优化"></a>1.4 SQL优化</h2><ul><li><strong>表的设计优化（参考阿里开发手册《嵩山版》）</strong><ul><li>比如设置合适的数值（tinyint  int  bigint），要根据实际情况选择</li><li>比如设置合适的字符串类型（char和varchar）char定长效率高，varchar可变长度，效率稍低</li></ul></li><li>索引优化</li><li>SQL语句优化<ul><li>SELECT语句务必指明字段名称（避免直接使用<code>select * </code>）</li><li>SQL语句要避免造成索引失效的写法</li><li>尽量用union all代替union  union会多一次过滤，效率低</li><li>避免在where子句中对字段进行表达式操作</li><li>Join优化 能用innerjoin 就不用left join right join，如必须使用 一定要以小表为驱动，内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边。left join 或 right join，不会重新调整顺序</li></ul></li></ul><h1 id="2-事务"><a href="#2-事务" class="headerlink" title="2. 事务"></a>2. 事务</h1><ul><li>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</li></ul><h2 id="2-1-事务特性"><a href="#2-1-事务特性" class="headerlink" title="2.1 事务特性"></a>2.1 事务特性</h2><ul><li>原子性（<strong>A</strong>tomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（<strong>C</strong>onsistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（<strong>I</strong>solation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（<strong>D</strong>urability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><h2 id="2-2-隔离级别"><a href="#2-2-隔离级别" class="headerlink" title="2.2 隔离级别"></a>2.2 隔离级别</h2><h3 id="2-2-1-并发事务问题"><a href="#2-2-1-并发事务问题" class="headerlink" title="2.2.1 并发事务问题"></a>2.2.1 并发事务问题</h3><ul><li>脏读：一个事务读到另外一个事务还没有提交的数据。  </li><li>不可重复读：  一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。 </li><li>幻读： 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了”幻影”。</li></ul><h3 id="2-2-2-隔离级别"><a href="#2-2-2-隔离级别" class="headerlink" title="2.2.2 隔离级别"></a>2.2.2 隔离级别</h3><ul><li>针对并发事务问题有四种解决方案</li><li><strong>Read uncommitted</strong> <strong>未提交读</strong>：无法避免脏读、不可重复读、幻读。</li><li><strong>Read committed</strong> <strong>读已提交</strong>：只能避免脏读</li><li><strong>Repeatable Read(默认) 可重复读</strong>：无法避免幻读。</li><li><strong>Serializable</strong> <strong>串行化</strong>：都可以解决</li></ul><blockquote><p>事务隔离级别越高，数据越安全，但是性能越低</p></blockquote><h2 id="2-3-MVCC"><a href="#2-3-MVCC" class="headerlink" title="2.3 MVCC"></a>2.3 MVCC</h2><ul><li><strong>缓冲池（buffer pool）</strong>:主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度**</li><li><strong>数据页（page）</strong>:是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503120544723.png" alt="image-20240503120544723"></p><h3 id="2-3-1-redo-log"><a href="#2-3-1-redo-log" class="headerlink" title="2.3.1 redo log"></a>2.3.1 redo log</h3><ul><li><p>重做日志，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong>。</p></li><li><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503120647750.png" alt="image-20240503120647750"></p></li></ul><h3 id="2-3-2-undo-log"><a href="#2-3-2-undo-log" class="headerlink" title="2.3.2 undo log"></a>2.3.2 undo log</h3><ul><li>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚 和 MVCC(多版本并发控制) 。undo log和redo log记录物理日志不一样，它是<strong>逻辑日志</strong>。</li><li>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，</li><li>当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</li><li>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</li><li>而update、delete的时候，产生的undo log日志不仅在回滚时需要，mvcc版本访问也需要，不会立即被删除。</li><li><strong>undo log</strong>可以实现事务的<strong>一致性</strong>和<strong>原子性</strong></li></ul><h3 id="2-3-3-MVCC（多版本并发控制）"><a href="#2-3-3-MVCC（多版本并发控制）" class="headerlink" title="2.3.3 MVCC（多版本并发控制）"></a>2.3.3 MVCC（多版本并发控制）</h3><ul><li>指维护一个数据的多个版本，使得读写操作没有冲突。</li><li>MVCC的具体实现，主要依赖于数据库记录中的隐式字段、undo log日志、readView。</li></ul><h4 id="2-3-3-1-隐式字段"><a href="#2-3-3-1-隐式字段" class="headerlink" title="2.3.3.1 隐式字段"></a>2.3.3.1 隐式字段</h4><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503121049428.png" alt="image-20240503121049428"></p><ul><li>目前有一个user表，里面字段为id、age、name。</li><li>但是隐藏了几个字段：<ul><li>DB_TRX_ID：最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，初始值为1。</li><li>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</li><li>DB_ROW_ID：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</li></ul></li></ul><h5 id="undo-log版本链"><a href="#undo-log版本链" class="headerlink" title="undo log版本链"></a>undo log版本链</h5><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503121407240.png" alt="image-20240503121407240"></p><ul><li><p>此时有五个事务对user表进行操作，事务5分别在不同时间查询id为30的记录。</p></li><li><p>undo log链最终样子：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503121538617.png" alt="image-20240503121538617"></p><ul><li>在事务1进行操作的时候，在undo log中生成一条记录，此时原数据中隐藏字段ROLL_PTR指向这条记录，隐藏字段TRX_ID设置为2。</li><li>在事务2进行操作的时候，undo log再生成一条记录，该记录的ROLL_PTR指向之前的记录，并且将原数据的隐藏字段ROLL_PTR指向新生成的记录，隐藏字段TRX_ID设置为3。</li><li>在事务2进行操作的时候，undo log再生成一条记录，该记录的ROLL_PTR指向之前的记录，并且将原数据的隐藏字段ROLL_PTR指向新生成的记录，隐藏字段TRX_ID设置为4。</li></ul></li></ul><blockquote><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p></blockquote><h4 id="2-3-3-2-readView"><a href="#2-3-3-2-readView" class="headerlink" title="2.3.3.2 readView"></a>2.3.3.2 readView</h4><ul><li>ReadView（读视图）是 <strong>快照读</strong> SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</li><li>当前读：<strong>读取的是记录的最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。</li><li>快照读：<strong>简单的select（不加锁）就是快照读</strong>；快照读读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。<ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li></ul></li></ul><h5 id="四个字段"><a href="#四个字段" class="headerlink" title="四个字段"></a>四个字段</h5><ul><li>m_ids：当前活跃的事务ID集合</li><li>min_trx_id：最小活跃事务ID</li><li>max_trx_id：预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</li><li>creator_trx_id：ReadView创建者的事务ID</li></ul><h5 id="读取规则（了解）"><a href="#读取规则（了解）" class="headerlink" title="读取规则（了解）"></a>读取规则（了解）</h5><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503122420249.png" alt="image-20240503122420249"></p><h5 id="生成时机"><a href="#生成时机" class="headerlink" title="生成时机"></a>生成时机</h5><ul><li>在不同的隔离级别下生成ReadView的时机不同：<ul><li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li></ul></li></ul><h6 id="RC"><a href="#RC" class="headerlink" title="RC"></a>RC</h6><ul><li>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503122605886.png" alt="image-20240503122605886"></p><ul><li><p>事务5在第一次查询记录的时候，记录中的TRX_ID为4、3、2、1，根据读取规则，4不满足读取规则、3也不满足读取规则、2满足读取规则，因此在第一次查询的时候，读取的是TRX_ID为2的数据，拿到的结果就是<code>&#123;id=30,age=3,name=A30&#125;</code></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503122740915.png" alt="image-20240503122740915"></p></li><li><p>事务5在第二次查询记录的时候，记录中的TRX_ID为4、3、2、1，根据读取规则，4不满足读取规则，3满足读取规则，因此最终得到的结果就是<code>&#123;id=30，age=3,name=A3&#125;</code></p></li></ul><h6 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h6><ul><li>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li><li>那么事务5的两次查询只会共用第一次执行快照读的时候生成ReadView。</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503123434142.png" alt="image-20240503123434142"></p><ul><li>因此两次查询出来的结果都一样为：<code>&#123;id=30,age=3,name=A30&#125;</code></li></ul><h1 id="3-主从同步"><a href="#3-主从同步" class="headerlink" title="3. 主从同步"></a>3. 主从同步</h1><ul><li><p>主从同步的核心就是二进制日志（bin log）</p></li><li><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。</p></li><li><p>主从同步分为三步完成：</p><ul><li>Master 主库在事务提交时，会把<strong>数据变更记录</strong>在二进制日志文件 Binlog 中。</li><li>从库<strong>读取</strong>主库的二进制日志文件 <strong>Binlog</strong> ，写入到从库的中继日志 <strong>Relay Log</strong> 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240503123756292.png" alt="image-20240503123756292"></p></li></ul><h1 id="4-分库分表"><a href="#4-分库分表" class="headerlink" title="4. 分库分表"></a>4. 分库分表</h1><ul><li>主从同步解决了访问压力，但是没有解决存储压力。</li><li>分库分表的时机：<ul><li>项目业务数据逐渐增多，或业务发展比较迅速（单表的数据量达<strong>1000W</strong>或<strong>20G</strong>以后）</li><li>优化已解决不了性能问题（主从读写分离、查询索引…）</li><li>IO瓶颈（磁盘IO、网络IO）、CPU瓶颈（聚合查询、连接数太多）</li></ul></li></ul><h2 id="4-1-垂直拆分"><a href="#4-1-垂直拆分" class="headerlink" title="4.1 垂直拆分"></a>4.1 垂直拆分</h2><h3 id="4-1-1-垂直分库"><a href="#4-1-1-垂直分库" class="headerlink" title="4.1.1 垂直分库"></a>4.1.1 垂直分库</h3><ul><li><p>以表为依据，根据业务将不同表拆分到不同库中。（典型案例：微服务是按照功能模块进行拆分的，对应的数据库就是跟模块）</p></li><li><p>特点：</p><ul><li>按业务对数据分级管理、维护、监控、扩展</li><li>在高并发下，提高磁盘IO和数据量连接数</li></ul></li></ul><h3 id="4-1-2-垂直分表"><a href="#4-1-2-垂直分表" class="headerlink" title="4.1.2 垂直分表"></a>4.1.2 垂直分表</h3><ul><li>以字段为依据，根据字段属性将不同字段拆分到不同表中。</li><li>拆分规则：<ul><li>把不常用的字段单独放在一张表。</li><li>把text，blob等大字段拆分出来放在附表中。</li></ul></li><li>特点：<ul><li>冷热数据分离。</li><li>减少IO过渡争抢，两表互不影响</li></ul></li></ul><h2 id="4-2-水平拆分"><a href="#4-2-水平拆分" class="headerlink" title="4.2 水平拆分"></a>4.2 水平拆分</h2><h3 id="4-2-1-水平分库"><a href="#4-2-1-水平分库" class="headerlink" title="4.2.1 水平分库"></a>4.2.1 水平分库</h3><ul><li>将一个库的数据拆分到多个库中。</li><li>特点：<ul><li>解决了单库大数量，高并发的性能瓶颈问题</li><li>提高了系统的稳定性和可用性</li></ul></li><li>路由规则：<ul><li>根据id取模</li><li>范围路由</li></ul></li></ul><h3 id="4-2-2-水平分表"><a href="#4-2-2-水平分表" class="headerlink" title="4.2.2 水平分表"></a>4.2.2 水平分表</h3><ul><li>将一个表的数据拆分到多个表中(可以在同一个库内)。</li><li>特点：<ul><li>优化单一表数据量过大而产生的性能问题;</li><li>避免IO争抢并减少锁表的几率;</li></ul></li></ul><h3 id="4-2-3-中间件"><a href="#4-2-3-中间件" class="headerlink" title="4.2.3 中间件"></a>4.2.3 中间件</h3><ul><li>水平分库分表之后会带来一些问题：<ul><li>分布式事务一致性问题</li><li>跨节点关联查询</li><li>跨节点分页、排序函数</li><li>主键避重</li></ul></li><li>解决：使用分库分表中间件（lsharding-sphere、mycat）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试-redis</title>
    <link href="/%E9%9D%A2%E8%AF%95-redis/e3a811c2f1b6/"/>
    <url>/%E9%9D%A2%E8%AF%95-redis/e3a811c2f1b6/</url>
    
    <content type="html"><![CDATA[<p>详情直达：<a href="https://www.bilibili.com/video/BV1yT411H7YK?p=6&vd_source=0450c732ee6a231d11d13ee9774e4b7f">视频</a></p><h1 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h1><h2 id="1-1-缓存穿透"><a href="#1-1-缓存穿透" class="headerlink" title="1.1 缓存穿透"></a>1.1 缓存穿透</h2><p>查询一个<strong>不存在</strong>的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502211237567.png" alt="image-20240502211237567"></p><ul><li>解决方案：<ul><li>缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存<ul><li>优点：简单</li><li>缺点：消耗内存，可能会发生不一致的问题</li></ul></li><li>布隆过滤器</li></ul></li></ul><h3 id="1-1-1-布隆过滤器"><a href="#1-1-1-布隆过滤器" class="headerlink" title="1.1.1  布隆过滤器"></a>1.1.1  布隆过滤器</h3><h4 id="1-1-1-1-介绍"><a href="#1-1-1-1-介绍" class="headerlink" title="1.1.1.1 介绍"></a>1.1.1.1 介绍</h4><ul><li><p>bitmap：相当于是一个以（bit）位为单位的数组，数组中每个单元只能存储二进制数0或1</p></li><li><p>布隆过滤器可以用于检索一个元素是否在一个集合中。</p></li><li><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502110122091.png" alt="image-20240502110122091"></p></li><li><p>使用的是redisson实现的布隆过滤器。</p></li></ul><h4 id="1-1-1-2-底层原理"><a href="#1-1-1-2-底层原理" class="headerlink" title="1.1.1.2 底层原理"></a>1.1.1.2 底层原理</h4><ul><li>初始化一个比较大数组，里面存放的二进制0或1。在一开始都是0，当一个key来了之后经过<strong>3次hash计算</strong>，模于数组长度找到数据的下标然后把数组中原来的0改为1，这样的话，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。</li><li>误判率：数组越小误判率就越大，数组越大误判率就越小，但是同时带来了更多的内存消耗。通常误判率在5%。</li></ul><h4 id="1-1-1-2-优点"><a href="#1-1-1-2-优点" class="headerlink" title="1.1.1.2 优点"></a>1.1.1.2 优点</h4><ul><li>内存占用少</li><li>没有多余Key</li></ul><h4 id="1-1-1-3-缺点"><a href="#1-1-1-3-缺点" class="headerlink" title="1.1.1.3 缺点"></a>1.1.1.3 缺点</h4><ul><li>实现复杂</li><li>存在误判</li></ul><h2 id="1-2-缓存击穿"><a href="#1-2-缓存击穿" class="headerlink" title="1.2 缓存击穿"></a>1.2 缓存击穿</h2><p>给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把DB压垮</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502211423139.png" alt="image-20240502211423139"></p><h3 id="1-2-1-互斥锁"><a href="#1-2-1-互斥锁" class="headerlink" title="1.2.1 互斥锁"></a>1.2.1 互斥锁</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502211512487.png" alt="image-20240502211512487"></p><ul><li>当缓存失效时，不立即去load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db的操作并回设缓存，否则重试get缓存的方法</li><li>优点：数据一致性</li><li>缺点：性能差</li></ul><h3 id="1-2-2-逻辑过期"><a href="#1-2-2-逻辑过期" class="headerlink" title="1.2.2 逻辑过期"></a>1.2.2 逻辑过期</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502211533351.png" alt="image-20240502211533351"></p><ul><li>在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间</li><li>当查询的时候，从redis取出数据后判断时间是否过期</li><li>如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据不是最新</li><li>优点：高可用，性能较好</li><li>缺点：数据不能达到强一致。</li></ul><h2 id="1-3-缓存雪崩"><a href="#1-3-缓存雪崩" class="headerlink" title="1.3 缓存雪崩"></a>1.3 缓存雪崩</h2><ul><li><p>指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库。</p></li><li><p>解决：</p><ul><li>给不同的Key的TTL添加随机值</li><li>给缓存业务添加降级限流策略</li><li>搭建redis集群。</li></ul></li></ul><h2 id="1-4-缓存预热"><a href="#1-4-缓存预热" class="headerlink" title="1.4 缓存预热"></a>1.4 缓存预热</h2><ul><li><p>指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p></li><li><p>解决：</p><ul><li>数据量不大的时候，工程启动的时候进行加载缓存动作；</li><li>数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；</li><li>数据量太大的时候，优先保证热点数据进行提前加载到缓存。</li></ul></li></ul><h2 id="1-5-双写一致"><a href="#1-5-双写一致" class="headerlink" title="1.5 双写一致"></a>1.5 双写一致</h2><p>即：当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p><h3 id="1-5-1-数据强一致"><a href="#1-5-1-数据强一致" class="headerlink" title="1.5.1 数据强一致"></a>1.5.1 数据强一致</h3><ul><li>对于这类问题，因为要求时效性比较高，我们当时采用的读写锁保证的强一致性。</li><li>可以采用redisson实现的读写锁，在<strong>读的时候添加共享锁(readLock)<strong>，可以</strong>保证读读不互斥，读写互斥</strong>。当我们<strong>更新数据</strong>的时候，<strong>添加排他锁(writeLock)，它是读写，读读都互斥</strong>，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据。这里面需要注意的是读方法和写方法上需要使用同一把锁才行。</li><li>排他锁底层使用setnx，这样就保证了当前只有一个线程操作锁住的方法。</li><li>延迟双删：如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定，在延时的过程中可能会出现脏数据，并不能保证强一致性。</li></ul><h3 id="1-5-2-时效性高"><a href="#1-5-2-时效性高" class="headerlink" title="1.5.2 时效性高"></a>1.5.2 时效性高</h3><ul><li>对于这类问题，因为需要满足高并发，因此允许有一定的延时。</li><li>可以采用MQ的方式，当有修改数据操作的时候，同时发布消息，在缓存监听服务中监听消息，一旦收到消息就立刻更新缓存。</li><li>还可以采用阿里的canal组件实现数据同步：不需要更改业务代码，部署一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据更新以后，canal会读取binlog数据，然后在通过canal的客户端获取到数据，更新缓存即可。</li></ul><h2 id="1-6-数据持久化"><a href="#1-6-数据持久化" class="headerlink" title="1.6 数据持久化"></a>1.6 数据持久化</h2><h3 id="1-6-1-RDB"><a href="#1-6-1-RDB" class="headerlink" title="1.6.1 RDB"></a>1.6.1 RDB</h3><ul><li><p>RDB是一个快照文件，它是把redis内存存储的数据写到磁盘上，当redis实例宕机恢复数据的时候，方便从RDB的快照文件中恢复数据。</p></li><li><p>在redis客户端使用bgsave就可以开启备份</p></li><li><p>可以在redis的配置文件redis.conf文件中找到</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502114447746.png" alt="image-20240502114447746"></p></li><li><p>执行原理：</p><ul><li><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p></li><li><p>在linux中所有进程不能直接操作物理内存的数据，os会给每个进程一个虚拟内存，os会维护一个虚拟内存与物理内存的一个关系表（页表）。</p></li><li><p>主进程操作虚拟内存，通过页表，关联到真正的物理内存，就完成了对数据的读写操作。</p></li><li><p>开启bgsave的时候fork出一个子进程，同时也复制了页表，那么在子进程与主进程的内存空间共享。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502115210482.png" alt="image-20240502115210482"></p></li><li><p>子进程在写RDB文件的时候，主进程接收用户请求实现修改内存数据。此时就形成主进程修改数据，但是子进程在备份数据，有脏数据风险。</p></li><li><p>避免脏数据发生，使用copy-on-write的技术：</p><ul><li><p>当主进程执行读操作的时候，访问共享内存</p></li><li><p>当主进程执行写操作的时候，会拷贝一份数据，专门用来进行写操作。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502115510980.png" alt="image-20240502115510980"></p></li></ul></li></ul></li></ul><h3 id="1-6-2-AOF"><a href="#1-6-2-AOF" class="headerlink" title="1.6.2 AOF"></a>1.6.2 AOF</h3><ul><li><p>AOF的含义是追加文件，当redis操作写命令的时候，都会存储这个文件中，当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据。</p></li><li><p>默认是关闭的，需要修改redis.conf文件下的appenonly配置由no改为yes。</p></li><li><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502115706409.png" alt="image-20240502115706409"></p></li><li><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502115738891.png" alt="image-20240502115738891"></p></li></ul><h3 id="1-6-3-区别"><a href="#1-6-3-区别" class="headerlink" title="1.6.3 区别"></a>1.6.3 区别</h3><p>通常对数据安全性较高的都会使用RDB+AOF</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502115759983.png" alt="image-20240502115759983"></p><h2 id="1-7-数据过期策略"><a href="#1-7-数据过期策略" class="headerlink" title="1.7 数据过期策略"></a>1.7 数据过期策略</h2><ul><li>Redis对数据设置数据的有效时间，数据过期以后，就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略（数据过期策略）。</li><li>通常使用惰性+定期删除</li></ul><h3 id="1-7-1-惰性删除"><a href="#1-7-1-惰性删除" class="headerlink" title="1.7.1 惰性删除"></a>1.7.1 惰性删除</h3><ul><li>惰性删除：设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key</li><li>优点：对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查</li><li>缺点：对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放</li></ul><h3 id="1-7-2-定期删除"><a href="#1-7-2-定期删除" class="headerlink" title="1.7.2 定期删除"></a>1.7.2 定期删除</h3><ul><li>每隔一段时间，我们就对一些key进行检查，删除里面过期的key(从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key)。</li><li>slow模式：定时任务，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件redis.conf 的hz 选项来调整这个次数</li><li>fast模式：执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li><li>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。</li><li>缺点：难以确定删除操作执行的时长和频率。</li></ul><h2 id="1-8-数据淘汰策略"><a href="#1-8-数据淘汰策略" class="headerlink" title="1.8 数据淘汰策略"></a>1.8 数据淘汰策略</h2><p>当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</p><p>有8种模式：</p><ul><li>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</li><li>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰。</li><li>allkeys-random：对全体key ，随机进行淘汰。（数据访问频率不大使用）</li><li>volatile-random：对设置了TTL的key ，随机进行淘汰。</li><li>allkeys-lru： 对全体key，基于LRU算法进行淘汰。（优先使用）</li><li>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰。（业务指定需求使用）</li><li>allkeys-lfu： 对全体key，基于LFU算法进行淘汰。（短时高频访问）</li><li>volatile-lfu： 对设置了TTL的key，基于LFU算法进行淘汰。（短时高频访问）</li></ul><blockquote><p><strong>LRU</strong>（<strong>L</strong>east <strong>R</strong>ecently <strong>U</strong>sed）最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p><p><strong>LFU</strong>（<strong>L</strong>east <strong>F</strong>requently <strong>U</strong>sed）最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</p></blockquote><h1 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2. 分布式锁"></a>2. 分布式锁</h1><p>使用场景：集群情况下的定时任务、抢单、幂等性场景</p><h2 id="2-1-超卖问题"><a href="#2-1-超卖问题" class="headerlink" title="2.1 超卖问题"></a>2.1 超卖问题</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502120918214.png" alt="image-20240502120918214"></p><p>在这种情况下，一定会出现超卖的。在单系统下，使用synchronized或者reentrantlock加锁可以放置超卖，但是在集群模式下，每个JVM的锁是不一样的，因此还会出现超卖问题。</p><p>如果使用redis作为分布式锁，使用setnx就可以完成，当然最后一定要手动的删除锁。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502121322214.png" alt="image-20240502121322214"></p><h2 id="2-2-锁时长"><a href="#2-2-锁时长" class="headerlink" title="2.2 锁时长"></a>2.2 锁时长</h2><h3 id="2-2-1-预估"><a href="#2-2-1-预估" class="headerlink" title="2.2.1 预估"></a>2.2.1 预估</h3><p>根据业务的平时耗时来给出一个预估加锁时长，但是如果出现网络抖动或者IO异常时，此方法不可靠。</p><h3 id="2-2-2-看门狗"><a href="#2-2-2-看门狗" class="headerlink" title="2.2.2 看门狗"></a>2.2.2 看门狗</h3><p>当线程1需要进行加锁时，获取锁成功后，每个</p><h2 id="2-3-可重入"><a href="#2-3-可重入" class="headerlink" title="2.3 可重入"></a>2.3 可重入</h2><p>redission实现的分布式锁是可重入的，使用Hash结构记录线程Id和重入次数</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502122445085.png" alt="image-20240502122445085"></p><h2 id="2-4-主从一致"><a href="#2-4-主从一致" class="headerlink" title="2.4 主从一致"></a>2.4 主从一致</h2><p>即：当线程1获得锁操作master节点后，master发生了宕机，此时在从节点中选举出新的master节点，线程2获取锁在新的master上，这样就造成两个线程同时获得锁</p><h3 id="2-4-1-红锁"><a href="#2-4-1-红锁" class="headerlink" title="2.4.1 红锁"></a>2.4.1 红锁</h3><p>RedLock(红锁)：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁(n &#x2F; 2 + 1)，避免在一个redis实例上加锁。</p><p>但是：红锁实现复杂，性能差，运维繁琐。</p><h1 id="3-集群"><a href="#3-集群" class="headerlink" title="3. 集群"></a>3. 集群</h1><h2 id="3-1-主从复制"><a href="#3-1-主从复制" class="headerlink" title="3.1 主从复制"></a>3.1 主从复制</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502123443764.png" alt="image-20240502123443764"></p><h3 id="3-1-1-主从数据同步"><a href="#3-1-1-主从数据同步" class="headerlink" title="3.1.1 主从数据同步"></a>3.1.1 主从数据同步</h3><ul><li><p>全量同步（首次）：</p><ul><li>从节点与主节点建立连接。</li><li>发起请求数据同步，会携带自己的repId和offest。</li><li>主节点接收到之后，根据repid判断是否是首次，repid不一致即是首次同步。</li><li>首次同步是将自己的repid和offset返回给从节点。</li><li>从节点保存主节点数据信息。</li><li>主节点执行bgsave。</li><li>将生成的rdb文件发送给从节点。</li><li>从节点接收后清空自己本地的rdb文件，加载主节点发送的rdb文件。</li><li>如果主节点在执行bgsave的时候，接收到用户请求，将会记录下这段备份时间所有的指令至repl_baklog中。</li><li>最后将repl_baklog发送给从节点，从节点执行该文件中所有的命令。</li><li>完成数据同步。</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502124016215.png" alt="image-20240502124016215"></p></li><li><p>增量同步（非首次）：发生在salve重启或者数据变化时</p><ul><li>从节点发生宕机重启。</li><li>从节点发起请求，携带repid和offset。</li><li>主节点接收请求，根据repid判断是自己的，进行增量同步。</li><li>去repl_baklog中寻找offset后的执行命令。</li><li>主节点将这些命令发送给从节点。</li><li>从节点执行命令。</li><li>完成同步</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502124318531.png" alt="image-20240502124318531"></p></li></ul><h2 id="3-2-哨兵模式"><a href="#3-2-哨兵模式" class="headerlink" title="3.2 哨兵模式"></a>3.2 哨兵模式</h2><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502125331993.png" alt="image-20240502125331993"></p><ul><li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作。</li><li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主。</li><li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li></ul><h3 id="3-2-1-检测"><a href="#3-2-1-检测" class="headerlink" title="3.2.1 检测"></a>3.2.1 检测</h3><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li><p>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p></li><li><p>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p></li></ul><h3 id="3-2-2-选举规则"><a href="#3-2-2-选举规则" class="headerlink" title="3.2.2 选举规则"></a>3.2.2 选举规则</h3><ul><li>首先判断主与从节点断开时间长短，如超过指定值就排该从节点。</li><li>然后判断从节点的slave-priority值，越小优先级越高。</li><li>如果slave-prority一样，则判断slave节点的offset值，越大优先级越高。</li></ul><h3 id="3-2-3-脑裂"><a href="#3-2-3-脑裂" class="headerlink" title="3.2.3 脑裂"></a>3.2.3 脑裂</h3><ul><li><p>正常的哨兵模式：<img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502125609906.png" alt="image-20240502125609906"></p></li><li><p>如果此时出现某一个主节点与哨兵由于网络问题出现不通信，被哨兵检测为下线，那么哨兵会在接下的从节点中重新选举出一个新的master节点。由于服务状态变更通知不能立刻通知到client，用户还在向原master写操作。<img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502125750134.png" alt="image-20240502125750134"></p></li><li><p>最终原master会被降为从节点，就进行了重新的主从数据同步操作，因此用户的写操作执行命令就造成丢失。</p></li><li><p>因此可以通过修改redis的两个配置参数防止出现该问题</p><ul><li>min-replicas-to-write 1  表示最少的salve节点为1个。即：在执行写操作的时候，必须要有一个从节点。</li><li>min-replicas-max-lag 5 表示数据复制和同步的延迟不能超过5秒。即：如果主从数据同步操作5秒，达不到要求就拒绝请求，这样就可以防止丢失数据。</li></ul></li></ul><h2 id="3-3-分片集群"><a href="#3-3-分片集群" class="headerlink" title="3.3 分片集群"></a>3.3 分片集群</h2><p>分片集群用来解决：</p><ul><li>海量数据存储问题</li><li>高并发写的问题</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502130411000.png" alt="image-20240502130411000"></p><h3 id="3-3-1-特征"><a href="#3-3-1-特征" class="headerlink" title="3.3.1 特征"></a>3.3.1 特征</h3><ul><li>集群中有多个master，每个master保存不同数据。</li><li>每个master都可以有多个slave节点。</li><li>master之间通过ping监测彼此健康状态。</li><li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点。</li></ul><h3 id="3-3-2-数据读写"><a href="#3-3-2-数据读写" class="headerlink" title="3.3.2 数据读写"></a>3.3.2 数据读写</h3><p>Redis 分片集群引入了哈希槽的概念，Redis 集群有 <strong>16384</strong> 个哈希槽，每个 key通过 <strong>CRC16</strong> 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502130516284.png" alt="image-20240502130516284"></p><h1 id="4-Redis事务"><a href="#4-Redis事务" class="headerlink" title="4. Redis事务"></a>4. Redis事务</h1><h2 id="4-1-事务基本概念"><a href="#4-1-事务基本概念" class="headerlink" title="4.1 事务基本概念"></a>4.1 事务基本概念</h2><ul><li>Redis事务中如果有某一条命令执行失败，之前的命令不会回滚，其后的命令仍然会被继续执行。鉴于这个原因，所以说Redis的事务严格意义上来说是不具备原子性的。</li><li>Redis事务中所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。</li></ul><h2 id="4-2-Redis事务三个阶段"><a href="#4-2-Redis事务三个阶段" class="headerlink" title="4.2 Redis事务三个阶段"></a>4.2 Redis事务三个阶段</h2><ol><li>multi 开启事务</li><li>大量指令入队</li><li>exec执行事务块内命令，截止此处一个事务已经结束。</li><li>discard 取消事务</li><li>watch 监视一个或多个key，如果事务执行前key被改动，事务将打断。unwatch 取消监视。</li></ol><blockquote><p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队.</p></blockquote><h2 id="4-3-Redis事务相关命令"><a href="#4-3-Redis事务相关命令" class="headerlink" title="4.3 Redis事务相关命令"></a>4.3 Redis事务相关命令</h2><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p><h3 id="4-3-1-WATCH"><a href="#4-3-1-WATCH" class="headerlink" title="4.3.1 WATCH"></a>4.3.1 WATCH</h3><ul><li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。</li><li>可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li></ul><h3 id="4-3-2-MULTI"><a href="#4-3-2-MULTI" class="headerlink" title="4.3.2 MULTI"></a>4.3.2 MULTI</h3><ul><li>MULTI命令用于开启一个事务，它总是返回OK。 </li><li>MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li></ul><h3 id="4-3-3-EXEC"><a href="#4-3-3-EXEC" class="headerlink" title="4.3.3 EXEC"></a>4.3.3 EXEC</h3><ul><li>执行所有事务块内的命令。</li><li>返回事务块内所有命令的返回值，按命令执行的先后顺序排列。</li><li>当操作被打断时，返回空值 nil 。</li><li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li></ul><h3 id="4-3-4-UNWATCH"><a href="#4-3-4-UNWATCH" class="headerlink" title="4.3.4 UNWATCH"></a>4.3.4 UNWATCH</h3><ul><li>UNWATCH命令可以取消watch对所有key的监控。</li></ul><h2 id="4-4-Redis事务支持隔离性吗？"><a href="#4-4-Redis事务支持隔离性吗？" class="headerlink" title="4.4 Redis事务支持隔离性吗？"></a>4.4 Redis事务支持隔离性吗？</h2><ul><li>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</li></ul><h2 id="4-5-Redis为什么不支持事务回滚？"><a href="#4-5-Redis为什么不支持事务回滚？" class="headerlink" title="4.5 Redis为什么不支持事务回滚？"></a>4.5 Redis为什么不支持事务回滚？</h2><ul><li>Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面，这些问题不能在入队时发现，这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><h2 id="4-6-Redis事务其他实现"><a href="#4-6-Redis事务其他实现" class="headerlink" title="4.6 Redis事务其他实现"></a>4.6 Redis事务其他实现</h2><ul><li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，<br>其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li></ul><h1 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h1><h2 id="5-1-redis是单线程会什么这么快？"><a href="#5-1-redis是单线程会什么这么快？" class="headerlink" title="5.1 redis是单线程会什么这么快？"></a>5.1 redis是单线程会什么这么快？</h2><ul><li>Redis是纯内存操作，执行速度非常快</li><li>采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题</li><li>使用I&#x2F;O多路复用模型，非阻塞IO</li><li>Redis是纯内存操作，执行速度非常快，它的性能瓶颈是<strong>网络延迟</strong>而不是执行速度</li></ul><h2 id="5-2-解释一下IO多路复用"><a href="#5-2-解释一下IO多路复用" class="headerlink" title="5.2 解释一下IO多路复用"></a>5.2 解释一下IO多路复用</h2><p>IO多路复用就是实现了高效的网络请求。</p><h3 id="5-2-1-IO模型"><a href="#5-2-1-IO模型" class="headerlink" title="5.2.1 IO模型"></a>5.2.1 IO模型</h3><ul><li><p>Linux系统中一个进程使用的内存情况划分两部分：<strong>内核空间、用户空间</strong>。</p><ul><li><p><strong>用户空间</strong>只能执行受限的命令（Ring3），而且不能直接调用系统资源必须通过内核提供的接口来访问。</p></li><li><p><strong>内核空间</strong>可以执行特权命令（Ring0），调用一切系统资源。</p></li></ul></li><li><p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p><ul><li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li><li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li></ul></li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502131005074.png" alt="image-20240502131005074"></p><h4 id="4-2-1-1-阻塞IO"><a href="#4-2-1-1-阻塞IO" class="headerlink" title="4.2.1.1 阻塞IO"></a>4.2.1.1 阻塞IO</h4><p>两个阶段都必须阻塞等待。</p><ul><li>阶段一：<ul><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>此时用户进程也处于阻塞状态</li></ul></li><li>阶段二：<ul><li>数据到达并拷贝到内核缓冲区，代表已就绪</li><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程解除阻塞，处理数据</li></ul></li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502131130565.png" alt="image-20240502131130565"></p><h4 id="5-2-1-2-非阻塞IO"><a href="#5-2-1-2-非阻塞IO" class="headerlink" title="5.2.1.2 非阻塞IO"></a>5.2.1.2 非阻塞IO</h4><ul><li>阶段一：<ul><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>返回异常给用户进程</li><li>用户进程拿到error后，再次尝试读取</li><li>循环往复，直到数据就绪</li></ul></li><li>阶段二：<ul><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程解除阻塞，处理数据</li></ul></li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502131145658.png" alt="image-20240502131145658"></p><blockquote><ul><li>非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。</li><li>虽然是非阻塞，但性能并没有得到提高。而且<strong>忙等机制会导致CPU空转，CPU使用率暴增</strong>。</li></ul></blockquote><h4 id="5-2-1-3-IO多路复用"><a href="#5-2-1-3-IO多路复用" class="headerlink" title="5.2.1.3 IO多路复用"></a>5.2.1.3 IO多路复用</h4><p>利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p><ul><li><p>阶段一：</p><ul><li>用户进程调用select，指定要监听的Socket集合</li><li>内核监听对应的多个socket</li><li>任意一个或多个socket数据就绪则返回readable</li><li>此过程中用户进程阻塞</li></ul></li><li><p>阶段二：</p><ul><li>用户进程找到就绪的socket</li><li>依次调用recvfrom读取数据</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ul></li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502131316993.png" alt="image-20240502131316993"></p><blockquote><p>由于在监听某个socket数据就绪的时候，会去寻找对应的socket，因此衍生出poll和epoll</p></blockquote><h5 id="select-poll"><a href="#select-poll" class="headerlink" title="select+poll"></a>select+poll</h5><p>select和poll只会通知用户进程有Socket就绪，但不确定具体是哪个Socket ，需要用户进程逐个遍历Socket来确认</p><h5 id="select-epoll"><a href="#select-epoll" class="headerlink" title="select+epoll"></a>select+epoll</h5><p>epoll则会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间</p><h2 id="5-3-redis网络模型"><a href="#5-3-redis网络模型" class="headerlink" title="5.3 redis网络模型"></a>5.3 redis网络模型</h2><p>Redis通过IO多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行封装， 提供了统一的高性能事件库</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502131707906.png" alt="image-20240502131707906"></p><h2 id="5-4-redis消息队列"><a href="#5-4-redis消息队列" class="headerlink" title="5.4 redis消息队列"></a>5.4 redis消息队列</h2><p>在消息队列中包含3个角色：</p><ul><li><strong>消息队列：</strong>存储和管理消息，也被称为消息代理。</li><li><strong>生产者：</strong>发送消息到消息队列。</li><li><strong>消费者：</strong>从消息队列获取消息并处理消息。</li></ul><h3 id="5-4-1-List"><a href="#5-4-1-List" class="headerlink" title="5.4.1 List"></a>5.4.1 List</h3><ul><li>redis的list结构是一个双向链表，很容易模拟出队列效果。</li><li>队列是入口和出口不在一边，因此可以用LPUSH结合RPOP、或者RPUSH结合LPOP实现</li><li>但是，当队列没有消息时pop就会返回null，并不会jvm堵塞队列那样堵塞并等待消息，因此这里应该使用BRPOP或者BLPOP来实现堵塞队列。</li><li><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/190ee72b5453430a957b66ad63a8b398.jpeg" alt="img"></li><li>优点：<ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul></li><li>缺点：<ul><li>无法避免消息丢失。从消息队列取到消息，还没来得及处理就挂掉了，这个消息就消失了。</li><li>只支持单消费者。</li></ul></li></ul><h3 id="5-4-2-PubSub"><a href="#5-4-2-PubSub" class="headerlink" title="5.4.2 PubSub"></a>5.4.2 PubSub</h3><ul><li><strong>PubSub（发布订阅）</strong>是redis2.0版本引入的消息传递模型，消费者可以订阅一个或多个channel（频道），生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</li><li><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502223358110.png" alt="image-20240502223358110"></li><li>相关命令：<ul><li>SUBSCRIBE channel [channel] ：订阅一个或多个频道</li><li>PUBLISH channel msg ：向一个频道发送消息</li><li>PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</li></ul></li><li>优点：<ul><li>采用发布订阅模型，支持多生产、多消费</li></ul></li><li>缺点：<ul><li>不支持数据持久化。</li><li>无法避免消息丢失。</li><li>消息堆积有上限，超出时数据丢失。（缓存空间是有上限的）</li></ul></li></ul><h3 id="5-4-3-Stream"><a href="#5-4-3-Stream" class="headerlink" title="5.4.3 Stream"></a>5.4.3 Stream</h3><ul><li>Stream是redis5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</li></ul><h4 id="5-4-3-1-单消费模式"><a href="#5-4-3-1-单消费模式" class="headerlink" title="5.4.3.1 单消费模式"></a>5.4.3.1 单消费模式</h4><ul><li><p>发送命令：<img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/0df50af4e9a542fab28a4862c5040ec3.jpeg" alt="img"></p></li><li><p><strong>使用XREAD读取</strong>：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/c041c8978dbe46058a3efd038040ae9f.jpeg" alt="img"></p><p>读取最新消息：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/10d111a9bb6841adb0193aef6e33f219.jpeg" alt="img"></p></li><li><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题。</p></li><li><p>特点：</p><ul><li>消息可回溯。不消失永久保存在队列里。</li><li>一个消息可以被多个消费者读取。读完不消失的，可以多个读</li><li>可以堵塞读取</li><li>有消息漏读的风险</li></ul></li></ul><h4 id="5-4-3-2-消费者组"><a href="#5-4-3-2-消费者组" class="headerlink" title="5.4.3.2 消费者组"></a>5.4.3.2 消费者组</h4><ul><li><p><strong>消费者组（Consumer Group）</strong>：将多个消费者划分到一个组，监听同一个队列。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/image-20240502223632816.png" alt="image-20240502223632816"></p></li><li><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/a76aed390f6f4429ac7b8d9007b31547.jpeg" alt="img"></p></li><li><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/aaaed8b6d50743f484c99c356bb74db0.jpeg" alt="img"></p></li><li><p>消费者监听的思路：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/f7075de1998a431291f174623edb3a0d.jpeg" alt="img"></p></li><li><p>特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul></li></ul><h3 id="5-4-4-比较"><a href="#5-4-4-比较" class="headerlink" title="5.4.4 比较"></a>5.4.4 比较</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/interview/ca6ad37bfc804680ad739ca559611956.jpeg" alt="img"></p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-进阶-索引</title>
    <link href="/MySQL-%E8%BF%9B%E9%98%B6-%E7%B4%A2%E5%BC%95/67c1cc216a26/"/>
    <url>/MySQL-%E8%BF%9B%E9%98%B6-%E7%B4%A2%E5%BC%95/67c1cc216a26/</url>
    
    <content type="html"><![CDATA[<h1 id="1-索引概述"><a href="#1-索引概述" class="headerlink" title="1. 索引概述"></a>1. 索引概述</h1><p>索引（index）是帮助MySQL**高效获取数据的数据结构(有序)**。</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><h1 id="2-索引演示"><a href="#2-索引演示" class="headerlink" title="2. 索引演示"></a>2. 索引演示</h1><p>有一张user表，如果此时执行SQL语句：<code> select * from user where age = 45;</code></p><ul><li>无索引：此时由于没有在age上存放索引，那么这个sql就从第一行开始扫描，一直扫描到最后一行，即：全表扫描。性能极低。</li><li>有索引：在age字段上建立索引，会创建一个类似二叉树一样的东西（真实结构为B+树），这样极大的加快了检索速度。</li></ul><h1 id="3-索引特点"><a href="#3-索引特点" class="headerlink" title="3. 索引特点"></a>3. 索引特点</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/57cc61ede90b2dd292b952edaa65386a.png" alt="image-20230410223027709"></p><h1 id="4-索引结构"><a href="#4-索引结构" class="headerlink" title="4. 索引结构"></a>4. 索引结构</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><p><strong>MySQL的索引是在存储引擎层实现的</strong>，不同的存储引擎有不同的索引结构</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/a8c8dbcef06ac6eed3ca4f7965abf706.png" alt="image-20230410223312985"></p><p>不同的存储引擎对索引结构的支持：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/adc39765a8424aeed9584a054941ac95.png" alt="image-20230410223456722"></p><blockquote><p>平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</p></blockquote><h2 id="4-2-二叉树"><a href="#4-2-二叉树" class="headerlink" title="4.2 二叉树"></a>4.2 二叉树</h2><p>当二叉树作为索引结构，存在以下缺点：</p><ul><li>顺序插入时，会形成一个<strong>链表，查询性能大大降低</strong>。</li><li>大数据量情况下，<strong>层级较深，检索速度慢</strong>。</li></ul><h2 id="4-3-红黑树"><a href="#4-3-红黑树" class="headerlink" title="4.3 红黑树"></a>4.3 红黑树</h2><p>红黑树是一颗<strong>自平衡二叉树</strong>，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树。</p><p>所以红黑树作为索引结构也会存在一个缺点：大数据量情况下，<strong>层级较深，检索速度慢</strong>。</p><h2 id="4-4-B树"><a href="#4-4-B树" class="headerlink" title="4.4 B树"></a>4.4 B树</h2><p>B树是一种<strong>多叉路衡查找树</strong>，相对于二叉树，<strong>B树每个节点可以有多个分支，即多叉。</strong></p><p>以一颗最大度数（max-degree）为<strong>5(5阶)的b-tree</strong>为例，那这个B树<strong>（每个节点最多存储4个key，5个指针）</strong>：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/cde74cc64474f37b88548b78a1bb2e19.png" alt="image-20230410224950819"></p><blockquote><p>树的度数指的是一个节点的子节点个数。（有n个key，就有n+1个指针）</p></blockquote><h3 id="4-4-1-特点"><a href="#4-4-1-特点" class="headerlink" title="4.4.1 特点"></a>4.4.1 特点</h3><ul><li>n阶的B树，每一个节点最多存储n-1个key，对应n个指针。</li><li><strong>一旦节点存储的key数量到达n，就会裂变，中间元素向上分裂。</strong></li><li>在B树中，<strong>非叶子节点和叶子节点都会存放数据。</strong></li></ul><h2 id="4-5-B-树"><a href="#4-5-B-树" class="headerlink" title="4.5 B+树"></a>4.5 B+树</h2><p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/338e4d70bc77603b7c1b9a4d91d3d42b.png" alt="image-20230410230124036"></p><blockquote><ul><li>绿色框框起来的部分，是<strong>索引部分，仅仅起到索引数据的作用，不存储数据。</strong></li><li>红色框框起来的部分，是<strong>数据存储部分，在其叶子节点中要存储具体的数据。</strong></li></ul></blockquote><h3 id="4-5-1-与B树区别"><a href="#4-5-1-与B树区别" class="headerlink" title="4.5.1 与B树区别"></a>4.5.1 与B树区别</h3><ul><li><strong>所有的数据都会出现在叶子节点。</strong></li><li>叶子节点<strong>形成一个单向链表</strong>。</li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li></ul><h3 id="4-5-2-MySQL索引数据结构"><a href="#4-5-2-MySQL索引数据结构" class="headerlink" title="4.5.2 MySQL索引数据结构"></a>4.5.2 MySQL索引数据结构</h3><p>在B+树上进行优化，<strong>在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</strong></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/06b719f39658f474f214e158afc3b292.png" alt="image-20230410230844291"></p><h2 id="4-6-Hash"><a href="#4-6-Hash" class="headerlink" title="4.6 Hash"></a>4.6 Hash</h2><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/9d97f29a92b3c65adeed91875fcf75c1.png" alt="image-20230411203125845"></p><p><strong>当出现两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞）</strong>，可以通过<strong>链表</strong>来解决。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/21b14f7ca29f22a8a3259ed9e89a3971.png" alt="image-20230411203219634"></p><h3 id="4-6-1-特点"><a href="#4-6-1-特点" class="headerlink" title="4.6.1 特点"></a>4.6.1 特点</h3><ul><li>Hash索引**只能用于对等比较(&#x3D;，in)**，不支持范围查询（between，&gt;，&lt; ，…）</li><li><strong>无法利用索引完成排序操作</strong></li><li><strong>查询效率高</strong>，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</li></ul><blockquote><p>在MySQL中，支持hash索引的是Memory存储引擎。 <strong>而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</strong></p></blockquote><h2 id="4-7-MySQL为何选择B-树作为索引结构"><a href="#4-7-MySQL为何选择B-树作为索引结构" class="headerlink" title="4.7 MySQL为何选择B+树作为索引结构"></a>4.7 MySQL为何选择B+树作为索引结构</h2><ul><li>相对于二叉树，<strong>层级更少，搜索效率高</strong>；</li><li>对于B-tree，<strong>无论是叶子节点还是非叶子节点，都会保存数据</strong>，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</li><li>相对Hash索引，<strong>B+tree支持范围匹配及排序操作</strong>；</li></ul><h1 id="5-索引分类"><a href="#5-索引分类" class="headerlink" title="5. 索引分类"></a>5. 索引分类</h1><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p><p><strong><img src="https://img-blog.csdnimg.cn/img_convert/cc79272e08ac00965e69ef23d9d04c84.png" alt="image-20230411214416027"></strong></p><h2 id="5-1-聚集索引-二级索引"><a href="#5-1-聚集索引-二级索引" class="headerlink" title="5.1 聚集索引&amp;二级索引"></a>5.1 聚集索引&amp;二级索引</h2><p>在InnoDB存储引擎中，根据索引的存储形式，可以分为以下两种：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/bd0a483e299531b56530aaba5379280a.png" alt="image-20230411214529881"></p><h3 id="5-1-1-聚集索引选取规则"><a href="#5-1-1-聚集索引选取规则" class="headerlink" title="5.1.1 聚集索引选取规则"></a>5.1.1 聚集索引选取规则</h3><blockquote><p>主键-&gt;唯一（unique）-&gt;rowid</p></blockquote><ul><li>如果<strong>存在主键，主键索引就是聚集索引。</strong></li><li>如果不存在主键，将使用<strong>第一个唯一（UNIQUE）索引作为聚集索引。</strong></li><li>如果表没有主键，或没有合适的唯一索引，则<strong>InnoDB会自动生成一个rowid作为隐藏的聚集索引。且聚集索引在一个表里只会有一个</strong></li></ul><h3 id="5-1-2-聚集索引-二级索引结构"><a href="#5-1-2-聚集索引-二级索引结构" class="headerlink" title="5.1.2 聚集索引&amp;二级索引结构"></a>5.1.2 聚集索引&amp;二级索引结构</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/baf9b3f5736e5a63ea5df60e2fc8c111.png" alt="image-20230411215242874"></p><p>观察可以得知：</p><ul><li><strong>聚集</strong>索引的叶子节点下挂的是<strong>这一行的数据</strong>。</li><li><strong>二级</strong>索引的叶子节点下挂的是<strong>该字段值对应的主键值</strong>。</li></ul><h3 id="5-1-3-执行SQL过程"><a href="#5-1-3-执行SQL过程" class="headerlink" title="5.1.3 执行SQL过程"></a>5.1.3 执行SQL过程</h3><p>在执行sql：<code>select * from user where name = &#39;Arm&#39;;</code>过程：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/1b5cf867bd0e417e0b5e410cbca070b7.png" alt="image-20230411220116187"></p><blockquote><p>文字描述：</p><ol><li>由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li><li>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。</li><li>最终拿到这一行的数据，直接返回即可。</li></ol></blockquote><h3 id="5-1-4-回表查询"><a href="#5-1-4-回表查询" class="headerlink" title="5.1.4 回表查询"></a>5.1.4 回表查询</h3><p><strong>先到二级索引中查找数据，找到主键值</strong>，然后<strong>再到聚集索引中根据主键值，获取数据的方式</strong>，就称之为回表查询。</p><h3 id="5-1-5-比较"><a href="#5-1-5-比较" class="headerlink" title="5.1.5 比较"></a>5.1.5 比较</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">A. <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">10</span> ; <br>B. <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Arm&#x27;</span> ; <br>备注: id为主键，name字段创建的有索引；<br></code></pre></td></tr></table></figure><p>A 语句的执行性能要高于 B 语句。</p><p>因为A语句直接<strong>走聚集索引，直接返回数据。</strong></p><p>而B语句需要先查询name字段的二级索引，然后再查询聚集索引，也就是需要进行回表查询。</p><h3 id="5-1-6-InnoDB主键索引的B-树高度多少"><a href="#5-1-6-InnoDB主键索引的B-树高度多少" class="headerlink" title="5.1.6 InnoDB主键索引的B+树高度多少"></a>5.1.6 InnoDB主键索引的B+树高度多少</h3><p>假设：一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。</p><blockquote><p>高度为2：</p><p>n * 8 + (n + 1) * 6 &#x3D; 16 * 1024 , 算出n约为 1170</p><p>n 为这个节点存储的key的数量</p><p>8 为主键占用的字节数</p><p>n+1 指代的是指针的数量</p><p>6 为InnoDB的指针占用的空间</p><p>16 * 1024 一页的大小是16k，所以是16 * 1024个字节</p><p>1171*16 &#x3D; 18736</p><p>1170 为这个节点存储的key，可以知道就会有1171个指针</p><p>每一个指针会指向下面的子节点，每个节点因为能放16行数据</p><p>也就是说，如果树的高度为2，则可以存储 18000 多条记录。</p></blockquote><blockquote><p>高度为3：</p><p>1171 * 1171 * 16 &#x3D; 21939856</p><p>多了一个高度，相当于又有1171个指针指向下面，因此直接用1171乘以上面的结果即可</p><p>也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。</p></blockquote><h1 id="6-索引语法"><a href="#6-索引语法" class="headerlink" title="6. 索引语法"></a>6. 索引语法</h1><h2 id="6-1-创建索引"><a href="#6-1-创建索引" class="headerlink" title="6.1 创建索引"></a>6.1 创建索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [ <span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT ] INDEX index_name <span class="hljs-keyword">ON</span> table_name (index_col_name,... ) ;<br></code></pre></td></tr></table></figure><h2 id="6-2-查看索引"><a href="#6-2-查看索引" class="headerlink" title="6.2 查看索引"></a>6.2 查看索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> table_name ;<br></code></pre></td></tr></table></figure><h2 id="6-3-删除索引"><a href="#6-3-删除索引" class="headerlink" title="6.3 删除索引"></a>6.3 删除索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name ;<br></code></pre></td></tr></table></figure><h1 id="7-SQL性能分析"><a href="#7-SQL性能分析" class="headerlink" title="7. SQL性能分析"></a>7. SQL性能分析</h1><h2 id="7-1-SQL执行频率"><a href="#7-1-SQL执行频率" class="headerlink" title="7.1 SQL执行频率"></a>7.1 SQL执行频率</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;com_______&#x27;</span>;<br>#session 是查看当前会话 ;<br>#<span class="hljs-keyword">global</span> 是查询全局数据 ;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/4035ae9268a36174c3fb2fa42b1a0bde.png" alt="image-20230412211950972"></p><blockquote><ul><li>Com_delete: 删除次数</li><li>Com_insert: 插入次数</li><li>Com_select: 查询次数</li><li>Com_update: 更新次数</li></ul><p> 通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 <strong>如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</strong>次数我们可以借助于慢查询 日志。</p></blockquote><h2 id="7-2-慢查询日志"><a href="#7-2-慢查询日志" class="headerlink" title="7.2 慢查询日志"></a>7.2 慢查询日志</h2><p>慢查询日志记录了<strong>所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志。</strong></p><p> MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">#查看系统变量 slow_query_log<br># variables 意思是变量<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;slow_query_log&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="7-2-1-开启慢查询日志"><a href="#7-2-1-开启慢查询日志" class="headerlink" title="7.2.1 开启慢查询日志"></a>7.2.1 开启慢查询日志</h3><p>需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">#使用vi编辑器打开配置文件（在使用前先输入exit退出mysql程序）<br>vi <span class="hljs-operator">/</span>etc<span class="hljs-operator">/</span>my.cnf<br><br>#接着按G到文章的最后位置，将下面内容输入进去，并且保存并退出<br><br># 开启MySQL慢日志查询开关<br>slow_query_log<span class="hljs-operator">=</span><span class="hljs-number">1</span><br># 设置慢日志的时间为<span class="hljs-number">2</span>秒，<span class="hljs-keyword">SQL</span>语句执行时间超过<span class="hljs-number">2</span>秒，就会视为慢查询，记录慢查询日志<br>long_query_time<span class="hljs-operator">=</span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>修改之后重启MySQL服务器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">systemctl restart mysqld<br><br>#再次查询慢查询日志<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;slow_query_log&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><p>检查慢查询日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">tail <span class="hljs-operator">-</span>f ‘主机名’<span class="hljs-operator">-</span>slow.log<br>#‘主机名’要更换成你自己的主机<br></code></pre></td></tr></table></figure><blockquote><p>如果不确定此处应填什么，可以先转到mysql目录下，再使用 ll 查看，往下拉，找到一个以-slow.log文件即可</p></blockquote></li><li><p>执行SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user; <br>#这条<span class="hljs-keyword">SQL</span>执行效率比较高, 执行耗时 <span class="hljs-number">0.00</span>sec<br></code></pre></td></tr></table></figure><blockquote><p>最终我们发现，在慢查询日志中，只会记录执行时间超多我们预设时间（2s）的SQL，执行较快的SQL 是不会记录的。这样通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化。</p></blockquote></li></ul><h2 id="7-3-Profile"><a href="#7-3-Profile" class="headerlink" title="7.3 Profile"></a>7.3 Profile</h2><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p><ul><li><p>使用<code>select @@have_profiling ;</code>查看当前的MYSQL是否支持profile操作。</p></li><li><p>使用<code>select @@profiling;</code>查询 profile 的开关是开启还是关闭。（0-关闭；1-开启）</p><blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">#通过<span class="hljs-keyword">set</span>语句在 session<span class="hljs-operator">/</span><span class="hljs-keyword">global</span> 级别开启profiling<br><span class="hljs-keyword">set</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>#查询profile操作是否可以运行<br><span class="hljs-keyword">select</span> @<span class="hljs-variable">@have_profiling</span> ;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h3 id="7-3-1-查看每一条SQL耗时情况"><a href="#7-3-1-查看每一条SQL耗时情况" class="headerlink" title="7.3.1 查看每一条SQL耗时情况"></a>7.3.1 查看每一条SQL耗时情况</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> profiles;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/d5b5d2e4081f808a023c09414af7c72c.png" alt="image-20230412220631780"></p><h3 id="7-3-2-指定query-id查看各阶段耗时情况"><a href="#7-3-2-指定query-id查看各阶段耗时情况" class="headerlink" title="7.3.2 指定query_id查看各阶段耗时情况"></a>7.3.2 指定query_id查看各阶段耗时情况</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#其中，query_id 需要替换成图中的数字<br><span class="hljs-keyword">show</span> profile <span class="hljs-keyword">for</span> query query_id;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/2c8055238d11e739cbe98509b127fce4.png" alt="image-20230412220809805"></p><h3 id="7-3-3-指定query-id的SQL查看CPU使用情况"><a href="#7-3-3-指定query-id的SQL查看CPU使用情况" class="headerlink" title="7.3.3 指定query_id的SQL查看CPU使用情况"></a>7.3.3 指定query_id的SQL查看CPU使用情况</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">##其中，query_id 需要替换成图中的数字<br><span class="hljs-keyword">show</span> profile cpu <span class="hljs-keyword">for</span> query query_id;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/cce6ee62f7af44416396c57ac4cfccd7.png" alt="image-20230412221119167"></p><h2 id="7-4-explain"><a href="#7-4-explain" class="headerlink" title="7.4 explain"></a>7.4 explain</h2><p>EXPLAIN 或者 DESC 命令<strong>获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序。</strong></p><h3 id="7-4-1-语法"><a href="#7-4-1-语法" class="headerlink" title="7.4.1 语法"></a>7.4.1 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 直接在select语句之前加上关键字 explain / desc</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 ;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/477e9af3f57c81d84c40238e4c00a4b0.png" alt="image-20230412221657326"></p><h3 id="7-4-2-字段含义"><a href="#7-4-2-字段含义" class="headerlink" title="7.4.2 字段含义"></a>7.4.2 字段含义</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/b9ba34f0cbef7ce8fc6b15251b30b564.png" alt="image-20230412221852861"></p><h1 id="8-索引使用"><a href="#8-索引使用" class="headerlink" title="8. 索引使用"></a>8. 索引使用</h1><p>建立索引前后，查询数据的耗时不是一个量级的。</p><h2 id="8-1-最左前缀法则"><a href="#8-1-最左前缀法则" class="headerlink" title="8.1 最左前缀法则"></a>8.1 最左前缀法则</h2><p>如果<strong>索引了多列（联合索引），要遵守最左前缀法则</strong>。<strong>最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</strong></p><p>以 tb_user 表为例，我们先来查看一下之前 tb_user 表所创建的索引。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/1e6fc6a816beec398894d46f512af8f6.png" alt="image-20230413220335527"></p><p>在该表存在一个联合索引，涉及的字段和顺序分别为：profession， age，status。</p><blockquote><p>对于最左前缀法则指的是，查询时，最左边的列，也就是profession必须存在，否则索引全部失效。 而且中间不能跳过某一列，否则该列后面的字段索引将失效。</p></blockquote><p> 接下来，我们来演示几组案例，看一下具体的执行计划：</p><h3 id="8-1-1-case1"><a href="#8-1-1-case1" class="headerlink" title="8.1.1 case1"></a>8.1.1 case1</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">31</span> <span class="hljs-keyword">and</span> status<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/7dd73e5adab26e133d6f5aa49bf03184.png" alt="image-20230413220707964"></p><p>由于本次查询涉及到了三个字段，且左边的字段全部引用了，没有出现失效的情况，因此可能用到的索引和实际索引是一样的，索引的长度是54。</p><h3 id="8-1-2-case2"><a href="#8-1-2-case2" class="headerlink" title="8.1.2 case2"></a>8.1.2 case2</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">31</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/23a82fa89cbdf1fc2465a2a59a48f0f7.png" alt="image-20230413221205946"></p><p>此时发现还是使用了联合索引</p><h3 id="8-1-3-case3"><a href="#8-1-3-case3" class="headerlink" title="8.1.3 case3"></a>8.1.3 case3</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/61d470575f7ff289d39ae6854e226bc9.png" alt="image-20230413221722101"></p><p>经过这三个case发现，<strong>只要联合索引最左边的字段 profession存在，索引就会生效，只不过索引的长度不同。</strong> 而且由以上三组测试，我们也可以推测出profession字段索引长度为47、age 字段索引长度为2、status字段索引长度为5。</p><h3 id="8-1-4-case4"><a href="#8-1-4-case4" class="headerlink" title="8.1.4 case4"></a>8.1.4 case4</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">31</span> <span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/7d4367ac8f5f0353380659b577b5412d.png" alt="image-20230413221916569"></p><p>此时发现并没有使用联合索引</p><h3 id="8-1-5-case5"><a href="#8-1-5-case5" class="headerlink" title="8.1.5 case5"></a>8.1.5 case5</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/6e2413507c125ae5e921ab1085218624.png" alt="image-20230413222143846"></p><p>同样发现没有使用联合索引，因此，经过case4和case5得出结论：联合索引最左边的列profession不存在，不满足最左前缀法则，因此索引并未生效。</p><h3 id="8-1-6-case6"><a href="#8-1-6-case6" class="headerlink" title="8.1.6 case6"></a>8.1.6 case6</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span> <span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/a5d69f164b159d9cc49cf7dff7a5042c.png" alt="image-20230413222312813"></p><p>由于存在profession字段，<strong>最左边的列是存在的，索引满足最左前缀法则的基本条件。</strong>但是查询时，跳过了age这个列，所以后面的列索引是不会使用的，也就是<strong>索引部分生效</strong>，所以索引的长度就是47。</p><h3 id="8-1-7-case7"><a href="#8-1-7-case7" class="headerlink" title="8.1.7 case7"></a>8.1.7 case7</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">31</span> <span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/4142f4e2e8d283d0f2e5d7c16ac0088d.png" alt="image-20230413222903216"></p><p>可以看到，是完全满足最左前缀法则的，索引长度54，联合索引是生效的。</p><blockquote><p>最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，<strong>与我们编写SQL时，条件编写的先后顺序无关。</strong></p></blockquote><h2 id="8-2-范围查询"><a href="#8-2-范围查询" class="headerlink" title="8.2 范围查询"></a>8.2 范围查询</h2><p><strong>联合索引中，出现范围查询(&gt;,&lt;)【即大于号、小于号、逗号】，范围查询右侧的列索引失效。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/346a5e4ee72cd2f3952319faf643311b.png" alt="image-20230413223309116"></p><p>可看出现在走的是联合索引，且索引长度为49</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> status<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/4f220b196962ea73c20c0c0a67dcc5b9.png" alt="image-20230413223422857"></p><p>可知现在已经走了联合索引，但是索引的长度为49，就说明当范围查询使用&gt; 或 &lt; 时，其右边的status字段是没有走索引的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> status<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/ac54bd5da51df48cd26939620844ca8e.png" alt="image-20230413223616911"></p><p>当范围查询使用&gt;&#x3D; 或 &lt;&#x3D; 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引的。</p><p> 所以，在业务允许的情况下，尽可能的使用类似于 &gt;&#x3D; 或 &lt;&#x3D; 这类的范围查询，而避免使用 &gt; 或 &lt; 。</p><h2 id="8-3-索引失效情况"><a href="#8-3-索引失效情况" class="headerlink" title="8.3 索引失效情况"></a>8.3 索引失效情况</h2><h3 id="8-3-1-索引列运算"><a href="#8-3-1-索引列运算" class="headerlink" title="8.3.1 索引列运算"></a>8.3.1 索引列运算</h3><p> <strong>不要在索引列上进行运算操作， 索引将失效。</strong></p><p> 在tb_user表中，除了前面介绍的联合索引之外，还有一个索引，是phone字段的单列索引。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/e54bff44f86b8192deea5cc0e7d5faac.png" alt="image-20230413224308379"></p><ol><li><p>当根据phone字段进行等值匹配查询时, 索引生效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;17799990015&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/99de71cee9fdd4b894764462c0985800.png" alt="image-20230413224502637"></p></li><li><p>当根据phone字段进行函数运算操作之后，索引失效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> <span class="hljs-built_in">substring</span>(phone,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;15&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/03c495eb8f47fa91122218821cb49bcb.png" alt="image-20230413224437774"></p><p>此时type为null，进行了全表扫描，说明索引失效。</p></li></ol><h3 id="8-3-2-字符串不加引号"><a href="#8-3-2-字符串不加引号" class="headerlink" title="8.3.2 字符串不加引号"></a>8.3.2 字符串不加引号</h3><p> <strong>字符串类型字段使用时，不加引号，索引将失效。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-number">17799990015</span>;<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-number">17799990015</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/0e56981ca58f799b94e9cfeda43f0240.png" alt="image-20230413225621031"></p><p><strong>如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。</strong></p><h3 id="8-3-3-模糊查询"><a href="#8-3-3-模糊查询" class="headerlink" title="8.3.3 模糊查询"></a>8.3.3 模糊查询</h3><p>如果仅仅是<strong>尾部模糊匹配，索引不会失效</strong>。如果是<strong>头部模糊匹配，索引失效</strong>。</p><p>下面查询语句中，都是根据profession字段查询，符合最左前缀法则，联合索引是可以生效的， 我们主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。</p><h4 id="8-3-3-1-case1"><a href="#8-3-3-1-case1" class="headerlink" title="8.3.3.1 case1"></a>8.3.3.1 case1</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;软件%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/bf5a36c1c9081fad0536c6fb707003f7.png" alt="image-20230413230902741"></p><p>在like模糊查询中，在关键字后面加%，索引可以生效。</p><h4 id="8-3-3-2-case2"><a href="#8-3-3-2-case2" class="headerlink" title="8.3.3.2 case2"></a>8.3.3.2 case2</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%工程&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/1021558291e767b4814080bf85be198b.png" alt="image-20230413231020746"></p><p>在关键字前面加了%，索引将会失效。</p><h4 id="8-3-3-3-case3"><a href="#8-3-3-3-case3" class="headerlink" title="8.3.3.3 case3"></a>8.3.3.3 case3</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%工%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/eaddba6aa5c02202625df2cc83c75252.png" alt="image-20230413231102647"></p><p><strong>在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字前面加了%，索引将会失效。</strong></p><h3 id="8-3-4-or连接条件"><a href="#8-3-4-or连接条件" class="headerlink" title="8.3.4 or连接条件"></a>8.3.4 or连接条件</h3><p><strong>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。只有两侧都有索引，才会生效。</strong></p><h4 id="8-3-4-1-case1"><a href="#8-3-4-1-case1" class="headerlink" title="8.3.4.1 case1"></a>8.3.4.1 case1</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br><span class="hljs-comment">/**id主键索引，但是age没有索引**/</span><br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/3960ace0dfa801a387d3926209bf4b67.png" alt="image-20230413231527972"></p><p>由于age没有索引，所以即使id有索引，索引也会失效。</p><h4 id="8-3-4-2-case2"><a href="#8-3-4-2-case2" class="headerlink" title="8.3.4.2 case2"></a>8.3.4.2 case2</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;17799990017&#x27;</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br></code></pre></td></tr></table></figure><p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。</p><h4 id="8-3-4-3-case3"><a href="#8-3-4-3-case3" class="headerlink" title="8.3.4.3 case3"></a>8.3.4.3 case3</h4><p>对age建立索引后</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_user_age <span class="hljs-keyword">on</span> tb_user(age);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/642d1e400bc18a4316c888b776c11019.png" alt="image-20230413232111132"></p><p><strong>最终，我们发现，当or连接的条件，左右两侧字段都有索引时，索引才会生效。</strong></p><h3 id="8-3-5-数据分布影响"><a href="#8-3-5-数据分布影响" class="headerlink" title="8.3.5 数据分布影响"></a>8.3.5 数据分布影响</h3><p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p><p><strong>MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</strong></p><blockquote><p>因此可能会出现一模一样的SQL语句，先后执行了两次，结果查询计划是不一样的，这是因为<strong>查询时MySQL会评估，走索引快，还是全表扫描快，如果全表 扫描更快，则放弃索引走全表扫描。 因此 is null 、is not null 是否走索引，得具体情况具体分析，并不是固定的。</strong></p></blockquote><h2 id="8-4-SQL提示"><a href="#8-4-SQL提示" class="headerlink" title="8.4 SQL提示"></a>8.4 SQL提示</h2><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><h3 id="8-4-1-use-index"><a href="#8-4-1-use-index" class="headerlink" title="8.4.1 use index"></a>8.4.1 use index</h3><p>建议MySQL使用哪一个索引完成此次查询<strong>（仅仅是建议，MySQL内部还会再次进行评估）</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user use index(idx_user_pro) <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="8-4-2-ignore-index"><a href="#8-4-2-ignore-index" class="headerlink" title="8.4.2 ignore index"></a>8.4.2 ignore index</h3><p>忽略指定索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user ignore index(idx_user_pro) <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="8-4-3-force-index"><a href="#8-4-3-force-index" class="headerlink" title="8.4.3 force index"></a>8.4.3 force index</h3><p>强制使用索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user force index(idx_user_pro) <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="8-4-4-案例"><a href="#8-4-4-案例" class="headerlink" title="8.4.4 案例"></a>8.4.4 案例</h3><ol><li><p>创建profession单列索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_user_pro <span class="hljs-keyword">on</span> tb_user(profession);<br></code></pre></td></tr></table></figure></li><li><p>执行sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/aa6ece6a1be99c3270ddf7f499f8fb9d.png" alt="image-20230415221531884"></p><blockquote><p>此时发现，possible_keys（可能用到的索引）里出现了 idx_user_pro_age_sta（联合索引），idx_user_pro（上面刚刚建的单列索引），证明这两个索引都可能用到，但最终MySQL选择了idx_user_pro_age_sta索引。这是MySQL自动选择的结果。</p></blockquote></li><li><p>使用<code>use index</code></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/10e1ae544d36b025211d438df875bc69.png" alt="image-20230415221907817"></p><blockquote><p><strong>use index会让查询使用特定的索引而不是由查询优化器自动选择索引，当然MySQL内部还会再次进行评估。</strong></p><p><strong>这通常适用于查询优化器选择了错误的索引，即使在顶级查询执行计划中指定了正确的索引为主键也是如此。</strong></p><p><strong>此外，”USE INDEX”还可以用于强制覆盖查询优化器的限制以使用特定类型的访问方法，例如索引搜索或全表扫描。</strong></p></blockquote></li><li><p>使用<code>ignore index</code></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/04404f21a3a11c0333a49229f2211a24.png" alt="image-20230415222228055"></p><blockquote><p>可看出， <strong>ignore index会告诉MySQL不要使用特定的索引，即使它可以使用。</strong>使用其可以提高查询性能，因为MySQL不必在访问表时检查和使用指定的索引。”IGNORE INDEX”往往会对针对索引的特定查询语句产生积极的结果，但应谨慎使用以确保不会对全局查询性能造成不良的影响。</p></blockquote></li><li><p>使用<code>force index</code></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/21d25f60469c92a04d0dc7e661d1d56e.png" alt="image-20230415222440710"></p><blockquote><p> 可看出，<strong>force index用于告诉MySQL强制使用特定的索引，即使它不是最佳的索引。</strong></p><p>使用”FORCE INDEX”关键字可以让我们控制MySQL使用哪个索引来执行SELECT语句，以便获得更好的查询性能。</p><p>**如果强制使用错误的索引，就有可能得到错误的结果或者降低查询性能。</p><p>在使用”FORCE INDEX”时，<strong>应该先对查询进行优化，选择最适合的索引，然后再使用”FORCE INDEX”关键字。</strong>而且它只能影响单个查询。如果在整个应用程序中需要强制使用特定的索引，则需要更改表结构以强制使用索引。</p></blockquote></li></ol><h3 id="8-3-6-覆盖索引"><a href="#8-3-6-覆盖索引" class="headerlink" title="8.3.6 覆盖索引"></a>8.3.6 覆盖索引</h3><p>尽量使用覆盖索引，减少select。</p><p>覆盖索引是<strong>指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到</strong>。</p><h4 id="8-3-6-1-案例"><a href="#8-3-6-1-案例" class="headerlink" title="8.3.6.1 案例"></a>8.3.6.1 案例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id, profession <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span><span class="hljs-number">31</span> <span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span> ;<br><br>explain <span class="hljs-keyword">select</span> id,profession,age, status <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span><span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">31</span> <span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span> ;<br><br>explain <span class="hljs-keyword">select</span> id,profession,age, status, name <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">31</span> <span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span> ;<br><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">31</span> <span class="hljs-keyword">and</span> status<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/34f43c3842db06ce1df3ff4aa7c29001.png" alt="image-20230415224022379"></p><blockquote><p>差异点体现在后面的<code>Extra</code>；</p><p>前面两条SQL的结果为 Using where; Using Index ; </p><p>而后面两条SQL的结果为: Using index condition 。</p></blockquote><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/c8bbb8096e9488316a805baaa0f7322c.png" alt="image-20230415224118913"></p><blockquote><p>在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段 profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据。</p><p> 而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。</p></blockquote><p>表结构以及索引示意图</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/ff43e8af4fdb141f045a10beacbba736.png" alt="image-20230416205452727"></p><blockquote><p>id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/d2117d1cbacca3fc3153bda61b317e7e.png" alt="image-20230416210004818"></p><p>此时根据id查询，<strong>直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">selet id,name <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Arm&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/7276d259290cbe9d1ec6d1e73bde0c1f.png" alt="image-20230416210122145"></p><p>虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，<strong>在name的二级索引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">selet id,name,gender <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Arm&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/458c2f840c087d0185c142a52f187b60.png" alt="image-20230416210235537"></p><p>由于在name的二级索引中，不包含gender，所以，<strong>需要两次索引扫描，也就是需要回表查询，性能相对较差一点。</strong></p><blockquote><p>有一张表，有四个字段(id, username, password, status), 由于数据量大, 需要对 以下SQL语句进行优化, 该如何进行才是最优方案:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,username,password <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;itcast&#x27;</span>;<br></code></pre></td></tr></table></figure><p>解决办法：</p><p>针对username和password建立联合索引，这样就可以查询二级索引的时候，返回的字段为id,username,password。此时可以避免回表查询，性能较好。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_user_name_pass <span class="hljs-keyword">on</span> tb_user(username,password); <br></code></pre></td></tr></table></figure></blockquote><h2 id="8-5-前缀索引"><a href="#8-5-前缀索引" class="headerlink" title="8.5 前缀索引"></a>8.5 前缀索引</h2><p> 当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。</p><p><strong>此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</strong></p><h3 id="8-5-1-语法"><a href="#8-5-1-语法" class="headerlink" title="8.5.1 语法"></a>8.5.1 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_xxxx <span class="hljs-keyword">on</span> table_name(<span class="hljs-keyword">column</span>(n)) ;<br></code></pre></td></tr></table></figure><h3 id="8-5-2-前缀长度"><a href="#8-5-2-前缀长度" class="headerlink" title="8.5.2 前缀长度"></a>8.5.2 前缀长度</h3><p>可以<strong>根据索引的选择性来决定</strong>，而<strong>选择性是指不重复的索引值（基数）和数据表的记录总数的比值</strong>， <strong>索引选择性越高则查询效率越高</strong>， <strong>唯一索引</strong>的选择性是<strong>1</strong>，这是<strong>最好</strong>的索引选择性，性能也是最好的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">#示例<br>#求email中不重复的索引值（基数）<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> email) <span class="hljs-keyword">from</span> tb_user;<br>#求数据表中记录总数，也就是求数据表中的所有数据<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user;<br>#两个的比值即为索引的选择性<br><br>#上面两条语句也可以结合在一起，直接就可以输出索引的选择性<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> email) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;<br><br>#也可以选择几个前缀。平衡前缀和选择性之间的关系，如选择前五个前缀的选择性<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-built_in">substring</span>(email,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;<br></code></pre></td></tr></table></figure><h3 id="8-5-3-示例"><a href="#8-5-3-示例" class="headerlink" title="8.5.3 示例"></a>8.5.3 示例</h3><p>为tb_user表的email字段，建立长度为5<strong>【5指查询的字段的长度，并不是表内前5个的数据】</strong>的前缀索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_email_5 <span class="hljs-keyword">on</span> tb_user(email(<span class="hljs-number">5</span>)) ;<br></code></pre></td></tr></table></figure><p>查询’<a href="mailto:&#99;&#97;&#x6f;&#99;&#97;&#x6f;&#54;&#x36;&#x36;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d;">&#99;&#97;&#x6f;&#99;&#97;&#x6f;&#54;&#x36;&#x36;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d;</a>’ ，<strong>【在这里，索引会根据长度为5进行查询，即查询caoca】</strong>看看是否使用到我们为它建的前缀索引</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/8296044054c14a2068fd15901b0fa1a7.png" alt="image-20230416213245736"></p><p>前缀索引的查询流程</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/88e73c179fc43ea2e54de3689bff4d1c.png" alt="image-20230416213433677"></p><h2 id="8-6-单列索引和联合索引"><a href="#8-6-单列索引和联合索引" class="headerlink" title="8.6 单列索引和联合索引"></a>8.6 单列索引和联合索引</h2><p>单列索引：即一个索引只包含<strong>单</strong>个列。</p><p>联合索引：即一个索引包含了<strong>多</strong>个列。</p><p>目前tb_user 表中目前的索引情况是既有单列索引，又有联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,phone,name <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;17799990014&#x27;</span> <span class="hljs-keyword">and</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;貂蝉&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/41962cfc00054e66135e917fcf0359ad.png" alt="image-20230416214526350"></p><p>通过上述执行计划我们可以看出来，在and连接的两个字段 phone、name上都是有单列索引的，但是最终mysql只会选择一个索引，也就是说，<strong>只能走一个字段的索引，此时是会回表查询的。</strong></p><p>创建一个phone和name字段的联合索引来查询一下执行计划。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index idx_user_phone_name <span class="hljs-keyword">on</span> tb_user(phone,name);<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/d04ddd7dae3a62ffc097009aa49e2d8a.png" alt="image-20230416214952798"></p><p>MySQL依旧选择单列索引，此时我们使用use index 让MySQL用我们所建的联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,phone,name <span class="hljs-keyword">from</span> tb_user use index(idx_user_phone_name) <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;17799990014&#x27;</span> <span class="hljs-keyword">and</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;貂蝉&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/7fb6608961f507cc3fb711fcf3b87d1c.png" alt="image-20230416215308884"></p><p>此时，查询时，就走了联合索引，而<strong>在联合索引中包含 phone、name的信息，在叶子节点下挂的是对应的主键id，所以查询是无需回表查询的。</strong></p><blockquote><p>如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。</p></blockquote><p>当查询使用联合索引时，具体结构：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/d7ae8e87756a8c0472a4465883f9370c.png" alt="image-20230416215530502"></p><h1 id="9-索引设计原则"><a href="#9-索引设计原则" class="headerlink" title="9. 索引设计原则"></a>9. 索引设计原则</h1><ol><li>针对于数据量较大（业务中数据量超过一百万），且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索 引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li></ol>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-进阶-存储引擎</title>
    <link href="/MySQL-%E8%BF%9B%E9%98%B6-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/287076446eca/"/>
    <url>/MySQL-%E8%BF%9B%E9%98%B6-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/287076446eca/</url>
    
    <content type="html"><![CDATA[<h1 id="1-MySQL体系结构"><a href="#1-MySQL体系结构" class="headerlink" title="1. MySQL体系结构"></a>1. MySQL体系结构</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/f03c4f71cb4ce6825ef6a882188bd481.png" alt="image-20230409010508341"></p><h2 id="1-1-连接层"><a href="#1-1-连接层" class="headerlink" title="1.1 连接层"></a>1.1 连接层</h2><p>最上层是一些客户端和链接服务，包含本地 sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于 TCP&#x2F;IP的通信。</p><p><strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案。</strong>在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><h2 id="1-2-服务层"><a href="#1-2-服务层" class="headerlink" title="1.2 服务层"></a>1.2 服务层</h2><p> <strong>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。</strong></p><p>在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><h2 id="1-3-引擎层"><a href="#1-3-引擎层" class="headerlink" title="1.3 引擎层"></a>1.3 引擎层</h2><p> 存储引擎层， <strong>存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</strong></p><p>数据库中的索引是在存储引擎层实现的。</p><h2 id="1-4-存储层"><a href="#1-4-存储层" class="headerlink" title="1.4 存储层"></a>1.4 存储层</h2><p>数据存储层， <strong>主要是将数据</strong>(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)<strong>存储在文件系统之上，并完成与存储引擎的交互</strong>。</p><h1 id="2-存储引擎介绍"><a href="#2-存储引擎介绍" class="headerlink" title="2. 存储引擎介绍"></a>2. 存储引擎介绍</h1><p>存储引擎是mysql数据库的核心，我们也需要在合适的场景选择合适的存储引擎。</p><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。</p><p><strong>存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</strong>我们可以在创建表的时候，来指定选择的存储引擎，如果 没有指定将自动选择默认的存储引擎。</p><h2 id="2-1-建表指定存储引擎"><a href="#2-1-建表指定存储引擎" class="headerlink" title="2.1 建表指定存储引擎"></a>2.1 建表指定存储引擎</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>字段<span class="hljs-number">1</span> 字段<span class="hljs-number">1</span>类型 [ COMMENT 字段<span class="hljs-number">1</span>注释 ] ,<br>字段n 字段n类型 [COMMENT 字段n注释 ]<br>) ENGINE <span class="hljs-operator">=</span> INNODB [ COMMENT 表注释 ] ;<br>#就算不指定，默认也是InnoDB<br></code></pre></td></tr></table></figure><h2 id="2-2-查询当前数据库支持的存储引擎"><a href="#2-2-查询当前数据库支持的存储引擎" class="headerlink" title="2.2 查询当前数据库支持的存储引擎"></a>2.2 查询当前数据库支持的存储引擎</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> engines;<br></code></pre></td></tr></table></figure><h1 id="3-存储引擎特点"><a href="#3-存储引擎特点" class="headerlink" title="3. 存储引擎特点"></a>3. 存储引擎特点</h1><h2 id="3-1-InnoDB"><a href="#3-1-InnoDB" class="headerlink" title="3.1 InnoDB"></a>3.1 InnoDB</h2><p> <strong>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎</strong>，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p><h3 id="3-1-1-特点"><a href="#3-1-1-特点" class="headerlink" title="3.1.1 特点"></a>3.1.1 特点</h3><ul><li>DML【数据的增删改语句】<strong>操作遵循ACID模型</strong>【事务的四大特性：原子性、隔离性、持久性、一致性】，支持事务；</li><li><strong>行级锁</strong>，提高并发访问性能；</li><li>支持<strong>外键FOREIGN KEY</strong>约束，保证数据的完整性和正确性；</li></ul><h3 id="3-1-2-文件"><a href="#3-1-2-文件" class="headerlink" title="3.1.2 文件"></a>3.1.2 文件</h3><p>xxx.ibd：<strong>xxx代表的是表名</strong>，innoDB引擎的每张表都会对应这样一个<strong>表空间文件，存储该表的表结构</strong>（frm-早期的 、sdi-新版的）、数据和索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_file_per_table&#x27;</span>;<br></code></pre></td></tr></table></figure><p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 我们直接打开MySQL的 数据存放目录： C:\ProgramData\MySQL\MySQL Server 8.0\Data ， 这个目录下有很多文件夹，不同的文件夹代表不同的数据库，我们直接打开itcast文件夹。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/7cea458457fbfda1e2e3631c4865ee5e.png" alt="image-20230409221112599"></p><p>每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 </p><p>而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令ibd2sdi，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表 1 show variables like ‘innodb_file_per_table’; 的表结构。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/859855327923fc61b0dd7064981cccad.png" alt="image-20230409221201746"></p><h3 id="3-1-3-逻辑存储结构"><a href="#3-1-3-逻辑存储结构" class="headerlink" title="3.1.3 逻辑存储结构"></a>3.1.3 逻辑存储结构</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/985ce499239706abee669cca091101ff.png" alt="image-20230409221419123"></p><ol><li>表空间 : InnoDB存储引擎逻辑结构的最高层，<strong>ibd文件其实就是表空间文件</strong>，在表空间中可以包含多个Segment段。</li><li>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的 理，都是引擎自身完成，不需要人为对其控制，<strong>一个段中包含多个区</strong>。</li><li>区 : <strong>区是表空间的单元结构，每个区的大小为1M</strong>。 默认情况下， <strong>InnoDB存储引擎页大小为 16K</strong>， 即一个区中一共有64个连续的页。</li><li>页 : <strong>页是组成区的最小单元</strong>，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li><li>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，<strong>在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段</strong>(后面会详细介绍)。</li></ol><h2 id="3-2-MyISAM"><a href="#3-2-MyISAM" class="headerlink" title="3.2 MyISAM"></a>3.2 MyISAM</h2><p>MyISAM是MySQL早期的默认存储引擎。</p><h3 id="3-2-1-特点"><a href="#3-2-1-特点" class="headerlink" title="3.2.1 特点"></a>3.2.1 特点</h3><p>不支持事务，不支持外键</p><p>支持表锁，不支持行锁</p><p>访问速度快</p><h3 id="3-2-2-文件"><a href="#3-2-2-文件" class="headerlink" title="3.2.2 文件"></a>3.2.2 文件</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/caa802d53d4572ce3870aa803f06cca9.png" alt="image-20230409221800806"></p><p>xxx.MYD: 存储数据</p><p>xxx.MYI: 存储索引</p><p>xxx.sdi：存储表结构信息</p><h2 id="3-3-Memory"><a href="#3-3-Memory" class="headerlink" title="3.3 Memory"></a>3.3 Memory</h2><p> Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p><h3 id="3-3-1-特点"><a href="#3-3-1-特点" class="headerlink" title="3.3.1 特点"></a>3.3.1 特点</h3><p> 内存存放</p><p>hash索引（默认）</p><h3 id="3-3-2-文件"><a href="#3-3-2-文件" class="headerlink" title="3.3.2 文件"></a>3.3.2 文件</h3><p>xxx.sdi：存储表结构信息</p><h2 id="3-4-区别"><a href="#3-4-区别" class="headerlink" title="3.4 区别"></a>3.4 区别</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/fe13b87ec8228d2dad7568f217ad49c4.png" alt="image-20230409222137888"></p><blockquote><p>InnoDB引擎, 支持事务, 而MyISAM不支持。</p><p>InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。</p><p>InnoDB引擎, 支持外键, 而MyISAM是不支持的</p></blockquote><h1 id="4-存储引擎选择"><a href="#4-存储引擎选择" class="headerlink" title="4. 存储引擎选择"></a>4. 存储引擎选择</h1><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 是<strong>Mysql的默认存储引擎，支持事务、外键</strong>。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li><li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li><li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-基础-事务</title>
    <link href="/MySQL-%E5%9F%BA%E7%A1%80-%E4%BA%8B%E5%8A%A1/e71b38f600e2/"/>
    <url>/MySQL-%E5%9F%BA%E7%A1%80-%E4%BA%8B%E5%8A%A1/e71b38f600e2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-事务简介"><a href="#1-事务简介" class="headerlink" title="1. 事务简介"></a>1. 事务简介</h1><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些<strong>操作要么同时成功，要么同时失败。</strong></p><blockquote><p>默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。</p></blockquote><h1 id="2-事务操作"><a href="#2-事务操作" class="headerlink" title="2. 事务操作"></a>2. 事务操作</h1><h2 id="2-1-方式一"><a href="#2-1-方式一" class="headerlink" title="2.1 方式一"></a>2.1 方式一</h2><h3 id="2-1-1-查看-设置事务提交方式"><a href="#2-1-1-查看-设置事务提交方式" class="headerlink" title="2.1.1 查看&#x2F;设置事务提交方式"></a>2.1.1 查看&#x2F;设置事务提交方式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">#以下命令仅针对当前窗口有效，即console窗口，数据表的窗口是没有反应的<br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@autocommit</span> ;#查看事务的自动提交方式，看是否是自动提交，是<span class="hljs-number">1</span>则自动提交，是<span class="hljs-number">0</span>则手动提交<br>#可以通过<span class="hljs-keyword">set</span>命令将提交方式改成手动的<br><span class="hljs-keyword">SET</span> @<span class="hljs-variable">@autocommit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br></code></pre></td></tr></table></figure><h3 id="2-1-2-提交事务"><a href="#2-1-2-提交事务" class="headerlink" title="2.1.2 提交事务"></a>2.1.2 提交事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#得<span class="hljs-keyword">commit</span>后，数据才会在数据表的窗口有反应<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h3 id="2-1-3-回滚事务"><a href="#2-1-3-回滚事务" class="headerlink" title="2.1.3 回滚事务"></a>2.1.3 回滚事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#为了不让事务的数据出错，当我们输出命令输入错误的时候，使用<span class="hljs-keyword">rollback</span>回滚，就不会对数据造成影响<br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><blockquote><p>上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。</p></blockquote><h2 id="2-2-方式二"><a href="#2-2-方式二" class="headerlink" title="2.2 方式二"></a>2.2 方式二</h2><h3 id="2-2-1-开启事务"><a href="#2-2-1-开启事务" class="headerlink" title="2.2.1 开启事务"></a>2.2.1 开启事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION 或 <span class="hljs-keyword">BEGIN</span> ;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-提交事务"><a href="#2-2-2-提交事务" class="headerlink" title="2.2.2 提交事务"></a>2.2.2 提交事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-3-回滚事务"><a href="#2-2-3-回滚事务" class="headerlink" title="2.2.3 回滚事务"></a>2.2.3 回滚事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><h1 id="3-事务四大特性（ACID）"><a href="#3-事务四大特性（ACID）" class="headerlink" title="3. 事务四大特性（ACID）"></a>3. 事务四大特性（ACID）</h1><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><h1 id="4-并发事务问题"><a href="#4-并发事务问题" class="headerlink" title="4. 并发事务问题"></a>4. 并发事务问题</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/39d956cf5fe76d5f2af5861589a5afd6.png" alt="image-20230409000803140"></p><h2 id="4-1-脏读"><a href="#4-1-脏读" class="headerlink" title="4.1 脏读"></a>4.1 脏读</h2><p><strong>一个事务读到另外一个事务还没有提交的数据。</strong></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/3e201ff213bb00dd53fba0041ebe84b8.png" alt="image-20230409000606164"></p><h2 id="4-2-不可重复读"><a href="#4-2-不可重复读" class="headerlink" title="4.2 不可重复读"></a>4.2 不可重复读</h2><p><strong>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</strong></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/f6ef9c81eff41d004c9877762efa49f6.png" alt="image-20230409001204739"></p><h2 id="4-3-幻读"><a href="#4-3-幻读" class="headerlink" title="4.3 幻读"></a>4.3 幻读</h2><p><strong>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”。</strong></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/eef4d3fd8b240bcd57be6e40b698d06d.png" alt="image-20230409001347479"></p><h1 id="5-事务隔离级别"><a href="#5-事务隔离级别" class="headerlink" title="5. 事务隔离级别"></a>5. 事务隔离级别</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/8dc15758831956d7d98e1b3868918d53.png" alt="image-20230409001933136"></p><h2 id="5-1-查看事务隔离级别"><a href="#5-1-查看事务隔离级别" class="headerlink" title="5.1 查看事务隔离级别"></a>5.1 查看事务隔离级别</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@TRANSACTION_ISOLATION</span>;<br></code></pre></td></tr></table></figure><h2 id="5-2-设置事务隔离级别"><a href="#5-2-设置事务隔离级别" class="headerlink" title="5.2 设置事务隔离级别"></a>5.2 设置事务隔离级别</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#以下命令均不区分大小写！<br><span class="hljs-keyword">SET</span> [ SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span> ] TRANSACTION ISOLATION LEVEL &#123; READ UNCOMMITTED <span class="hljs-operator">|</span>READ COMMITTED <span class="hljs-operator">|</span> REPEATABLE READ <span class="hljs-operator">|</span> SERIALIZABLE &#125;<br></code></pre></td></tr></table></figure><blockquote><p>事务隔离级别越高，数据越安全，但是性能越低。就像Serializable 是数据最安全的，但是性能也是最低的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-基础-多表查询</title>
    <link href="/MySQL-%E5%9F%BA%E7%A1%80-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/d6a68715b3df/"/>
    <url>/MySQL-%E5%9F%BA%E7%A1%80-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/d6a68715b3df/</url>
    
    <content type="html"><![CDATA[<h1 id="1-多表关系"><a href="#1-多表关系" class="headerlink" title="1. 多表关系"></a>1. 多表关系</h1><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p><ul><li>一对多(多对一)</li><li>多对多</li><li>一对一</li></ul><h2 id="1-1-一对多"><a href="#1-1-一对多" class="headerlink" title="1.1 一对多"></a>1.1 一对多</h2><p>案例: 部门 与 员工的关系</p><p>关系: <strong>一个部门对应多个员工，一个员工对应一个部门</strong></p><p><strong>实现: 在多的一方建立外键，指向 一 的一方的主键</strong></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/3be8350f32d26c37d44e9f30052e8f43.png" alt="image-20230402173208525"></p><h2 id="1-2-多对多"><a href="#1-2-多对多" class="headerlink" title="1.2 多对多"></a>1.2 多对多</h2><p>案例: 学生 与 课程 的关系</p><p>关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择</p><p><strong>实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</strong></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/4840478456277cf6cd3211d0bd97cb90.png" alt="image-20230402173337290"></p><h2 id="1-3-一对一"><a href="#1-3-一对一" class="headerlink" title="1.3 一对一"></a>1.3 一对一</h2><p>案例: 用户 与 用户 详情的关系</p><p>关系: 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率</p><p>实现: <strong>在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</strong></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/f93b3d880a7298ad14a3297486cf7230.png" alt="image-20230402210828857"></p><h1 id="2-多表查询概述"><a href="#2-多表查询概述" class="headerlink" title="2. 多表查询概述"></a>2. 多表查询概述</h1><h2 id="2-1-执行sql脚本"><a href="#2-1-执行sql脚本" class="headerlink" title="2.1 执行sql脚本"></a>2.1 执行sql脚本</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs sql">#创建dept表，并插入数据<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept(<br>    id <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span> <span class="hljs-keyword">primary</span> key,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;部门名称&#x27;</span><br>)comment <span class="hljs-string">&#x27;部门表&#x27;</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept (id, name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;研发部&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;市场部&#x27;</span>),(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;财务部&#x27;</span>), (<span class="hljs-number">4</span>,<br><span class="hljs-string">&#x27;销售部&#x27;</span>), (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;总经办&#x27;</span>), (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;人事部&#x27;</span>);<br><br>#创建emp表，并插入数据<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp(<br>    id <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span> <span class="hljs-keyword">primary</span> key,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    age <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    job <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) comment <span class="hljs-string">&#x27;职位&#x27;</span>,<br>    salary <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;薪资&#x27;</span>,<br>    entrydate <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span>,<br>    managerid <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;直属领导ID&#x27;</span>,<br>    dept_id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;部门ID&#x27;</span><br>)comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<br><br>#添加外键<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> fk_emp_dept_id <span class="hljs-keyword">foreign</span> key (dept_id) <span class="hljs-keyword">references</span><br>dept(id);<br><br>#添加员工表数据<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, name, age, job,salary, entrydate, managerid, dept_id)<br><span class="hljs-keyword">VALUES</span><br>    (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;金庸&#x27;</span>, <span class="hljs-number">66</span>, <span class="hljs-string">&#x27;总裁&#x27;</span>,<span class="hljs-number">20000</span>, <span class="hljs-string">&#x27;2000-01-01&#x27;</span>, <span class="hljs-keyword">null</span>,<span class="hljs-number">5</span>),<br>    (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;张无忌&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;项目经理&#x27;</span>,<span class="hljs-number">12500</span>, <span class="hljs-string">&#x27;2005-12-05&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<br>    (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;杨逍&#x27;</span>, <span class="hljs-number">33</span>, <span class="hljs-string">&#x27;开发&#x27;</span>, <span class="hljs-number">8400</span>,<span class="hljs-string">&#x27;2000-11-03&#x27;</span>, <span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br>    (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;韦一笑&#x27;</span>, <span class="hljs-number">48</span>, <span class="hljs-string">&#x27;开发&#x27;</span>,<span class="hljs-number">11000</span>, <span class="hljs-string">&#x27;2002-02-05&#x27;</span>, <span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br>    (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;常遇春&#x27;</span>, <span class="hljs-number">43</span>, <span class="hljs-string">&#x27;开发&#x27;</span>,<span class="hljs-number">10500</span>, <span class="hljs-string">&#x27;2004-09-07&#x27;</span>, <span class="hljs-number">3</span>,<span class="hljs-number">1</span>),<br>    (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;小昭&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;程序员鼓励师&#x27;</span>,<span class="hljs-number">6600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br>    (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;灭绝&#x27;</span>, <span class="hljs-number">60</span>, <span class="hljs-string">&#x27;财务总监&#x27;</span>,<span class="hljs-number">8500</span>, <span class="hljs-string">&#x27;2002-09-12&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">3</span>),<br>    (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;周芷若&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;会计&#x27;</span>,<span class="hljs-number">4800</span>, <span class="hljs-string">&#x27;2006-06-02&#x27;</span>, <span class="hljs-number">7</span>,<span class="hljs-number">3</span>),<br>    (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;丁敏君&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;出纳&#x27;</span>,<span class="hljs-number">5250</span>, <span class="hljs-string">&#x27;2009-05-13&#x27;</span>, <span class="hljs-number">7</span>,<span class="hljs-number">3</span>),<br>    (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;赵敏&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;市场部总监&#x27;</span>,<span class="hljs-number">12500</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<br>    (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;鹿杖客&#x27;</span>, <span class="hljs-number">56</span>, <span class="hljs-string">&#x27;职员&#x27;</span>,<span class="hljs-number">3750</span>, <span class="hljs-string">&#x27;2006-10-03&#x27;</span>, <span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>    (<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;鹤笔翁&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;职员&#x27;</span>,<span class="hljs-number">3750</span>, <span class="hljs-string">&#x27;2007-05-09&#x27;</span>, <span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>    (<span class="hljs-number">13</span>, <span class="hljs-string">&#x27;方东白&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;职员&#x27;</span>,<span class="hljs-number">5500</span>, <span class="hljs-string">&#x27;2009-02-12&#x27;</span>, <span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>    (<span class="hljs-number">14</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">88</span>, <span class="hljs-string">&#x27;销售总监&#x27;</span>,<span class="hljs-number">14000</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">4</span>),<br>    (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;俞莲舟&#x27;</span>, <span class="hljs-number">38</span>, <span class="hljs-string">&#x27;销售&#x27;</span>,<span class="hljs-number">4600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">14</span>,<span class="hljs-number">4</span>),<br>    (<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;宋远桥&#x27;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&#x27;销售&#x27;</span>,<span class="hljs-number">4600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">14</span>,<span class="hljs-number">4</span>),<br>    (<span class="hljs-number">17</span>, <span class="hljs-string">&#x27;陈友谅&#x27;</span>, <span class="hljs-number">42</span>, <span class="hljs-keyword">null</span>,<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;2011-10-12&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><h2 id="2-2-概述"><a href="#2-2-概述" class="headerlink" title="2.2 概述"></a>2.2 概述</h2><p>多表查询就是指从多张表中查询数据。</p><h3 id="2-2-1-笛卡尔积"><a href="#2-2-1-笛卡尔积" class="headerlink" title="2.2.1 笛卡尔积"></a>2.2.1 笛卡尔积</h3><p><strong>笛卡尔乘积是指在数学中，两个集合 A 集合 和 B 集合的所有组合情况。</strong></p><p>如果直接执行<code>select * from emp , dept ; </code>，此时会将两个表的记录相乘。</p><p>但是在多表查询中，需要消除无效的笛卡尔积，只保留有效数据</p><p>正确姿势</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#当员工表里的部门id 等于 部门表中的id ，就可以来消除无效的笛卡尔积<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp,dept <span class="hljs-keyword">where</span> emp.dept_id <span class="hljs-operator">=</span> dept.id;<br></code></pre></td></tr></table></figure><h2 id="2-3-分类"><a href="#2-3-分类" class="headerlink" title="2.3 分类"></a>2.3 分类</h2><h5 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h5><ol><li><p>内连接：相当于<strong>查询A、B交集部分数据</strong></p></li><li><p>外连接</p><ol><li>左外连接：查询<strong>左表</strong>所有数据，以及两张表交集部分数据</li><li>右外连接：查询<strong>右表</strong>所有数据，以及两张表交集部分数据</li></ol></li><li><p>自连接：<strong>当前表与自身</strong>的连接查询，<strong>自连接必须使用表别名</strong></p></li></ol><h1 id="3-内连接"><a href="#3-内连接" class="headerlink" title="3. 内连接"></a>3. 内连接</h1><p><strong>内连接查询的是两张表交集部分的数据。</strong></p><p>分为隐式内连接、显式内连接</p><h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><p>隐式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> , 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件 ... ;<br></code></pre></td></tr></table></figure><p>显式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [ <span class="hljs-keyword">INNER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件 ... ;<br></code></pre></td></tr></table></figure><h1 id="4-外连接"><a href="#4-外连接" class="headerlink" title="4. 外连接"></a>4. 外连接</h1><p>外连接分为两种，分别是：左外连接 和 右外连接。</p><h2 id="4-1-语法"><a href="#4-1-语法" class="headerlink" title="4.1 语法"></a>4.1 语法</h2><p>左外连接：左外连接相当于左表的所有数据，当然也包含表1和表2交集部分的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [ <span class="hljs-keyword">OUTER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件 ... ;<br></code></pre></td></tr></table></figure><p>右外连接：右外连接相当于右表的所有数据，当然也包含表1和表2交集部分的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> [ <span class="hljs-keyword">OUTER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件 ... ;<br></code></pre></td></tr></table></figure><blockquote><ol><li>左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。</li><li>而我们在日常开发使用时，更偏向于左外连接。</li></ol></blockquote><h1 id="5-自连接"><a href="#5-自连接" class="headerlink" title="5. 自连接"></a>5. 自连接</h1><h2 id="5-1-自连接查询"><a href="#5-1-自连接查询" class="headerlink" title="5.1 自连接查询"></a>5.1 自连接查询</h2><p>顾名思义，就是自己连接自己，也就是把一张表连接查询多次。</p><h3 id="5-1-1-语法"><a href="#5-1-1-语法" class="headerlink" title="5.1.1  语法"></a>5.1.1  语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表A 别名A <span class="hljs-keyword">JOIN</span> 表A 别名B <span class="hljs-keyword">ON</span> 条件 ... ;<br></code></pre></td></tr></table></figure><p><strong>对于自连接查询，可以是内连接查询，也可以是外连接查询。</strong></p><blockquote><p>在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段。</p></blockquote><h2 id="5-2-联合查询"><a href="#5-2-联合查询" class="headerlink" title="5.2 联合查询"></a>5.2 联合查询</h2><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><h3 id="5-2-1-语法"><a href="#5-2-1-语法" class="headerlink" title="5.2.1 语法"></a>5.2.1 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表A ...<br><span class="hljs-keyword">UNION</span> [ <span class="hljs-keyword">ALL</span> ]<br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表B ....;<br></code></pre></td></tr></table></figure><blockquote><ul><li>对于联合查询的<strong>多张表的列数</strong>必须保持一致，<strong>字段类型</strong>也需要保持一致。</li><li>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</li></ul></blockquote><h1 id="6-子查询"><a href="#6-子查询" class="headerlink" title="6. 子查询"></a>6. 子查询</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p><strong>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</strong></p><h3 id="6-1-1-语法"><a href="#6-1-1-语法" class="headerlink" title="6.1.1 语法"></a>6.1.1 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> column1 <span class="hljs-operator">=</span> ( <span class="hljs-keyword">SELECT</span> column1 <span class="hljs-keyword">FROM</span> t2 );<br></code></pre></td></tr></table></figure><h3 id="6-1-2-分类"><a href="#6-1-2-分类" class="headerlink" title="6.1.2 分类"></a>6.1.2 分类</h3><p>根据子查询结果不同，分为：</p><ol><li>标量子查询（子查询结果为单个值）</li><li>列子查询(子查询结果为一列)</li><li>行子查询(子查询结果为一行)</li><li>表子查询(子查询结果为多行多列)</li></ol><p>根据子查询位置，分为：</p><ol><li>WHERE之后</li><li>FROM之后</li><li>SELECT之后</li></ol><h2 id="6-2-标量子查询"><a href="#6-2-标量子查询" class="headerlink" title="6.2 标量子查询"></a>6.2 标量子查询</h2><p> 子查询返回的结果是<strong>单个值（数字、字符串、日期等）</strong>，最简单的形式，这种子查询称为标量子查询。</p><p><strong>常用的操作符：&#x3D; &lt;&gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;</strong></p><h2 id="6-3-列子查询"><a href="#6-3-列子查询" class="headerlink" title="6.3 列子查询"></a>6.3 列子查询</h2><p><strong>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</strong></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/44c0f7dfcf14aaaa218563b9a94a4c77.png" alt="image-20230402231528557"></p><h2 id="6-4-行子查询"><a href="#6-4-行子查询" class="headerlink" title="6.4 行子查询"></a>6.4 行子查询</h2><p>子查询返回的结果是<strong>一行（可以是多列）</strong>，这种子查询称为行子查询。 </p><p>常用的操作符：&#x3D; 、&lt;&gt; 、IN 、NOT IN</p><h2 id="6-5-表子查询"><a href="#6-5-表子查询" class="headerlink" title="6.5 表子查询"></a>6.5 表子查询</h2><p>子查询返回的结果是<strong>多行多列</strong>，这种子查询称为表子查询。 </p><p>常用的操作符：IN</p><h1 id="7-案例"><a href="#7-案例" class="headerlink" title="7. 案例"></a>7. 案例</h1><h2 id="7-1-数据准备"><a href="#7-1-数据准备" class="headerlink" title="7.1 数据准备"></a>7.1 数据准备</h2><p>涉及到的表就三张：emp员工表、dept部门表、salgrade薪资等级表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> salgrade(<br>grade <span class="hljs-type">int</span>,<br>losal <span class="hljs-type">int</span>,#最低工资<br>hisal <span class="hljs-type">int</span>#最高工资<br>) comment <span class="hljs-string">&#x27;薪资等级表&#x27;</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>,<span class="hljs-number">3001</span>,<span class="hljs-number">5000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>,<span class="hljs-number">5001</span>,<span class="hljs-number">8000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">4</span>,<span class="hljs-number">8001</span>,<span class="hljs-number">10000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">5</span>,<span class="hljs-number">10001</span>,<span class="hljs-number">15000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">6</span>,<span class="hljs-number">15001</span>,<span class="hljs-number">20000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>,<span class="hljs-number">20001</span>,<span class="hljs-number">25000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">8</span>,<span class="hljs-number">25001</span>,<span class="hljs-number">30000</span>);<br></code></pre></td></tr></table></figure><ol><li><p>查询员工的姓名、年龄、职位、部门信息 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> emp.name,age,job,dept.name <span class="hljs-keyword">from</span> emp,dept <span class="hljs-keyword">where</span> emp.dept_id <span class="hljs-operator">=</span> dept.id;<br></code></pre></td></tr></table></figure></li><li><p>查询年龄小于30岁的员工的姓名、年龄、职位、部门信息</p></li></ol>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> emp.name,age,job,d.name <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> emp.dept_id <span class="hljs-operator">=</span> d.id <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>查询拥有员工的部门ID、部门名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#<span class="hljs-keyword">distinct</span> 去掉重复数据<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> dept.id,dept.name <span class="hljs-keyword">from</span> emp,dept <span class="hljs-keyword">where</span> emp.dept_id <span class="hljs-operator">=</span> dept.id;<br></code></pre></td></tr></table></figure></li><li><p>查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">#如果在外连接需要在加条件，就在<span class="hljs-keyword">on</span>后面的条件接上<span class="hljs-keyword">where</span>，然后输入新的条件<br>#如果把<span class="hljs-keyword">where</span>改成<span class="hljs-keyword">and</span>，会显示不全<br>#因为使用<span class="hljs-keyword">where</span>，可以跳出左外连接的限制；而使用<span class="hljs-keyword">and</span>，依然在左外连接之内，会显示左表所有<br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>,d.name <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> d.id <span class="hljs-operator">=</span> e.dept_id <span class="hljs-keyword">where</span> e.age <span class="hljs-operator">&gt;</span> <span class="hljs-number">40</span>;<br></code></pre></td></tr></table></figure></li><li><p>查询所有员工的工资等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> emp.<span class="hljs-operator">*</span>,grade <span class="hljs-keyword">from</span> emp,salgrade <span class="hljs-keyword">where</span> emp.salary <span class="hljs-operator">&gt;=</span> salgrade.losal <span class="hljs-keyword">and</span> emp.salary <span class="hljs-operator">&lt;=</span> salgrade.hisal;<br></code></pre></td></tr></table></figure></li><li><p>查询“研发部”所有员工的信息以及工资等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> emp.<span class="hljs-operator">*</span>,grade <span class="hljs-keyword">from</span> emp,salgrade,dept <span class="hljs-keyword">where</span> (emp.salary <span class="hljs-keyword">between</span> salgrade.losal <span class="hljs-keyword">and</span> salgrade.hisal) <span class="hljs-keyword">and</span> emp.dept_id <span class="hljs-operator">=</span> dept.id <span class="hljs-keyword">and</span> dept.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>查询 “研发部” 员工的平均工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(e.salary) <span class="hljs-keyword">from</span> emp e,dept d <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id <span class="hljs-keyword">and</span> d.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>查询工资比 “灭绝” 高的员工信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span>(<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">where</span> e.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;灭绝&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>查询比平均薪资高的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary) <span class="hljs-keyword">from</span> emp e);<br></code></pre></td></tr></table></figure></li><li><p>查询低于本部门平均工资的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&lt;</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary) <span class="hljs-keyword">from</span> emp e ,dept d <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id <span class="hljs-keyword">and</span> d.name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;研发部&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>查询所有的部门信息，并统计部门的员工人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,name,(<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id) <span class="hljs-keyword">from</span> dept d;<br></code></pre></td></tr></table></figure></li><li><p>查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s.name , s.no , c.name <span class="hljs-keyword">from</span> student01 s , student_course sc , course01 c <span class="hljs-keyword">where</span> s.id <span class="hljs-operator">=</span> sc.studentid <span class="hljs-keyword">and</span> sc.courseid <span class="hljs-operator">=</span> c.id ;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-基础-约束</title>
    <link href="/MySQL-%E5%9F%BA%E7%A1%80-%E7%BA%A6%E6%9D%9F/e7ac4524e181/"/>
    <url>/MySQL-%E5%9F%BA%E7%A1%80-%E7%BA%A6%E6%9D%9F/e7ac4524e181/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>概念：<strong>约束是作用于表中字段上的规则，用于限制存储在表中的数据。</strong></p><p>目的：保证数据库中数据的<strong>正确、有效性和完整性</strong>。</p><h2 id="1-1-分类"><a href="#1-1-分类" class="headerlink" title="1.1 分类"></a>1.1 分类</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/07d45b88d744fb77cf71eb710cf5dd16.png" alt="image-20230401220221581"></p><blockquote><p>约束是作用于表中字段上的，可以在创建表&#x2F;修改表的时候添加约束。</p></blockquote><h2 id="2-约束演示"><a href="#2-约束演示" class="headerlink" title="2. 约束演示"></a>2. 约束演示</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/796947c9d0bc8ee1deeec62a3c37995c.png" alt="image-20230401220545922"></p><p>对应的建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> userr(<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment comment <span class="hljs-string">&#x27;主键&#x27;</span>,     #auto_increment 表示：自动增长<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">unique</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    age <span class="hljs-type">int</span> <span class="hljs-keyword">check</span> ( age<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span> <span class="hljs-operator">&amp;&amp;</span> age<span class="hljs-operator">&lt;=</span><span class="hljs-number">120</span> ) comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    status <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;1&#x27;</span> comment <span class="hljs-string">&#x27;状态&#x27;</span>,<br>    gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span> <br>)comment <span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="3-外键约束"><a href="#3-外键约束" class="headerlink" title="3. 外键约束"></a>3. 外键约束</h1><p><strong>外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</strong></p><blockquote><p>不推荐使用，性能较差</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-基础-函数</title>
    <link href="/MySQL-%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/15eed543fc7f/"/>
    <url>/MySQL-%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/15eed543fc7f/</url>
    
    <content type="html"><![CDATA[<h1 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1. 字符串函数"></a>1. 字符串函数</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/99b7ce6e8c72aa38b4c57b0b01045e48.png" alt="image-20230331231723580"></p><h2 id="1-1-concat"><a href="#1-1-concat" class="headerlink" title="1.1 concat"></a>1.1 concat</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;Hello&#x27;</span>,<span class="hljs-string">&#x27;MySQL&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="1-2-lower"><a href="#1-2-lower" class="headerlink" title="1.2 lower"></a>1.2 lower</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">lower</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="1-3-uppper"><a href="#1-3-uppper" class="headerlink" title="1.3 uppper"></a>1.3 uppper</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">upper</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="1-4-lpad"><a href="#1-4-lpad" class="headerlink" title="1.4 lpad"></a>1.4 lpad</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#中间<span class="hljs-number">5</span>的意思是：从左到右填充到<span class="hljs-number">5</span>个字符<br><span class="hljs-keyword">select</span> lpad(<span class="hljs-string">&#x27;01&#x27;</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;-&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="1-5-rpad"><a href="#1-5-rpad" class="headerlink" title="1.5 rpad"></a>1.5 rpad</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#中间<span class="hljs-number">5</span>的意思是：从右到左填充到<span class="hljs-number">5</span>个字符<br><span class="hljs-keyword">select</span> rpad(<span class="hljs-string">&#x27;01&#x27;</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;-&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="1-6-trim"><a href="#1-6-trim" class="headerlink" title="1.6 trim"></a>1.6 trim</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27;  Hello  MySQL  &#x27;</span>);<br>#输出结果：Hello  MySQL 只去除头尾，中间不去除<br></code></pre></td></tr></table></figure><h2 id="1-7-substring"><a href="#1-7-substring" class="headerlink" title="1.7 substring"></a>1.7 substring</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">#“<span class="hljs-number">1</span>”代表的是：从第一个字符开始截取<br>#“<span class="hljs-number">5</span>”代表的是：截取五个<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;Hello MySQL&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);<br>#输出结果：Hello<br></code></pre></td></tr></table></figure><h1 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2. 数值函数"></a>2. 数值函数</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/fb001dc580e31f464ea0487dbaa87760.png" alt="image-20230331234959858"></p><h2 id="2-1-ceil"><a href="#2-1-ceil" class="headerlink" title="2.1 ceil"></a>2.1 ceil</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.5</span>);<br>#输出结果：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="2-2-floor"><a href="#2-2-floor" class="headerlink" title="2.2 floor"></a>2.2 floor</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">2.7</span>);<br>#输出结果：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="2-3-mod"><a href="#2-3-mod" class="headerlink" title="2.3 mod"></a>2.3 mod</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br>#输出结果：<span class="hljs-number">3</span><br>#相当于是 <span class="hljs-number">3</span> 除以 <span class="hljs-number">4</span> ，余数为<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="2-4-rand"><a href="#2-4-rand" class="headerlink" title="2.4 rand"></a>2.4 rand</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> rand();<br></code></pre></td></tr></table></figure><h2 id="2-5-round"><a href="#2-5-round" class="headerlink" title="2.5 round"></a>2.5 round</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> round(<span class="hljs-number">4.7657</span>,<span class="hljs-number">2</span>);<br>#输出结果：<span class="hljs-number">4.77</span><br>#第一个数是想被四舍五入的数<br>#第二个是想保留多少位小数<br></code></pre></td></tr></table></figure><h1 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3. 日期函数"></a>3. 日期函数</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/e9641096be39466867179be92b05a00b.png" alt="image-20230401000434109"></p><h2 id="3-1-curdate"><a href="#3-1-curdate" class="headerlink" title="3.1 curdate"></a>3.1 curdate</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> curdate();<br></code></pre></td></tr></table></figure><h2 id="3-2-curtime"><a href="#3-2-curtime" class="headerlink" title="3.2 curtime"></a>3.2 curtime</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> curtime();<br></code></pre></td></tr></table></figure><h2 id="3-3-now"><a href="#3-3-now" class="headerlink" title="3.3 now"></a>3.3 now</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> now();<br></code></pre></td></tr></table></figure><h2 id="3-4-YEAR-MONTH-DAY"><a href="#3-4-YEAR-MONTH-DAY" class="headerlink" title="3.4 YEAR&#x2F;MONTH&#x2F;DAY"></a>3.4 YEAR&#x2F;MONTH&#x2F;DAY</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">YEAR</span>(now());<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">MONTH</span>(now());<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">DAY</span>(now());<br></code></pre></td></tr></table></figure><h2 id="3-5-day-add"><a href="#3-5-day-add" class="headerlink" title="3.5 day_add"></a>3.5 day_add</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">#<span class="hljs-type">INTERVAL</span> 代表向后推多久<br><span class="hljs-keyword">select</span> date_add(now(),<span class="hljs-type">INTERVAL</span> <span class="hljs-number">70</span> <span class="hljs-keyword">DAY</span>);<br>#举一反三，我们也可以<br><span class="hljs-keyword">select</span> date_add(now(),<span class="hljs-type">INTERVAL</span> <span class="hljs-number">70</span> <span class="hljs-keyword">MONTH</span>);<br><span class="hljs-keyword">select</span> date_add(now(),<span class="hljs-type">INTERVAL</span> <span class="hljs-number">70</span> <span class="hljs-keyword">YEAR</span>);<br></code></pre></td></tr></table></figure><h2 id="3-6-datadiff"><a href="#3-6-datadiff" class="headerlink" title="3.6 datadiff"></a>3.6 datadiff</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#要输入两个数，且第一个年月日时长大于第二个，不然会出现负数<br><span class="hljs-keyword">select</span> datediff(<span class="hljs-string">&#x27;2023-04-01&#x27;</span>,<span class="hljs-string">&#x27;2003-05-15&#x27;</span>);<br></code></pre></td></tr></table></figure><h1 id="4-流程函数"><a href="#4-流程函数" class="headerlink" title="4. 流程函数"></a>4. 流程函数</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/0fff6f474dbe74c0074068bba635092d.png" alt="image-20230401131046816"></p><h2 id="4-1-if"><a href="#4-1-if" class="headerlink" title="4.1 if"></a>4.1 if</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> if(<span class="hljs-literal">true</span>,<span class="hljs-string">&#x27;ok&#x27;</span>,<span class="hljs-string">&#x27;no&#x27;</span>);<br>#一般ture或<span class="hljs-literal">false</span>里面放的是条件表达式<br>#输出结果：ok<br></code></pre></td></tr></table></figure><h2 id="4-2-ifnull"><a href="#4-2-ifnull" class="headerlink" title="4.2 ifnull"></a>4.2 ifnull</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ifnull(<span class="hljs-string">&#x27;ok&#x27;</span>,<span class="hljs-string">&#x27;no&#x27;</span>);<br>#如果第一个值不为空，则返回第一个值；如果为空，则返回第二个值，即返回默认值<br>#输出结果：ok<br><br><span class="hljs-keyword">select</span> ifnull(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;no&#x27;</span>);<br>#此时第一个值为空，因此返回第二个值<br>#输出结果：<span class="hljs-keyword">no</span><br></code></pre></td></tr></table></figure><h2 id="4-3-case-when-then-else-end"><a href="#4-3-case-when-then-else-end" class="headerlink" title="4.3 case when then else end"></a>4.3 case when then else end</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>       name,<br>(<span class="hljs-keyword">case</span> workaddress <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;北京&#x27;</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;一线城市&#x27;</span> <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;上海&#x27;</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;一线城市&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;二线城市&#x27;</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;工作地址&#x27;</span><br><span class="hljs-keyword">from</span> emp ;<br>#<span class="hljs-keyword">case</span>  需要查询的东西 <span class="hljs-keyword">when</span> value1 <span class="hljs-keyword">then</span> value2  （ 意思是把value1归为value2类下）如果想继续加，就在后面继续<span class="hljs-keyword">when</span>——<span class="hljs-keyword">then</span>即可<br>#如果 北京 的值被找到了l，则返回 一线城市 ，··．否则返回<span class="hljs-keyword">default</span>默认值，即 二线城市 <br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-基础-SQL</title>
    <link href="/MySQL-%E5%9F%BA%E7%A1%80-SQL/b480c0de1b0e/"/>
    <url>/MySQL-%E5%9F%BA%E7%A1%80-SQL/b480c0de1b0e/</url>
    
    <content type="html"><![CDATA[<h1 id="1-SQL分类"><a href="#1-SQL分类" class="headerlink" title="1. SQL分类"></a>1. SQL分类</h1><p>SQL语句，根据其功能主要可以分为四类：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/ed6094d365e3e42ba41e4e488a3e5b74.png" alt="image-20230325223355908"></p><h1 id="2-DDL"><a href="#2-DDL" class="headerlink" title="2. DDL"></a>2. DDL</h1><p>Data Definition Language，数据定义语言，用来定义数据库对象(数据库，表，字段) 。</p><h2 id="2-1-数据库操作"><a href="#2-1-数据库操作" class="headerlink" title="2.1 数据库操作"></a>2.1 数据库操作</h2><p>查询所有数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> databases;<br></code></pre></td></tr></table></figure><p> 查询当前数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> database();<br></code></pre></td></tr></table></figure><p>创建数据库</p><blockquote><p>可以通过 <strong>if not exists</strong> 参数来解决这个问题，数据库不存在, 则创建该数据库，如果存在，则不创建。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database [ if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> ] 数据库名 [ <span class="hljs-keyword">default</span> charset 字符集 ] [ <span class="hljs-keyword">collate</span> 排序<br>规则 ] ;<br></code></pre></td></tr></table></figure><p>删除数据库</p><blockquote><p>如果删除一个不存在的数据库，将会报错。此时，可以加上参数 <strong>if exists</strong> ，如果数据库存在，再执行删除，否则不执行删除。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> database [ if <span class="hljs-keyword">exists</span> ] 数据库名 ;<br></code></pre></td></tr></table></figure><p>切换数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">use 数据库名 ;<br></code></pre></td></tr></table></figure><h2 id="2-2-表操作"><a href="#2-2-表操作" class="headerlink" title="2.2 表操作"></a>2.2 表操作</h2><p>查询当前数据库下所有表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> tables;<br></code></pre></td></tr></table></figure><p>查看指定表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">desc</span> 表名 ;<br></code></pre></td></tr></table></figure><p>查询指定表的建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名 ;<br></code></pre></td></tr></table></figure><p>创建表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>字段<span class="hljs-number">1</span> 字段<span class="hljs-number">1</span>类型 [ COMMENT 字段<span class="hljs-number">1</span>注释 ],<br>字段<span class="hljs-number">2</span> 字段<span class="hljs-number">2</span>类型 [COMMENT 字段<span class="hljs-number">2</span>注释 ],<br>字段<span class="hljs-number">3</span> 字段<span class="hljs-number">3</span>类型 [COMMENT 字段<span class="hljs-number">3</span>注释 ],<br>......<br>字段n 字段n类型 [COMMENT 字段n注释 ]<br>) [ COMMENT 表注释 ] ;<br></code></pre></td></tr></table></figure><h2 id="2-3-数据类型"><a href="#2-3-数据类型" class="headerlink" title="2.3 数据类型"></a>2.3 数据类型</h2><p>MySQL中的数据类型有很多，主要分为三类：<strong>数值类型、字符串类型、日期时间类型</strong>。</p><h3 id="2-3-1-数值类型"><a href="#2-3-1-数值类型" class="headerlink" title="2.3.1 数值类型"></a>2.3.1 数值类型</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/46fb13fb097745454b369901a92fa8f7.png" alt="image-20230325224159346"></p><h3 id="2-3-2-字符串类型"><a href="#2-3-2-字符串类型" class="headerlink" title="2.3.2 字符串类型"></a>2.3.2 字符串类型</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/6618e946db54b9da7efd74824c7ccb1f.png" alt="image-20230325224310246"></p><blockquote><ol><li>char 与 varchar 都可以描述字符串。</li><li>char是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。</li><li>varchar是变长字符串，指定的长度为最大占用长度 。</li><li><strong>varchar在使用的时候，会去计算所占用的空间</strong>，相对来说，char的性能会更高些。</li></ol></blockquote><h3 id="2-3-3-日期时间类型"><a href="#2-3-3-日期时间类型" class="headerlink" title="2.3.3 日期时间类型"></a>2.3.3 日期时间类型</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/c1b28efca52a2143c0408d0dad1c2b25.png" alt="image-20230325224324059"></p><h2 id="2-4-修改表"><a href="#2-4-修改表" class="headerlink" title="2.4 修改表"></a>2.4 修改表</h2><p>添加字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];<br></code></pre></td></tr></table></figure><p>修改数据类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型 (长度);<br></code></pre></td></tr></table></figure><p>修改字段名和字段类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];<br></code></pre></td></tr></table></figure><p>删除字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> 字段名;<br></code></pre></td></tr></table></figure><p>修改表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 RENAME <span class="hljs-keyword">TO</span> 新表名;<br></code></pre></td></tr></table></figure><p>删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> [ IF <span class="hljs-keyword">EXISTS</span> ] 表名;<br></code></pre></td></tr></table></figure><p>删除指定表，并重新建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure><h1 id="3-DML"><a href="#3-DML" class="headerlink" title="3. DML"></a>3. DML</h1><p>DML英文全称是Data Manipulation Language(<strong>数据操作语言</strong>)，用来对数据库中表的数据记录进行增、删、改操作。</p><h2 id="3-1-添加数据"><a href="#3-1-添加数据" class="headerlink" title="3.1 添加数据"></a>3.1 添加数据</h2><p>给自定字段添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>, ...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><p>给所有字段添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><p>批量添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>, ...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), (值<br><span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...) ;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><ul><li><p><strong>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</strong></p></li><li><p>** 字符串和日期型数据应该包含在引号中。**</p></li><li><p><strong>插入的数据大小，应该在字段的规定范围内。</strong></p></li></ul></blockquote><h2 id="3-2-修改数据"><a href="#3-2-修改数据" class="headerlink" title="3.2 修改数据"></a>3.2 修改数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 字段名<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">1</span> , 字段名<span class="hljs-number">2</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">2</span> , .... [ <span class="hljs-keyword">WHERE</span> 条件 ] ;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><p>如果不加where是更新整张表</p></blockquote><h2 id="3-3-删除数据"><a href="#3-3-删除数据" class="headerlink" title="3.3 删除数据"></a>3.3 删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 [ <span class="hljs-keyword">WHERE</span> 条件 ] ;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><ul><li><p>DELETE 语句的条件可以有，也可以没有，如果<strong>没有条件，则会删除整张表的所有数据</strong>。</p></li><li><p><strong>DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。</strong></p></li></ul></blockquote><h1 id="4-DQL"><a href="#4-DQL" class="headerlink" title="4. DQL"></a>4. DQL</h1><p>DQL英文全称是Data Query Language(<strong>数据查询语言</strong>)，数据查询语言，用来查询数据库中表的记录。</p><h2 id="4-1-基本语法"><a href="#4-1-基本语法" class="headerlink" title="4.1 基本语法"></a>4.1 基本语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>字段列表<br><span class="hljs-keyword">FROM</span><br>表名列表<br><span class="hljs-keyword">WHERE</span><br>条件列表<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>分组字段列表<br><span class="hljs-keyword">HAVING</span><br>分组后条件列表<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>排序字段列表<br>LIMIT<br>分页参数<br></code></pre></td></tr></table></figure><h2 id="4-2-基础查询"><a href="#4-2-基础查询" class="headerlink" title="4.2 基础查询"></a>4.2 基础查询</h2><h3 id="4-2-1-查询多个字段"><a href="#4-2-1-查询多个字段" class="headerlink" title="4.2.1 查询多个字段"></a>4.2.1 查询多个字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, 字段<span class="hljs-number">3</span> ... <span class="hljs-keyword">FROM</span> 表名 ;<br></code></pre></td></tr></table></figure><h3 id="4-2-2-查询所有字段"><a href="#4-2-2-查询所有字段" class="headerlink" title="4.2.2 查询所有字段"></a>4.2.2 查询所有字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 ;<br></code></pre></td></tr></table></figure><blockquote><p>* 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。</p></blockquote><h3 id="4-2-3-字段设置别名"><a href="#4-2-3-字段设置别名" class="headerlink" title="4.2.3 字段设置别名"></a>4.2.3 字段设置别名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span> [ 别名<span class="hljs-number">1</span> ] , 字段<span class="hljs-number">2</span> [ 别名<span class="hljs-number">2</span> ] ... <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><h3 id="4-2-4-去除重复记录"><a href="#4-2-4-去除重复记录" class="headerlink" title="4.2.4 去除重复记录"></a>4.2.4 去除重复记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><h2 id="4-3-条件查询"><a href="#4-3-条件查询" class="headerlink" title="4.3 条件查询"></a>4.3 条件查询</h2><h3 id="4-3-1-语法"><a href="#4-3-1-语法" class="headerlink" title="4.3.1 语法"></a>4.3.1 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件列表 ;<br></code></pre></td></tr></table></figure><h3 id="4-3-2-条件"><a href="#4-3-2-条件" class="headerlink" title="4.3.2 条件"></a>4.3.2 条件</h3><p>比较运算符</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/1b1b915afa4383a28ea0bed53a359d97.png" alt="image-20230327204725050"></p><p>逻辑运算符</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/6a3686ee7574838f1d4b1cdf7bb6450b.png" alt="image-20230327204833135"></p><h2 id="4-4-聚合函数"><a href="#4-4-聚合函数" class="headerlink" title="4.4 聚合函数"></a>4.4 聚合函数</h2><p>将一列数据作为一个整体，进行纵向计算 。</p><h3 id="4-4-1-语法"><a href="#4-4-1-语法" class="headerlink" title="4.4.1 语法"></a>4.4.1 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 聚合函数(字段列表) <span class="hljs-keyword">FROM</span> 表名 ;<br></code></pre></td></tr></table></figure><blockquote><p>注意 : NULL值是不参与所有聚合函数运算的。所有聚合函数是不计算NULL值的。</p></blockquote><h3 id="4-4-2-常见的聚合函数"><a href="#4-4-2-常见的聚合函数" class="headerlink" title="4.4.2 常见的聚合函数"></a>4.4.2 常见的聚合函数</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/28f6ea865d09ad6476fa68c038511d30.png" alt="image-20230327212255154"></p><h2 id="4-5-分组查询"><a href="#4-5-分组查询" class="headerlink" title="4.5 分组查询"></a>4.5 分组查询</h2><h3 id="4-5-1-语法"><a href="#4-5-1-语法" class="headerlink" title="4.5.1 语法"></a>4.5.1 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 [ <span class="hljs-keyword">WHERE</span> 条件 ] <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 分组字段名 [ <span class="hljs-keyword">HAVING</span> 分组后过滤条件 ];<br></code></pre></td></tr></table></figure><h3 id="4-5-2-和where区别"><a href="#4-5-2-和where区别" class="headerlink" title="4.5.2 和where区别"></a>4.5.2 和where区别</h3><ul><li>执行时机不同：<strong>where是分组之前</strong>进行过滤，不满足where条件，不参与分组；而<strong>having是分组</strong> 之后对结果进行过滤。</li><li>判断条件不同：<strong>where不能对聚合函数进行判断，而having可以。</strong></li></ul><blockquote><p>注：</p><ul><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</li><li>执行顺序: where &gt; 聚合函数 &gt; having 。</li><li>支持多字段分组, 具体语法为 : group by columnA,columnB</li></ul></blockquote><h2 id="4-6-排序查询"><a href="#4-6-排序查询" class="headerlink" title="4.6 排序查询"></a>4.6 排序查询</h2><h3 id="4-6-1-语法"><a href="#4-6-1-语法" class="headerlink" title="4.6.1 语法"></a>4.6.1 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段<span class="hljs-number">1</span> 排序方式<span class="hljs-number">1</span> , 字段<span class="hljs-number">2</span> 排序方式<span class="hljs-number">2</span> ;<br></code></pre></td></tr></table></figure><h3 id="4-6-2-排序方式"><a href="#4-6-2-排序方式" class="headerlink" title="4.6.2 排序方式"></a>4.6.2 排序方式</h3><ul><li>ASC : 升序(默认值)</li><li>DESC: 降序</li></ul><blockquote><ul><li>如果是升序, 可以不指定排序方式ASC ;</li><li>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;</li></ul></blockquote><h2 id="4-7-分页查询"><a href="#4-7-分页查询" class="headerlink" title="4.7 分页查询"></a>4.7 分页查询</h2><h3 id="4-7-1-语法"><a href="#4-7-1-语法" class="headerlink" title="4.7.1 语法"></a>4.7.1 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 LIMIT 起始索引, 查询记录数 ;<br></code></pre></td></tr></table></figure><blockquote><ul><li>起始索引从0开始，起始索引 &#x3D; （查询页码 - 1）* 每页显示记录数。</li><li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</li></ul></blockquote><h2 id="4-8-执行顺序"><a href="#4-8-执行顺序" class="headerlink" title="4.8 执行顺序"></a>4.8 执行顺序</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/f0e49f238eeb7fd5e40e2199ac1ba5af.png" alt="image-20230327225347911"></p><h1 id="5-DCL"><a href="#5-DCL" class="headerlink" title="5. DCL"></a>5. DCL</h1><p>DCL英文全称是**Data Control Language(数据控制语言)**，用来管理数据库用户、控制数据库的访问权限。</p><h2 id="5-1-管理用户"><a href="#5-1-管理用户" class="headerlink" title="5.1 管理用户"></a>5.1 管理用户</h2><h3 id="5-1-1-查询用户"><a href="#5-1-1-查询用户" class="headerlink" title="5.1.1 查询用户"></a>5.1.1 查询用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mysql.user;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/236ba3cd1e6ce91a4f2fa78c891360c7.png" alt="image-20230328194940563"></p><p> <strong>Host 代表当前用户访问的主机</strong>, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的。 <strong>User 代表的是访问该数据库的用户名</strong>。在MySQL中需要通过Host和User来唯一标识一 个用户。</p><h3 id="5-1-2-创建用户"><a href="#5-1-2-创建用户" class="headerlink" title="5.1.2 创建用户"></a>5.1.2 创建用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;密码&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>% 百分号是代表任意主机！</p></blockquote><h3 id="5-1-3-修改用户密码"><a href="#5-1-3-修改用户密码" class="headerlink" title="5.1.3 修改用户密码"></a>5.1.3 修改用户密码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;新密码&#x27;</span> ;<br></code></pre></td></tr></table></figure><h3 id="5-1-4-删除用户"><a href="#5-1-4-删除用户" class="headerlink" title="5.1.4 删除用户"></a>5.1.4 删除用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span> ;<br></code></pre></td></tr></table></figure><blockquote><ul><li>在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。</li><li>主机名可以使用 % 通配。</li><li>这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库 管理员）使用。</li></ul></blockquote><h2 id="5-2-权限控制"><a href="#5-2-权限控制" class="headerlink" title="5.2 权限控制"></a>5.2 权限控制</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/MySQL/07b13ea864abf8d3ad308a53cee0c56f.png" alt="image-20230328200415175"></p><h3 id="5-2-1-查询权限"><a href="#5-2-1-查询权限" class="headerlink" title="5.2.1 查询权限"></a>5.2.1 查询权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span> ;<br></code></pre></td></tr></table></figure><h3 id="5-2-2-授予权限"><a href="#5-2-2-授予权限" class="headerlink" title="5.2.2 授予权限"></a>5.2.2 授予权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> 权限列表 <span class="hljs-keyword">ON</span> 数据库名.表名 <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="5-2-3-撤销权限"><a href="#5-2-3-撤销权限" class="headerlink" title="5.2.3 撤销权限"></a>5.2.3 撤销权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> 权限列表 <span class="hljs-keyword">ON</span> 数据库名.表名 <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><ul><li><p>多个权限之间，使用逗号分隔 。</p></li><li><p>授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</p></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC-03-共享模型之管程</title>
    <link href="/JUC-03-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B/3d1ad634835b/"/>
    <url>/JUC-03-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B/3d1ad634835b/</url>
    
    <content type="html"><![CDATA[<h1 id="1-共享带来的问题"><a href="#1-共享带来的问题" class="headerlink" title="1. 共享带来的问题"></a>1. 共享带来的问题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">999999</span>; i++) &#123;<br>                count++;<br><br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">999999</span>; i++) &#123;<br>                count--;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        System.out.println(count);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>共享资源在被两个线程使用的时候，可能会遇见线程1要对变量i&#x3D;0进行+1操作，但是在进行+1的途中cpu时间片到期，cpu切换交给了线程2，线程2也对变量i进行-1操作。然后把结果-1返回到共享变量。但是切换回线程1中的变量已经+1也就是局部变量已经是1，并且重新赋值给共享变量导致的并发问题</li><li>第二个是共享资源如果一直被一个线程使用，线程可能会由于需要sleep，wait，io等操作浪费cpu的使用时间，那么可以把这段时间让给别人。</li></ul><h2 id="1-1-分析"><a href="#1-1-分析" class="headerlink" title="1.1 分析"></a>1.1 分析</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/3844b0c79eb7eac42c534005559ac4fa.png" alt="image-20211012152027370"></p><h2 id="1-2-临界区"><a href="#1-2-临界区" class="headerlink" title="1.2 临界区"></a>1.2 临界区</h2><ul><li>实际上就是多个线程访问的代码里面有共享资源，那么这段代码就是临界区</li></ul><h2 id="1-3-竞态条件"><a href="#1-3-竞态条件" class="headerlink" title="1.3 竞态条件"></a>1.3 竞态条件</h2><ul><li>如果在临界区中多线程执行发生执行指令序列不同导致结果无法预测的状况就是竞态条件</li></ul><h1 id="2-sychronized解决方案"><a href="#2-sychronized解决方案" class="headerlink" title="2. sychronized解决方案"></a>2. sychronized解决方案</h1><p>对临界区上锁，加上sychronized，这样保证，每次只会有一个共享资源进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> Object lock=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                count++;<br>            &#125;<br><br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                count--;<br>            &#125;<br><br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>    t1.start();<br>    t2.start();<br>    t1.join();<br>    t2.join();<br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,count);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="3-方法上的synchronized"><a href="#3-方法上的synchronized" class="headerlink" title="3. 方法上的synchronized"></a>3. 方法上的synchronized</h1><h2 id="3-1-加在成员方法上"><a href="#3-1-加在成员方法上" class="headerlink" title="3.1 加在成员方法上"></a>3.1 加在成员方法上</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-comment">//在方法上加上synchronized关键字</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-加在静态方法上"><a href="#3-2-加在静态方法上" class="headerlink" title="3.2 加在静态方法上"></a>3.2 加在静态方法上</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-comment">//在静态方法上加上synchronized关键字</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span>(Demo.class) &#123;<br><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>经典的<a href="https://blog.csdn.net/weixin_53029342/article/details/128664737?ops_request_misc=&request_id=&biz_id=102&utm_term=%E7%BA%BF%E7%A8%8B8%E9%94%81&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-128664737.142%5Ev100%5Epc_search_result_base5&spm=1018.2226.3001.4187">线程八锁问题</a></p></blockquote><h1 id="4-变量的线程安全分析"><a href="#4-变量的线程安全分析" class="headerlink" title="4. 变量的线程安全分析"></a>4. 变量的线程安全分析</h1><h2 id="4-1-静态变量和成员变量是否有线程安全问题"><a href="#4-1-静态变量和成员变量是否有线程安全问题" class="headerlink" title="4.1 静态变量和成员变量是否有线程安全问题"></a>4.1 静态变量和成员变量是否有线程安全问题</h2><p>如果只是对静态变量和成员变量进行读操作，是没有现成安全问题的。</p><p>但是只要有写操作，就需要看临界区，大概率会出现线程安全问题。</p><h2 id="4-2-局部变量"><a href="#4-2-局部变量" class="headerlink" title="4.2 局部变量"></a>4.2 局部变量</h2><p>如果是引用类型的话那么就有。</p><p>局部变量的值存储在线程的栈帧里面，也就是私有的。而不是像static变量那样先从方法区中取出这个变量然后再进行对应的修改。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/e290cdb3faa7e7f775bb7c61abe1f215.png" alt="image-20211012161844837"></p><blockquote><p>即：每个线程会创建自己的栈帧，在每个栈帧里面，都有一份局部变量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThreadSafe</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THREAD_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LOOP_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        ThreadSafeSubClass test = new ThreadSafeSubClass();</span><br>        ThreadUnsafe test=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadUnsafe</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                test.method1(LOOP_NUMBER);<br>            &#125;, <span class="hljs-string">&quot;Thread&quot;</span> + (i+<span class="hljs-number">1</span>)).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 由于list是在该类创建的，每个线程都是对这个list进行共享，因此会出现线程安全问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadUnsafe</span> &#123;<br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2();<br>            method3();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// list是在调用方法method1时候创建的，属于方法中的局部变量，那么每个线程进入method1的时候都会创建一个list，因此不会出现线程安全问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        System.out.println(<span class="hljs-number">1</span>);<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 由于子类采用继承的方式重写了method3，此时list会被多个线程操作，会出现线程安全问题。解决办法就是给方法加上final防止子类重写。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadSafe</span>&#123;<br><span class="hljs-comment">//    @Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> &#123;<br>        System.out.println(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            list.remove(<span class="hljs-number">0</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析</p><ol><li><p>对于第一种使用ThreadUnsafe类的方式，图解：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/image-20240425215800329.png" alt="image-20240425215800329"></p><p>此时所有的线程的list应用都指向了堆区中的那唯一一个list对象，因此list对象就是一个共享资源。</p></li><li><p>对于第二种使用ThreadSafe类的方式，图解：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/image-20240425215936544.png" alt="image-20240425215936544"></p><p>每个线程运行method1方法都是new list，这样list就是局部变量，没有共享。同时使用传参的方式，那么在同一个线程中的method2和method3使用的都是同一个list对象</p></li><li><p>对于使用ThreadSafeSubClass，此时虽然List是局部变量，但是由于重写了method3，在method3中新创建了一个线程去操作这个list，原本这个List由最外层的线程创建，那么此时list就是一个共享资源，会引发线程安全问题</p></li></ol><h2 id="4-3-线程安全类"><a href="#4-3-线程安全类" class="headerlink" title="4.3 线程安全类"></a>4.3 线程安全类</h2><ul><li>Integer</li><li>HashTable</li><li>String</li><li>Random</li><li>Vector</li><li>JUC下的类</li></ul><p>它们单个方法是线程安全的，但是如果多个方法执行的时候就不一样了。</p><p>同时不可变类线程安全（String、Integer），String和Integer都是不可变的，String本质上就是一个char[]数组。如果是substring方法实际上就是复制一个新的数组出来，然后再给String的char数组进行赋值。replace也实际上只是创建数组，然后对比原数组的旧值，如果是旧值那么直接给新的数组的那个位置赋值新值</p><h1 id="5-Monitor"><a href="#5-Monitor" class="headerlink" title="5. Monitor"></a>5. Monitor</h1><h2 id="5-1-Java对象头"><a href="#5-1-Java对象头" class="headerlink" title="5.1 Java对象头"></a>5.1 Java对象头</h2><p>包括了markword主要就是存储hashcode，age（gc生命值），biase_lock是不是偏向锁，01加锁的情况</p><p>还有就是klassword只要就是指向类对象（类的信息）。</p><p>如果是数组那么就还包括了数组的长度。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/image-20240427092856254.png" alt="image-20240427092856254"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/image-20240427092918408.png" alt="image-20240427092918408"></p><h2 id="5-2-Monitor锁"><a href="#5-2-Monitor锁" class="headerlink" title="5.2 Monitor锁"></a>5.2 Monitor锁</h2><p>monitor锁是由操作系统提供的。</p><h3 id="5-2-1-原理"><a href="#5-2-1-原理" class="headerlink" title="5.2.1 原理"></a>5.2.1 原理</h3><p>Mark Word占32bit，实际上就是把obj的markword前面30bit记录monitor的地址，指向monitor。</p><p>如果有线程要执行临时区的时候那么就把monitor的owner指向对应的线程。</p><p>如果又有线程进来，那么会看看obj是否关联锁，然后再看看锁是否有owner，如果有那么就进入到EntryList阻塞等待。等待线程释放锁之后，唤醒entryList然后重新开始竞争。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/850e43d3299bbe2af12d7f5b631c6089.png" alt="image-20211012190808458"></p><h3 id="5-2-2-字节码角度"><a href="#5-2-2-字节码角度" class="headerlink" title="5.2.2 字节码角度"></a>5.2.2 字节码角度</h3><p>就是先把lock的引用复制放到slot1，然后就是monitorenter，把lock的markword指向monitor，并且把hashcode等存入monitor。接着执行业务代码，最后就是取出引用slot1，然后就是monitorexit，解锁。而且对业务代码也就是同步块进行了异常监视，如果出现异常，那么还是会进行解锁操作的。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/b66f6722ef869522a8adf07a314e300e.png" alt="image-20211012191838416"></p><h1 id="6-synchronized优化"><a href="#6-synchronized优化" class="headerlink" title="6. synchronized优化"></a>6. synchronized优化</h1><p>偏向锁是单个线程专属的，如果单个线程处理某个代码没有竞争，那么就可以使用偏向锁，如果有竞争那么就可以升级为轻量级锁。</p><h2 id="6-1-轻量级锁"><a href="#6-1-轻量级锁" class="headerlink" title="6.1 轻量级锁"></a>6.1 轻量级锁</h2><p>本质就是线程的调用临时区方法的栈帧的锁记录保存对象的引用和对象markword的信息。</p><p>接着就是把<strong>对应锁记录的锁信息与obj进行交换</strong>，比如说把01改成了00告诉obj这是一个轻量级锁，而且告诉了obj锁记录的地址，相当于就是给obj贴上是谁的锁的标签。如果是可重入锁，那么锁记录markword部分就是null表示的是这是可重入的，用的是同一个锁。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/b4e4c1610eea3dbeda5bba37aac1c5c8.png" alt="image-20211012194226364"></p><h2 id="6-2-锁膨胀"><a href="#6-2-锁膨胀" class="headerlink" title="6.2 锁膨胀"></a>6.2 锁膨胀</h2><ul><li>其实就是竞争轻量级锁的时候，没有地方给竞争的线程放着，那么这个时候就需要把轻量锁转换成重量级锁monitor，其实就是把obj的markword指向monitor。然后就是monitor的owner指向当前线程的锁记录。把阻塞线程放到等待队列里面。</li><li>恢复的时候，CAS尝试把线程的锁记录给恢复过去，但是发现失败。这个时候恢复方式改成了重量级锁的恢复方式，唤醒list，然后owner设置为null，线程重新竞争monitor。如果没有就把monitor保存的hashcode信息恢复。</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/7895c9c7e3709732dd9a445154519c3a.png" alt="image-20211012195850961"></p><h2 id="6-3-自旋优化"><a href="#6-3-自旋优化" class="headerlink" title="6.3 自旋优化"></a>6.3 自旋优化</h2><ul><li>自旋就是旋多一会等等别人释放重量级锁，如果成功一次，那么下次就会确定成功几率加大，自旋多几次。如果没有等到那么就阻塞。</li><li>自旋的原因：阻塞会导致线程的上下文切换需要消耗cpu时间和资源。速度相对比较慢。</li></ul><h2 id="6-4-偏向锁"><a href="#6-4-偏向锁" class="headerlink" title="6.4 偏向锁"></a>6.4 偏向锁</h2><p>之所以要用偏向锁是因为轻量级锁的锁重入每次都调用CAS进行对比，CAS是一个OS指令操作，速度很慢。所以偏向锁是把ThreadId直接赋值给markword，那么下次能直接在java上对比这个markword。</p><ul><li>偏向锁带有延迟性，通常对象创建过一会才会生成</li><li>生成偏向锁-&gt;轻量级锁-&gt;重量级锁</li><li>如果给临时区使用偏向锁，那么对应执行线程的id赋值给markword</li><li>如果使用了锁的hashcode，那么偏向锁就会被禁止，因为hashcode占用的bit太多。</li><li>轻量级在锁记录上记录hashcode，重量级在monitor上记录</li><li>如果两个线程用同一个偏向级锁，那么锁会变成不可偏向，升级为轻量级锁。</li></ul><h3 id="6-4-1-批量重偏向"><a href="#6-4-1-批量重偏向" class="headerlink" title="6.4.1 批量重偏向"></a>6.4.1 批量重偏向</h3><p>其实就是多个没有竞争的线程，使用同一个锁，如果jvm发现撤销的偏向次数超过20次，那么就会自动偏向另外一个线程。比如t1线程使用一堆锁，锁偏向t1。但是如果t2使用这些锁，并且需要撤销锁的偏向超过20次，那么这些锁会全部偏向t2</p><h3 id="6-4-2-批量撤销"><a href="#6-4-2-批量撤销" class="headerlink" title="6.4.2 批量撤销"></a>6.4.2 批量撤销</h3><p>如果撤销超过40次那么jvm就会撤销所有对象的偏向</p><h2 id="6-5-锁消除"><a href="#6-5-锁消除" class="headerlink" title="6.5 锁消除"></a>6.5 锁消除</h2><p>在JVM中有一个即时编译器(JIT)发现锁的临界区里面根本就没有共享资源，那么就取消了这个锁。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/1e2c8538418dd6f29631b7a11a418dbf.png" alt="image-20211012210126414"></p><h1 id="7-wait-notify"><a href="#7-wait-notify" class="headerlink" title="7. wait&#x2F;notify"></a>7. wait&#x2F;notify</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/image-20240427133739558.png" alt="image-20240427133739558"></p><ul><li>Owner线程发现条件不满足，调用wait方法，即可进入WaitSet3变为WAITING状态</li><li>BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU时间片</li><li>BLOCKED线程会在Owner线程释放锁时唤醒</li><li>WAITING线程会在Owner线程调用notify或notifyAll时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入<br>EntryList重新竞争</li></ul><h2 id="7-1-API介绍"><a href="#7-1-API介绍" class="headerlink" title="7.1 API介绍"></a>7.1 API介绍</h2><ul><li><code>obj.wait()</code>：让进入object监视器的线程到waitSet等待</li><li><code>obj.notify()</code>：让object上正在waitSet等待的线程中随机挑选一个唤醒</li><li><code>obj.notifyAll()</code>：让object上正在waiteSet的所有等待的线程被唤醒</li></ul><h1 id="8-wait-notify正确使用"><a href="#8-wait-notify正确使用" class="headerlink" title="8. wait&#x2F;notify正确使用"></a>8. wait&#x2F;notify正确使用</h1><h2 id="8-1-sleep和wait区别"><a href="#8-1-sleep和wait区别" class="headerlink" title="8.1 sleep和wait区别"></a>8.1 sleep和wait区别</h2><ol><li>sleep是Thread的静态方法，wait是Object的方法。</li><li>sleep不需要强制和synchronized配合使用，但是wait需要和synchronized一起使用。</li><li>sleep不会释放对象锁，wait在等待的时候会释放对象锁。</li><li>不管调用sleep或者wait，当前线程都会进入TIMED_WAITING状态。</li></ol><h2 id="8-2-正确使用"><a href="#8-2-正确使用" class="headerlink" title="8.2 正确使用"></a>8.2 正确使用</h2><p>case升级过程建议观看<a href="https://www.bilibili.com/video/BV16J411h7Rd?p=93&vd_source=0450c732ee6a231d11d13ee9774e4b7f">视频</a></p><p>总结：</p><blockquote><p>可以通过while多次判断条件是否成立，直接使用notifyAll来唤醒所有的线程。然后线程被唤醒之后先再次判断条件是否成立，成立那么往下面执行，如果不成立那么继续执行wait。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>  <span class="hljs-keyword">while</span>(条件不成立) &#123;<br>    lock.wait();<br>  &#125;<br>  <span class="hljs-comment">// 条件成立</span><br>  doSth();<br>&#125;<br><br><span class="hljs-comment">//其他线程</span><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>  lock.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h1 id="9-生产者消费者"><a href="#9-生产者消费者" class="headerlink" title="9. 生产者消费者"></a>9. 生产者消费者</h1><h1 id="10-park-unPark"><a href="#10-park-unPark" class="headerlink" title="10. park&#x2F;unPark"></a>10. park&#x2F;unPark</h1><h1 id="11-线程状态转换"><a href="#11-线程状态转换" class="headerlink" title="11. 线程状态转换"></a>11. 线程状态转换</h1><h1 id="12-多把锁"><a href="#12-多把锁" class="headerlink" title="12. 多把锁"></a>12. 多把锁</h1><h1 id="13-活跃性"><a href="#13-活跃性" class="headerlink" title="13. 活跃性"></a>13. 活跃性</h1><h1 id="14-ReentrantLock"><a href="#14-ReentrantLock" class="headerlink" title="14. ReentrantLock"></a>14. ReentrantLock</h1>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC-02-Java线程</title>
    <link href="/JUC-02-Java%E7%BA%BF%E7%A8%8B/6f24c74f93c5/"/>
    <url>/JUC-02-Java%E7%BA%BF%E7%A8%8B/6f24c74f93c5/</url>
    
    <content type="html"><![CDATA[<h1 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1. 创建线程"></a>1. 创建线程</h1><h2 id="1-1-直接使用Thread"><a href="#1-1-直接使用Thread" class="headerlink" title="1.1 直接使用Thread"></a>1.1 直接使用Thread</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造方法的参数是给线程指定名字，，推荐给线程起个名字</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-comment">// run 方法内实现了要执行的任务</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br> log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br> &#125;<br> &#125;;<br>t1.start();<br></code></pre></td></tr></table></figure><h2 id="1-2-Runnable-Thread"><a href="#1-2-Runnable-Thread" class="headerlink" title="1.2 Runnable+Thread"></a>1.2 Runnable+Thread</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建一个实现 Runnable 接口的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">// 2.实现 Runnable 的抽象 run() 方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) System.out.println(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3.创建实现了 Runnable 的类的对象</span><br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-comment">// 4.把此对象作为参数放入 Thread 类的构造器，从而创建 Thread 类的对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable);<br>        <span class="hljs-comment">// 5.调用 Thread 类的对象的 start() 方法</span><br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于继承 Thread 类的方式，用实现 Runnable 接口的方式更好。</p><ol><li>Java 是单继承多实现，继承了 Thread 就不能继承别的类了（那岂不是所有自己写的子类都没法用于多线程了吗？），但实现了 Runnable 却可以同时实现别的接口。</li><li>用一个 Runnable 实现类的对象就可以创建多个线程（这些线程共享这个对象），因而可以很方便地让多个线程共享数据（各个线程共享同一个 Runnable 类型的对象）。</li></ol><h2 id="1-3-Callable-Thread"><a href="#1-3-Callable-Thread" class="headerlink" title="1.3 Callable+Thread"></a>1.3 Callable+Thread</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建一个实现 Callable 接口的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-comment">// 2.实现 Callable 的抽象 call() 方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <span class="hljs-comment">// Callable 的 call() 方法可以抛出异常</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) sum += i;<br>        <span class="hljs-keyword">return</span> sum;  <span class="hljs-comment">// Callable 的 call() 方法可以有返回值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3.创建实现了 Callable 的类的对象</span><br>        <span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>        <span class="hljs-comment">// 4.把此对象作为参数放入 FutureTask 类的构造器，从而创建 FutureTask 类的对象</span><br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(myCallable);<br>        <span class="hljs-comment">// 5.把 FutureTask 类的对象作为参数放入 Thread 类的构造器，从而创建 Thread 类的对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        <span class="hljs-comment">// 6.调用 Thread 类的对象的 start() 方法</span><br>        thread.start();<br>        <span class="hljs-comment">// 7.调用 FutureTask 类的对象的 get() 方法，以获取线程的返回值（如果不需要返回值则不需要这一步）</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">sumObject</span> <span class="hljs-operator">=</span> futureTask.get();  <span class="hljs-comment">// 获取线程的返回值</span><br>            System.out.println(sumObject);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Callable</code> 与 <code>Runnable</code> 的主要区别：<ul><li><code>Callable</code> 的 <code>call()</code> 方法可以有返回值。</li><li><code>Callable</code> 的 <code>call()</code> 方法可以抛异常。</li><li><code>Callable</code> 支持泛型。</li></ul></li></ul><h2 id="1-4-线程池创建线程"><a href="#1-4-线程池创建线程" class="headerlink" title="1.4 线程池创建线程"></a>1.4 线程池创建线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建一个实现 Runnable 接口的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">// 2.实现 Runnable 的抽象 run() 方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) System.out.println(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3.创建 ExecutorService 类的对象（创建线程池）</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 固定线程数量的线程池</span><br>        <span class="hljs-comment">// 4.创建实现了 Runnable 的类的对象</span><br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-comment">// 5.把实现了 Runnable 的类的对象作为参数放入 ExecutorService 类的对象的 execute() 方法</span><br>        executorService.execute(myRunnable);  <span class="hljs-comment">// Runnable 用 execute() 方法，Callable 用 submit() 方法</span><br>        <span class="hljs-comment">// 6.关闭线程池</span><br>        executorService.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实际上创建线程的方式只有一种：</p><p><strong>new 一个 Thread 对象，并给它一个 Runnable 类型的对象</strong></p><p><strong>Thread 对象负责启动线程，Runnable 对象负责执行线程</strong></p></blockquote><h1 id="2-查看进程线程方法"><a href="#2-查看进程线程方法" class="headerlink" title="2. 查看进程线程方法"></a>2. 查看进程线程方法</h1><p>在linux下：</p><ul><li><code>ps -fe</code> 查看所有进程</li><li><code>ps -fT -p &lt;PID&gt; </code>查看某个进程（PID）的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>top</code> 按大写 H 切换是否显示线程</li><li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li></ul><h1 id="3-线程运行原理"><a href="#3-线程运行原理" class="headerlink" title="3. 线程运行原理"></a>3. 线程运行原理</h1><h2 id="3-1-栈与栈帧"><a href="#3-1-栈与栈帧" class="headerlink" title="3.1 栈与栈帧"></a>3.1 栈与栈帧</h2><ol><li>每个线程启动后，虚拟机就会为其分配一块栈内存。</li><li>每个方法被执行的时候都会同时创建一个栈帧(stack frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，是属于线程的私有的。</li><li>当java中使用多线程时，每个线程都会维护它自己的栈，每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</li></ol><h2 id="3-2-线程上下文切换"><a href="#3-2-线程上下文切换" class="headerlink" title="3.2 线程上下文切换"></a>3.2 线程上下文切换</h2><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ol><li><p>线程的 cpu 时间片用完</p></li><li><p>垃圾回收</p></li><li><p>有更高优先级的线程需要运行</p></li><li><p>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</p></li></ol><blockquote><p>当上下文切换发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器，它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul></blockquote><h1 id="5-常见方法"><a href="#5-常见方法" class="headerlink" title="5. 常见方法"></a>5. 常见方法</h1><h2 id="5-1-start-run"><a href="#5-1-start-run" class="headerlink" title="5.1 start&#x2F;run"></a>5.1 start&#x2F;run</h2><ul><li>直接调用 run 是在主线程中执行了 run，没有启动新的线程</li><li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li></ul><h2 id="5-2-sleep"><a href="#5-2-sleep" class="headerlink" title="5.2 sleep"></a>5.2 sleep</h2><ol><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li><li>睡眠结束后的线程未必会立刻得到执行</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ol><h2 id="5-3-yeild"><a href="#5-3-yeild" class="headerlink" title="5.3 yeild"></a>5.3 yeild</h2><ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h2 id="5-4-join"><a href="#5-4-join" class="headerlink" title="5.4 join"></a>5.4 join</h2><ol><li>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</li><li>如在主线程中调用ti.join()，则是主线程等待t1线程结束</li></ol><h2 id="5-5-interrupt"><a href="#5-5-interrupt" class="headerlink" title="5.5 interrupt"></a>5.5 interrupt</h2><ol><li>用于打断阻塞(sleep wait join)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片。</li><li>如果一个线程在在运行中被打断，打断标记会被置为true。线程不会停止，会继续执行。如果要让线程在被打断后停下来，需要使用打断标记来判断。</li><li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false。线程抛出异常InterruptedException。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test7</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Monitor</span> <span class="hljs-variable">monitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Monitor</span>();<br>        monitor.start();<br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        monitor.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monitor</span> &#123;<br><br>    Thread monitor;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>        monitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">//开始不停的监控</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">//判断当前线程是否被打断了</span><br>                <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>                    log.info(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                    <span class="hljs-comment">//终止线程执行</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                log.info(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//线程休眠</span><br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    <span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span><br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于停止监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//打断线程</span><br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-6-线程优先级"><a href="#5-6-线程优先级" class="headerlink" title="5.6 线程优先级"></a>5.6 线程优先级</h2><ol><li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; log.info(<span class="hljs-string">&quot;thread run&quot;</span>));<br>thread.setPriority();<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The minimum priority that a thread can have.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The default priority that is assigned to a thread.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORM_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The maximum priority that a thread can have.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h1 id="10-sleep-yield-wait-join区别"><a href="#10-sleep-yield-wait-join区别" class="headerlink" title="10. sleep&#x2F;yield&#x2F;wait&#x2F;join区别"></a>10. sleep&#x2F;yield&#x2F;wait&#x2F;join区别</h1><ol><li>sleep，join，yield，interrupted是Thread类中的方法</li><li>wait&#x2F;notify是object中的方法</li><li>sleep 不释放锁、释放cpu</li><li>join 释放锁、join的线程抢占cpu，如t1.join(), t1抢占cpu</li><li>yield 不释放锁、释放cpu</li><li>wait 释放锁、释放cpu</li></ol><h1 id="11-主线程-守护线程"><a href="#11-主线程-守护线程" class="headerlink" title="11. 主线程&#x2F;守护线程"></a>11. 主线程&#x2F;守护线程</h1><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><blockquote><p>注意<br>垃圾回收器线程就是一种守护线程</p></blockquote><h1 id="12-操作系统线程五种状态"><a href="#12-操作系统线程五种状态" class="headerlink" title="12. 操作系统线程五种状态"></a>12. 操作系统线程五种状态</h1><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态<ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li>【阻塞状态】<ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h1 id="13-java线程六种状态"><a href="#13-java线程六种状态" class="headerlink" title="13. java线程六种状态"></a>13. java线程六种状态</h1><p>这是从 Java API 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p><ul><li>NEW 线程刚被创建，但是还没有调用 start() 方法</li><li>RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li><li>BLOCKED， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分。</li><li>TERMINATED 当线程代码运行结束</li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC-01-进程与线程</title>
    <link href="/JUC-01-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1825fe04ebc7/"/>
    <url>/JUC-01-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1825fe04ebc7/</url>
    
    <content type="html"><![CDATA[<h1 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h1><ol><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在<br>指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器<br>等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ol><h1 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h1><ol><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li></ol><h1 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h1><ol><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集。</li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享。</li><li>进程间通信较为复杂</li><li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP。</li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量。</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低。</li></ol><h1 id="4-并发"><a href="#4-并发" class="headerlink" title="4. 并发"></a>4. 并发</h1><p>在单核cpu下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是同时运行的。 一般会将这种线程轮流使用 CPU 的做法称为并发(concurrent)</p><h1 id="5-并行"><a href="#5-并行" class="headerlink" title="5. 并行"></a>5. 并行</h1><p>多核cpu下，每个核都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring基础知识-事务</title>
    <link href="/spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%BA%8B%E5%8A%A1/2ff047cb81fb/"/>
    <url>/spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%BA%8B%E5%8A%A1/2ff047cb81fb/</url>
    
    <content type="html"><![CDATA[<h1 id="1-事务"><a href="#1-事务" class="headerlink" title="1 事务"></a>1 事务</h1><ol><li><p>事务是数据库操作最基本单位，要么都成功，要么都失败。</p></li><li><p>事务四个特性ACID：原子性，一致性，隔离性，持久性。</p></li><li><p>Spring事务管理有两种方式：编程式事务管理 和 声明式事务管理，一般使用声明式事务管理，底层使用AOP原理。</p></li><li><p>声明式事务管理有两种方式：基于xml配置方式 和 基于注解方式，一般使用注解方式。</p></li><li><p>Spring事务管理提供了一个接口，叫做事务管理器，这个接口针对不同的框架提供不同的实现类。</p></li><li><p>在service类上面或者service类的方法上面添加事务注解<code>@Transactional</code></p></li><li><p>如果把<code>@Transactional</code>添加在类上面，这个类里面所有方法都添加事务。</p></li><li><p>如果只是添加在方法上面，则只为这个方法添加事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><ol><li><p>propagation：事务传播行为，总共有7种。</p></li><li><p>isolation：事务隔离级别</p><blockquote><p>有三个读问题：脏读，不可重复读，虚读（幻读）。</p><p>设置隔离级别，解决读问题：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/image-20240414125344168.png" alt="image-20240414125344168"></p></blockquote></li><li><p>timeout：超时时间</p><ul><li>事务需要在一定时间内进行提交，超过时间后回滚。</li><li>默认值是-1，设置时间以秒为单位。</li></ul></li><li><p>readOnly：是否只读</p><ul><li>默认值为false，表示可以查询，也可以增删改。</li><li>设置为true，只能查询。</li></ul></li><li><p>rollbackFor：回滚，设置出现哪些异常进行事务回滚。</p></li><li><p>noRollbackFor：不回滚，设置出现哪些异常不进行事务回滚。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.READ_COMMITTED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountService</span> &#123;<br></code></pre></td></tr></table></figure><h2 id="完全注解实现声明式事务管理"><a href="#完全注解实现声明式事务管理" class="headerlink" title="完全注解实现声明式事务管理"></a>完全注解实现声明式事务管理</h2><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//配置类</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.oymn.spring5&quot;)</span>  <span class="hljs-comment">//开启组件扫描</span><br><span class="hljs-meta">@EnableTransactionManagement</span>  <span class="hljs-comment">//开启事务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br><br>    <span class="hljs-comment">//创建数据库连接池</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title function_">getDruidDataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">druidDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        druidDataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        druidDataSource.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/book&quot;</span>);<br>        druidDataSource.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        druidDataSource.setPassword(<span class="hljs-string">&quot;000000&quot;</span>);<br>        <span class="hljs-keyword">return</span> druidDataSource;<br>    &#125;<br>    <span class="hljs-comment">//创建JdbcTemplate对象</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title function_">getJdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span>&#123;<br>        <span class="hljs-type">JdbcTemplate</span> <span class="hljs-variable">jdbcTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>();<br>        jdbcTemplate.setDataSource(dataSource);<br>        <span class="hljs-keyword">return</span> jdbcTemplate;<br>    &#125;<br>    <span class="hljs-comment">//创建事务管理器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSourceTransactionManager <span class="hljs-title function_">getDataSourceTransactionManager</span><span class="hljs-params">(DataSource dataSource)</span>&#123;<br>        <span class="hljs-type">DataSourceTransactionManager</span> <span class="hljs-variable">transactionManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>();<br>        transactionManager.setDataSource(dataSource);<br>        <span class="hljs-keyword">return</span> transactionManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>service类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountDao accountDao;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accountMoney</span><span class="hljs-params">()</span>&#123;<br>        accountDao.add();<br>        <span class="hljs-comment">//int i=1/0;   //用来模拟转账失败</span><br>        accountDao.reduce();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p>在spring中一共有7中传播行为，REQUIRED、NESTED、REQUIRES_NEW常用</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">REQUIRED：如果当前没有事务，就新建一个事务。如果当前存在事务，则加入这个事务。 <br><span class="hljs-code"> </span><br>NESTED：如果当前没有事务，就新建一个事务。如果当前事务存在，则执行一个嵌套事务。<br><span class="hljs-code"> </span><br>REQUIRES<span class="hljs-emphasis">_NEW：如果当前没有事务，就新建一个事务。如果当前存在事务，把当前事务挂起，并且自己创建一个新的事务给自己使用。 </span><br><span class="hljs-emphasis"> </span><br><span class="hljs-emphasis">SUPPORTS：如果当前没有事务，就以非事务方式执行。 如果当前有事务，则使用事务。</span><br><span class="hljs-emphasis"> </span><br><span class="hljs-emphasis">NOT_</span>SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br><span class="hljs-code"> </span><br>MANDATORY：以事务方式执行，如果当前没有事务，就抛出异常。 <br><span class="hljs-code"> </span><br>NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 <br></code></pre></td></tr></table></figure><h3 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h3><p>有个注册业务，注册时需要记录登录账号、密码、身份证号、姓名、手机号这5个信息，涉及三张表，分别是<strong>t_user_account、t_user_idcard、t_user_phone</strong>，刚开始的业务要求这些都不能为空，如果其中一个发生异常，那么其余已经插入的全部回滚（这些异常是我用作数据校验时抛出的，正常生产上会先进行数据校验，校验成功了再更改数据库，我这里为了演示@Transactional的回滚效果，先更改数据，如果校验不通过，便会通过spring的事务进行回滚）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserVO</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String userAccount;<br>    <span class="hljs-keyword">private</span> String userPwd;<br>    <span class="hljs-keyword">private</span> String phoneNum;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String IDCard;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userVO</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(UserVO userVO)</span> &#123;<br>        userService.insertId(userVO);<br>        <span class="hljs-keyword">try</span> &#123;<br>            userService.register(userVO);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-comment">//插入新用户的id</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertId</span><span class="hljs-params">(UserVO userVO)</span>;<br>    <span class="hljs-comment">//插入用户账号、密码、手机号、姓名、身份证号</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(UserVO userVO)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertId</span><span class="hljs-params">(UserVO userVO)</span> &#123;<br> <br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into t_user_account (user_id) values (?)&quot;</span>;<br>        jdbcTemplate.update(sql1,userVO.getId());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into t_user_idcard (user_id) values (?)&quot;</span>;<br>        jdbcTemplate.update(sql2,userVO.getId());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into t_user_phone (user_id) values (?)&quot;</span>;<br>        jdbcTemplate.update(sql3,userVO.getId());<br>    &#125;<br> <br>    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(UserVO userVO)</span> &#123;<br>        <span class="hljs-comment">//插入账号密码</span><br>        userDao.insertAccountAndPwd(userVO);<br>        <span class="hljs-comment">//再插入手机号</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update t_user_phone set phone_num = ? where user_id = ?&quot;</span>;<br>        jdbcTemplate.update(sql1,userVO.getPhoneNum(),userVO.getId());<br>        <span class="hljs-keyword">if</span> (userVO.getPhoneNum() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;手机号码不能为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//插入身份证号和姓名</span><br>        userDao.insertIDcardAndName(userVO);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：这里选择抛出的是RuntimeException，该异常是运行时异常，如果不做异常回滚的配置，默认非运行时异常（比如我刚开始抛出的是Exception），则不会发生回滚。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-comment">//插入账户和密码</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertAccountAndPwd</span><span class="hljs-params">(UserVO userVO)</span>;<br> <br>    <span class="hljs-comment">//插入身份证号和姓名</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertIDcardAndName</span><span class="hljs-params">(UserVO userVO)</span>;<br> <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br> <br>    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertAccountAndPwd</span><span class="hljs-params">(UserVO userVO)</span> &#123;<br> <br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update t_user_account set user_account = ?, user_pwd = ? where user_id = ?&quot;</span>;<br>        jdbcTemplate.update(sql1,userVO.getUserAccount(),userVO.getUserPwd(),userVO.getId());<br>        <span class="hljs-keyword">if</span> (userVO.getUserAccount() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;账号不能为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (userVO.getUserPwd() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;密码不能为空&quot;</span>);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertIDcardAndName</span><span class="hljs-params">(UserVO userVO)</span> &#123;<br>        <span class="hljs-comment">//先将新用户的身份证号和姓名插入</span><br> <br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update t_user_idcard set ID_card = ?, user_name = ? where user_id = ?&quot;</span>;<br>        jdbcTemplate.update(sql1,userVO.getIDCard(),userVO.getUserName(),userVO.getId());<br>        <span class="hljs-keyword">if</span> (userVO.getIDCard() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;身份证号不能为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (userVO.getUserName() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;姓名不能为空&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringJUnitConfig(locations = &quot;classpath:txSpreadBean.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestTxSpread</span> &#123;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserController userController;<br> <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UserVO</span> <span class="hljs-variable">userVO1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserVO</span>(<span class="hljs-number">1L</span>,<span class="hljs-string">&quot;花花&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;花木兰&quot;</span>,<span class="hljs-string">&quot;511387197807180001&quot;</span>);<br>        userController.register(userVO1);<br> <br>        <span class="hljs-type">UserVO</span> <span class="hljs-variable">userVO2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserVO</span>(<span class="hljs-number">2L</span>,<span class="hljs-string">&quot;花花&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>,<span class="hljs-string">&quot;13612312345&quot;</span>,<span class="hljs-string">&quot;花木兰&quot;</span>,<span class="hljs-literal">null</span>);<br>        userController.register(userVO2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在该示例中涉及事务传播行为要点的是UserServiceImpl的register方法。</p><p>register方法：是外围方法，除了调用了insertAccountAndPwd方法和insertIDcardAndName方法外，直接调用jdbcTemplate进行手机号的插入。</p><p>insertAccountAndPwd方法：是内围方法，进行账号密码的插入。</p><p>insertIDcardAndName方法：是内围方法，进行身份证号、姓名的插入。</p></blockquote><h4 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h4><p>我们要实现登录账号、密码、手机号、身份证号、姓名，这些都不能为空，<strong>如果其中一个发生异常，那么其余已经插入的全部回滚。</strong></p><p>根据这个业务及我们当前代码结构，我们需要在这一个外围方法和两个内围方法中都添加@Transactional注解，因为要求有异常，只要有数据库改动的代码全部回滚。</p><p><strong>传播行为选择</strong></p><blockquote><p>将<code>@Transactional</code>的事务传播属性propagation值设为<code>Propagation.REQUIRED</code></p><p>这个值是默认的，它的含义是：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。</p><p>这正好符合我们业务需求：外围方法已经是一个事务后，被调用的两个内围方法也加入到这个事务中，就实现了只要有任意一个异常，只会插入一个id，其余需要插入的登录账号、密码、手机号、身份证号、姓名都回滚。</p></blockquote><p>测试：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/521ab1ee8e694e4d9fd1a41ce37dc036.png" alt="img"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/599b446f0ad0440a9ed20ebaa3d90260.png" alt="img"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/db7df0bd3fb8405d8d6fe9d6c856976a.png" alt="img"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/7b8e1b5dd2b0404284df697e248c4afe.png" alt="img"></p><blockquote><p>可以看见：只要一个方法内有异常，这三个方法都会回滚，数据库里没有一个表中有新记录。</p></blockquote><h4 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h4><p>业务逻辑改为注册时可以不提交身份证号与姓名（但是身份证号和姓名必须同时添加或不添加），后续确定后再提交即可，账号密码和手机号仍然不可缺少，少一个则全部回滚。</p><p>那么这里我们仍保持内围方法insertIDcardAndName方法为事务，外围方法register和内围方法insertAccountAndPwd也为事务，但是要保证insertIDcardAndName方法出现异常时不能导致外围方法回滚。</p><p>导致外围回滚有两种途径，一个是内围方法出现异常后会抛出给外围方法，然后外围方法的@Transactional感知到异常回滚，另一个是外围方法与内围方法本事是一个事务，那么内围方法回滚的时候自然会使外围方法也会滚。</p><p><strong>传播行为选择</strong></p><p>首先要在外围方法中将内围方法insertIDcardAndName的异常捕获，<strong>不能再使用REQUIRED为事务传播属性了</strong>，因为内围方法事务传播属性为REQUIRED代表加入到外围方法的事务中，会同时回滚。将@Transactional的事务传播属性propagation值设为<strong>Propagation.NESTED</strong>，它的含义是：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，就新建一个事务。这正好符合我们业务需求：外围方法是一个事务的情况下，我们的内围方法有异常只需要回滚自己就行，外围方法有异常才回滚全部。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/4feb68dcda764293b540821b3881ed02.png" alt="img"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/a62d73850cb34503b124652f27eb4159.png" alt="img"></p><p>测试：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/9fdf991c5a914488b6f10896be7e30d9.png" alt="img"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/1f3ef4a7139a490282092cb1d9db249d.png" alt="img"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/5b07b1ad0c8f41dbbd44faf9eb5c3334.png" alt="img"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/17b715b890344d5aa54d58533549be57.png" alt="img"></p><blockquote><p>上边我们通过引起这三个方法（一个外围、两个内围）内的异常，发现当insertIDcardAndName方法有异常，并不会导致外围方法register和内围方法insertAccountAndPwd回滚。</p></blockquote><h4 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h4><p>注册时可以不提交身份证号与姓名（但是身份证号和姓名必须同时添加或不添加），也可以不提交手机号，后续确定后再提交即可，账号密码和手机号仍然不可缺少，少一个则全部回滚。</p><p><strong>传播行为选择</strong></p><p>上次业务修改我们只要保证内围方法insertIDcardAndName回滚不带上外围方法回滚，这次我们还要保证外围方法register回滚时不要带上内围方法insertAccountAndPwd回滚。</p><p>所以这次我们可以将@Transactional的事务传播属性propagation值设为<strong>Propagation.REQUIRES_NEW</strong>，它的含义是：如果当前没有事务，就新建一个事务。如果当前存在事务，把当前事务挂起，并且自己创建一个新的事务给自己使用。</p><p>这正好符合我们业务需求：外围方法是一个事务的情况下，我们的内围方法开始它自己的业务，外围方法回滚不带上内围方法。</p><p>测试</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/45b994b6edce413d87afbb416230793a.png" alt="img"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/652913bdfebb49eebc6e913678d8b731.png" alt="img"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/700a2667522d40bf8a4f45af8e5e42cc.png" alt="img"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/a7ca59a0dc4e489dadb1b1dce1e52296.png" alt="img"></p><blockquote><p>上边我们通过引起这三个方法（一个外围、两个内围）内的异常，发现当外围方法register方法有异常，并不会导致内围方法insertAccountAndPwd回滚。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当我们不想让内围回滚带上外围也回滚，内围方法事务就不要使用REQUIRED，可以使用NESTED或REQUIRES_NEW。</p><p>当我们不想让外围回滚带上内围也回滚，内围方法事务就不要使用REQUIRED和NESTED，可以使用REQUIRES_NEW。</p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring基础知识-AOP</title>
    <link href="/spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-AOP/a8d960500940/"/>
    <url>/spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-AOP/a8d960500940/</url>
    
    <content type="html"><![CDATA[<h1 id="1-原理"><a href="#1-原理" class="headerlink" title="1 原理"></a>1 原理</h1><ul><li><p><strong>面向切面编程</strong>，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得<strong>业务逻辑各部分之间的耦合度降低</strong>，提高程序的可重用性，同时提高了开发的效率。通俗来说就是<strong>在不修改代码的情况下添加新的功能。</strong></p></li><li><p>底层通过动态代理来实现：</p><ul><li>第一种：<strong>有接口的情况</strong>，使用JDK动态代理：<strong>创建接口实现类的代理对象</strong>。</li><li>第二种：<strong>无接口的情况</strong>，使用CGLIB动态代理：<strong>创建当前类子类的代理对象</strong>。</li></ul></li></ul><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><ol><li>通过 java.lang.reflect.Proxy类 的 newProxyInstance方法 创建代理类。<ol><li>newProxyInstance方法：</li></ol></li></ol><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/95dd9d0804e03a9505f51dea7f3f49d2.png" alt="image-20210801004308007"></p><pre><code class="hljs">1. 参数一：类加载器1. 参数二：所增强方法所在的类，这个类实现的接口，支持多个接口1. 参数三：实现InvocationHandle接口，重写invoke方法来添加新的功能</code></pre><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a*b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>增强类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>      Object obj;<br>  <span class="hljs-comment">//通过有参构造函数将所需代理的类传过来</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserDaoProxy</span><span class="hljs-params">(Object obj)</span>&#123;<br>          <span class="hljs-built_in">this</span>.obj = obj;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>          System.out.println(<span class="hljs-string">&quot;进入&quot;</span> + method.getName() + <span class="hljs-string">&quot;方法，这是新增的代码，参数有&quot;</span> + Arrays.toString(args));<br><br>    <span class="hljs-comment">//执行原有的代码</span><br>          <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(obj, args);<br><br>          System.out.println(<span class="hljs-string">&quot;方法原先的内容执行完了&quot;</span>);<br><br>          <span class="hljs-keyword">return</span> invoke;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-comment">//所需代理的类实现的接口，支持多个接口</span><br>        Class[] interfaces = &#123;UserDao.class&#125;;<br><br>        <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br>        <br><span class="hljs-comment">//调用newProxyInstance方法来创建代理类</span><br>        <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDaoProxy</span> <span class="hljs-operator">=</span> (UserDao) Proxy.newProxyInstance(Main.class.getClassLoader(), interfaces, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoProxy</span>(userDao));<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userDaoProxy.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        System.out.println(result);<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/20210801005210.png" alt="image-20210801005210363"></p><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>目标类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;目标方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现MethodInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行目标方法之前&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> proxy.invokeSuper(obj, args);<br>        System.out.println(<span class="hljs-string">&quot;执行目标方法之后&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibDynamicProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        enhancer.setSuperclass(TargetClass.class);   <span class="hljs-comment">//将代理类作为父类</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomMethodInterceptor</span>());<br><br>        <span class="hljs-type">TargetClass</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (TargetClass) enhancer.create();<br>        proxy.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">执行目标方法之前<br>目标方法<br>执行目标方法之后<br></code></pre></td></tr></table></figure><h1 id="2-基于AspectJ实现AOP操作"><a href="#2-基于AspectJ实现AOP操作" class="headerlink" title="2 基于AspectJ实现AOP操作"></a>2 基于AspectJ实现AOP操作</h1><h2 id="AOP相关术语"><a href="#AOP相关术语" class="headerlink" title="AOP相关术语"></a>AOP相关术语</h2><ol><li>连接点：类中可以被增强的方法，称为连接点。</li><li>切入点：实际被增强的方法，称为切入点。</li><li>通知：增强的那一部分逻辑代码。通知有多种类型：<ol><li>前置通知：增强部分代码在原代码前面。</li><li>后置通知：增强部分代码在原代码后面。</li><li>环绕通知：增强部分代码既有在原代码前面，也有在原代码后面。</li><li>异常通知：原代码发生异常后才会执行。</li><li>最终通知：类似与finally那一部分</li></ol></li><li>切面：指把通知应用到切入点这一个动作。</li></ol><h2 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h2><p><strong>语法：execution（[权限修饰符] [返回类型] [类全路径] [方法名称] [参数列表]）</strong></p><ol><li><p>对 com.atguigu.dao.BookDao 类里面的 add 进行增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com.auguigu.dao.BookDao.add(..))<br></code></pre></td></tr></table></figure></li><li><p>对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com.atguigu.dao.BookDao.*(..))<br></code></pre></td></tr></table></figure></li><li><p>对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(* com.atguigu.dao.*.* (..))<br></code></pre></td></tr></table></figure></li></ol><h2 id="基于注解实现AOP"><a href="#基于注解实现AOP" class="headerlink" title="基于注解实现AOP"></a>基于注解实现AOP</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;    <br>        System.out.println(<span class="hljs-string">&quot;User.add()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span>   <span class="hljs-comment">//使用Aspect注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxy</span> &#123;<br>    <span class="hljs-comment">//前置通知</span><br>    <span class="hljs-meta">@Before(value=&quot;execution(* com.oymn.spring5.User.add(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UserProxy.before()&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//后置通知</span><br>    <span class="hljs-meta">@AfterReturning(value=&quot;execution(* com.oymn.spring5.User.add(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UserProxy.afterReturning()&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//最终通知</span><br>    <span class="hljs-meta">@After(value=&quot;execution(* com.oymn.spring5.User.add(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">After</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UserProxy.After()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//异常通知</span><br>    <span class="hljs-meta">@AfterThrowing(value=&quot;execution(* com.oymn.spring5.User.add(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AfterThrowing</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UserProxy.AfterThrowing()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//环绕通知</span><br>    <span class="hljs-meta">@Around(value=&quot;execution(* com.oymn.spring5.User.add(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Around</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;UserProxy.Around()   _1&quot;</span>);<br><br>        <span class="hljs-comment">//调用proceed方法执行原先部分的代码</span><br>        proceedingJoinPoint.proceed();<br><br>        System.out.println(<span class="hljs-string">&quot;UserProxy.Around()   _2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.oymn.spring5&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;bean1.xml&quot;</span>);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;user&quot;</span>, User.class);<br>    user.add();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出<br><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/20210801210024.png" alt="image-20210801210024676"></p><p>异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>    System.out.println(<span class="hljs-string">&quot;User.add()&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/20210801210304.png" alt="image-20210801210304774"></p><p>对于上面的例子，有很多通知的切入点都是相同的方法，因此，可以将<strong>该切入点进行抽取：通过@Pointcut注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(value=&quot;execution(* com.oymn.spring5.User.add(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointDemo</span><span class="hljs-params">()</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">//前置通知</span><br><span class="hljs-meta">@Before(value=&quot;pointDemo()&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;UserProxy.before()&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>当有多个增强类对同一方法进行增强时，可以通过**@Order（数字值）来设置增强类的优先级，数字越小优先级越高。**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Order(1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonProxy</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring基础知识-IOC</title>
    <link href="/spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-IOC/245be0057711/"/>
    <url>/spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-IOC/245be0057711/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Spring概述"><a href="#1-Spring概述" class="headerlink" title="1 Spring概述"></a>1 Spring概述</h1><ol><li><p>Spring 是轻量级的开源的 JavaEE 框架</p></li><li><p>Spring 有两个核心部分：IOC 和 AOP。</p><ol><li>IOC：控制反转，把创建对象过程交给 Spring 进行管理</li><li>AOP：面向切面，不修改源代码进行功能增强</li></ol></li><li><p>Spring 特点 ：</p><ol><li>方便解耦，简化开发</li><li>Aop 编程支持</li><li>方便程序测试</li><li>方便和其他框架进行整合</li><li>方便进行事务操作</li><li>降低 API 开发难度</li></ol></li></ol><h1 id="2-IOC"><a href="#2-IOC" class="headerlink" title="2 IOC"></a>2 IOC</h1><p>概念：控制反转，把对象创建和对象的调用过程交给spring进行管理。</p><p>目标：<strong>降低耦合度。</strong></p><p>底层原理：<strong>xml，反射，工厂模式</strong></p><h2 id="2-1-两大接口"><a href="#2-1-两大接口" class="headerlink" title="2.1 两大接口"></a>2.1 两大接口</h2><p>Spring提供IOC容器两种实现方式（两个接口）</p><ol><li><p>BeanFactory：Spring内部使用的接口，不提倡开发人员使用。特点：加载配置文件时不会创建对象，获取对象时才会创建对象。</p></li><li><p><strong>ApplicationContext：</strong>BeanFactory的子接口，提供了更多更强大的功能，一般由开发人员使用。特点：加载配置文件时会把配置文件里的对象进行创建。</p><ol><li>FileSystemXmlApplicationContext：绝对路径，从盘符开始算起</li><li>ClassPathXmlApplicationContext：相对路径，从src开始算起</li></ol></li><li><p>Bean管理是指两个操作：Spring创建对象 和 Spring注入属性。</p><ol><li>Bean管理有两种操作方式：基于xml配置文件方式实现 和 基于注解方式实现</li></ol></li></ol><h2 id="2-2-基于XML操作Bean"><a href="#2-2-基于XML操作Bean" class="headerlink" title="2.2 基于XML操作Bean"></a>2.2 基于XML操作Bean</h2><p>在基于xml创建对象的时候需要做到：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/20210719101725.png" alt="image-20210719101725911"></p><ol><li>在Spring配置文件中使用bean标签来创建对象</li><li>bean标签有很多属性，常用属性：<ul><li>id：唯一标识</li><li>class：类路径</li></ul></li><li><strong>创建对象时，默认执行无参构造函数</strong></li></ol><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><blockquote><ol><li><p>为对应类提供set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String userAge;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserName</span><span class="hljs-params">(String userName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userName = userName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserAge</span><span class="hljs-params">(String userAge)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userAge = userAge;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userAge;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>在xml配置文件中通过property标签进行属性注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置User对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.oymn.spring5.User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;haha&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userAge&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;bean1.xml&quot;</span>);<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;user&quot;</span>, User.class);<br>System.out.println(user.getUserName() + <span class="hljs-string">&quot;     &quot;</span> + user.getUserAge());<br></code></pre></td></tr></table></figure></li></ol></blockquote><h4 id="注入值"><a href="#注入值" class="headerlink" title="注入值"></a>注入值</h4><h5 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置User对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.oymn.spring5.User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="属性值含有特殊符号"><a href="#属性值含有特殊符号" class="headerlink" title="属性值含有特殊符号"></a>属性值含有特殊符号</h5><p>假设现在userName属性需要赋值为 &lt; haha &gt;</p><p>如果像上面那样直接在value中声明的话会报错，因为包含特殊符号 &lt;&gt;</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/image-20240414102602634.png" alt="image-20240414102602634"></p><h5 id="注入外部Bean"><a href="#注入外部Bean" class="headerlink" title="注入外部Bean"></a>注入外部Bean</h5><p>有两个类：UserService和UserDaoImpl，其中UserDaoImpl实现UserDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span>&#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;add&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用ref来指定外部bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDaoImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.oymn.spring5.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.oymn.spring5.UserService&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="注入内部bean"><a href="#注入内部bean" class="headerlink" title="注入内部bean"></a>注入内部bean</h5><p>嵌套bean标签实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--内部 bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--设置两个普通属性--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ename&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lucy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--设置对象类型属性--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dept&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;安保部&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><blockquote><ol><li><p>提供有参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String userAge;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String userName, String userAge)</span>&#123;<br>        <span class="hljs-built_in">this</span>.userName = userName;<br>        <span class="hljs-built_in">this</span>.userAge = userAge;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>xml中通过constructor-arg标签进行属性注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置User对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.oymn.spring5.User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;haha&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userAge&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol></blockquote><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="注入值-1"><a href="#注入值-1" class="headerlink" title="注入值"></a>注入值</h4><h5 id="级联赋值"><a href="#级联赋值" class="headerlink" title="级联赋值"></a>级联赋值</h5><p>emp类中有ename和dept两个属性，其中dept有dname属性，写法二需要emp提供dept属性的get方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--级联赋值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--设置两个普通属性--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ename&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lucy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--写法一--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dept&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--写法二--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dept.dname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;技术部&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;财务部&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="注入属性集合-数组-List-Map-Set"><a href="#注入属性集合-数组-List-Map-Set" class="headerlink" title="注入属性集合-数组&#x2F;List&#x2F;Map&#x2F;Set"></a>注入属性集合-数组&#x2F;List&#x2F;Map&#x2F;Set</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stu</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String[] courses;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; list;<br>    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; map;<br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; set;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCourses</span><span class="hljs-params">(String[] courses)</span> &#123;<br>        <span class="hljs-built_in">this</span>.courses = courses;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setList</span><span class="hljs-params">(List&lt;String&gt; list)</span> &#123;<br>        <span class="hljs-built_in">this</span>.list = list;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMap</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> &#123;<br>        <span class="hljs-built_in">this</span>.map = map;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSet</span><span class="hljs-params">(Set&lt;String&gt; set)</span> &#123;<br>        <span class="hljs-built_in">this</span>.set = set;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.oymn.spring5.Stu&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数组类型属性注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;courses&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>java课程<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>数据库课程<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--List类型属性注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>李四<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Map类型属性注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;JAVA&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;java&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;PHP&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;php&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Set类型属性注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;set&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>Mysql<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>Redis<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果是对象的话，写法：集合+外部bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--创建多个 course 对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;course1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring5 框架&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;course2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;MyBatis 框架&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--注入 list 集合类型，值是对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;courseList&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;course1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;course2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>把集合注入部分提取出来</p><p>使用 util 标签，这样不同的bean都可以使用相同的集合注入部分了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--将集合注入部分提取出来--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;booklist&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>易筋经<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>九阳神功<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.oymn.spring5.Book&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;booklist&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><p>在Spring中，<strong>默认Bean是单实例对象</strong>。但是可以通过修改Bean标签中的scope属性，让单例对象变为多实例对象。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/20210719113500.png" alt="image-20210719113500730"></p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><ol><li>通过构造器创建 bean 实例（无参数构造）</li><li>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</li><li>把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization</li><li>调用 bean 的初始化的方法（需要进行配置初始化的方法）</li><li>把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization</li><li>bean 可以使用了（对象获取到了）</li><li>当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</li></ol><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orders</span> &#123;<br>    <span class="hljs-keyword">private</span> String orderName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Orders</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;第一步：执行无参构造方法创建bean实例&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOrderName</span><span class="hljs-params">(String orderName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.orderName = orderName;<br>        System.out.println(<span class="hljs-string">&quot;第二步：调用set方法设置属性值&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//初始化方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;第四步：执行初始化方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//销毁方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroyMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;第七步：执行销毁方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后置处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现后置处理器，需要实现BeanPostProcessor接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPost</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;第三步：将bean实例传递给bean后置处理器的postProcessBeforeInitialization方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;第五步：将bean实例传递给bean后置处理器的postProcessAfterInitialization方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>xml创建对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.oymn.spring5.Orders&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initMethod&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroyMethod&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;orderName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hahah&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--配置bean后置处理器，这样配置后整个xml里面的bean用的都是这个后置处理器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myBeanPost&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.oymn.spring5.MyBeanPost&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testOrders</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;bean1.xml&quot;</span>);<br><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;orders&quot;</span>, Orders.class);<br><br>    System.out.println(<span class="hljs-string">&quot;第六步：获取bean实例对象&quot;</span>);<br>    System.out.println(orders);<br><br>    <span class="hljs-comment">//手动让bean实例销毁</span><br>    context.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/20210720122628.png" alt="image-20210720122628081"></p><h3 id="XML自动装配"><a href="#XML自动装配" class="headerlink" title="XML自动装配"></a>XML自动装配</h3><ul><li>根据指定的装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入。</li><li>根据属性名称自动装配：要求 emp中属性的名称dept 和 bean标签的id值dept 一样，才能识别。</li><li>根据属性类型自动装配：要求同一个xml文件中不能有两个相同类型的bean，否则无法识别是哪一个</li></ul><h3 id="通过外部文件操作Bean"><a href="#通过外部文件操作Bean" class="headerlink" title="通过外部文件操作Bean"></a>通过外部文件操作Bean</h3><ol><li>导入德鲁伊连接池jar包</li><li>创建外部属性文件，properties格式文件，写数据库信息</li></ol><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/20210731004522.png" alt="image-20210731004522456"></p><ol start="3"><li>引入context名称空间，并通过context标签引入外部属性文件，使用“${}”来获取文件中对应的值</li></ol><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Spring/a6aa7ccefe1d0a49cc0729a056c8086b.png" alt="image-20210731010320233"></p><h2 id="2-3-基于注解操作Bean"><a href="#2-3-基于注解操作Bean" class="headerlink" title="2.3 基于注解操作Bean"></a>2.3 基于注解操作Bean</h2><ul><li>格式：@注解名称（属性名&#x3D;属性值，属性名&#x3D;属性值，……）</li><li>注解可以作用在类，属性，方法。</li><li>使用注解的目的：简化xml配置</li></ul><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul><li>@Component：将该类标记为一个组件，Spring会自动扫描该类，并将其实例化为一个Bean。</li><li>@Service：一般用于Service层</li><li>@Controller：一般用于web层</li><li>@ Repository：一般用于Dao层</li></ul><h3 id="基于注解进行属性注入"><a href="#基于注解进行属性注入" class="headerlink" title="基于注解进行属性注入"></a>基于注解进行属性注入</h3><p><strong>@Autowired</strong>：根据属性类型自动装配</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StuDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StuDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StuDao</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;StuDaoImpl&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(value=&quot;stuService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StuService</span> &#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> StuDao stuDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;addService&quot;</span>);<br>        stuDao.add();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>@Qualifier</strong>：根据属性名称自动装配</p><blockquote><p>当遇到一个接口有很多实现类时，只通过@Autowire是无法完成自动装配的，所以需要再使用@Qualifier通过名称来锁定某个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(value=&quot;stuService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StuService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(value=&quot;stuDaoImpl&quot;)</span>  <span class="hljs-comment">//这样就能显式指定stuDaoImpl这个实现类</span><br>    <span class="hljs-keyword">public</span> StuDao stuDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;addService&quot;</span>);<br>        stuDao.add();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>@Resource</strong>：可以根据类型注入，也可以根据名称注入</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(value=&quot;stuService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StuService</span> &#123;<br>    <br>    <span class="hljs-comment">//@Resource   //根据类型进行注入</span><br>    <span class="hljs-meta">@Resource(name=&quot;stuDaoImpl&quot;)</span>  <span class="hljs-comment">//根据名称进行注入</span><br>    <span class="hljs-keyword">public</span> StuDao stuDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;addService&quot;</span>);<br>        stuDao.add();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>@Value</strong>：注入普通类型属性</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(value = &quot;abc&quot;)</span><br><span class="hljs-keyword">private</span> String name;<br></code></pre></td></tr></table></figure></blockquote><h3 id="完全基于注解开发"><a href="#完全基于注解开发" class="headerlink" title="完全基于注解开发"></a>完全基于注解开发</h3><p>创建配置类替代XML文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>    <span class="hljs-comment">//表明为一个配置类</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.oymn&quot;)</span>   <span class="hljs-comment">//开启组件扫描</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springcloud微服务技术栈-04</title>
    <link href="/springclou%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88-04/016cd1d7bfed/"/>
    <url>/springclou%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88-04/016cd1d7bfed/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>springcloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springcloud微服务技术栈-03</title>
    <link href="/springclou%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88-03/a8ff326633d6/"/>
    <url>/springclou%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88-03/a8ff326633d6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>springcloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springcloud微服务技术栈-02</title>
    <link href="/springclou%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88-02/2a83262f3ef9/"/>
    <url>/springclou%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88-02/2a83262f3ef9/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>springcloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springclou微服务技术栈-01</title>
    <link href="/springclou%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88-01/f0aa2e2b38d0/"/>
    <url>/springclou%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88-01/f0aa2e2b38d0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-微服务认识"><a href="#1-微服务认识" class="headerlink" title="1 微服务认识"></a>1 微服务认识</h1><blockquote><p>SpringCloud ！&#x3D; 微服务</p></blockquote><h2 id="1-1-如何学"><a href="#1-1-如何学" class="headerlink" title="1.1 如何学"></a>1.1 如何学</h2><ol><li>核心思想是拆分，把大的业务模块划分成多个小的模块，每个模块叫服务。多个服务形成了服务集群。</li><li>服务集群多了之后，各个服务之间的调用关系会很复杂，需要靠注册中心管理。</li><li>同理，随着服务集群的增多，配置文件也不断增长需要配置中心来管理(实现配置的热更新)。</li><li>用户访问组件需要经过网关，其作用主要是：身份验证、路由规则、负载均衡。</li><li>把数据库数据放入内存中，为了应对高并发，不能是单体缓存而是集群，称为分布式缓存。</li><li>进行搜索的时候用上分布式搜索。</li><li>最后还需要异步通信的消息队列，为了减少服务通知的链路，缩短响应时间，增加吞吐量。</li><li>最后这么多组件，一旦出了问题，不好定位，引入分布式日志服务。</li><li>实时监控系统中各个服务的状态和内存占用，可以定位到某个方法栈信息，便于找到异常所在称为系统监控链路追踪。</li></ol><h2 id="1-2-学习规划"><a href="#1-2-学习规划" class="headerlink" title="1.2 学习规划"></a>1.2 学习规划</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/a7079e42e02b43989a56284cfa7cf261.png" alt="在这里插入图片描述"></p><h2 id="1-3-单体架构和分布式架构"><a href="#1-3-单体架构和分布式架构" class="headerlink" title="1.3 单体架构和分布式架构"></a>1.3 单体架构和分布式架构</h2><h3 id="1-3-1-单体架构"><a href="#1-3-1-单体架构" class="headerlink" title="1.3.1 单体架构"></a>1.3.1 单体架构</h3><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h3 id="1-3-2-分布式架构"><a href="#1-3-2-分布式架构" class="headerlink" title="1.3.2 分布式架构"></a>1.3.2 分布式架构</h3><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><blockquote><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul></blockquote><h2 id="1-4-微服务"><a href="#1-4-微服务" class="headerlink" title="1.4 微服务"></a>1.4 微服务</h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><h3 id="1-4-1-微服务技术对比"><a href="#1-4-1-微服务技术对比" class="headerlink" title="1.4.1 微服务技术对比"></a>1.4.1 微服务技术对比</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/578f90a2be084cb5b733dff0470bc9e5.png" alt="在这里插入图片描述"></p><h3 id="1-4-2-SpringCloud"><a href="#1-4-2-SpringCloud" class="headerlink" title="1.4.2 SpringCloud"></a>1.4.2 SpringCloud</h3><p>SpringCloud是目前国内使用最广泛的微服务框架。集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>常用组件：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/d926594e22d446efb0d2f1b16c74577e.png" alt="在这里插入图片描述"></p><p>版本关系：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/b3ab831aeb02466c9181cc6f5a0edb07.png" alt="在这里插入图片描述"></p><h1 id="2-服务拆分和远程调用"><a href="#2-服务拆分和远程调用" class="headerlink" title="2 服务拆分和远程调用"></a>2 服务拆分和远程调用</h1><h2 id="2-1-服务拆分原则"><a href="#2-1-服务拆分原则" class="headerlink" title="2.1 服务拆分原则"></a>2.1 服务拆分原则</h2><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><h2 id="2-2-demo"><a href="#2-2-demo" class="headerlink" title="2.2 demo"></a>2.2 demo</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/5148009735d54e0d865aec5fbfa28387.png" alt="在这里插入图片描述"></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/c0127a23415d4acb9a12a58189011190.png" alt="在这里插入图片描述"></p><h2 id="2-3-远程调用"><a href="#2-3-远程调用" class="headerlink" title="2.3 远程调用"></a>2.3 远程调用</h2><p>在order-service服务中，有一个根据id查询订单的接口：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/e264831bbce745a8a848a070ca9b70a9.png" alt="在这里插入图片描述"></p><blockquote><p><a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a> 进行查询</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/2036990b89474356b2e1b52edbaf9454.png" alt="在这里插入图片描述"></p></blockquote><p>在user-service中有一个根据id查询用户的接口：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/e9a8bcb3d987428dbc4ae49d46a866ca.png" alt="在这里插入图片描述"></p><blockquote><p><a href="http://localhost:8081/user/1">http://localhost:8081/user/1</a> 进行查询<br><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/ef76d983db85404599e1b087cf00471d.png" alt="在这里插入图片描述"></p></blockquote><p>那么此时如何可以在查询订单的时候将用户信息返回呢？</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/a65b799a4bb844609be3eff482b28a25.png" alt="在这里插入图片描述"></p><h2 id="2-4-实现"><a href="#2-4-实现" class="headerlink" title="2.4 实现"></a>2.4 实现</h2><h3 id="2-4-1-注册RestTemplate"><a href="#2-4-1-注册RestTemplate" class="headerlink" title="2.4.1 注册RestTemplate"></a>2.4.1 注册RestTemplate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.order;<br><br><span class="hljs-keyword">import</span> org.mybatis.spring.annotation.MapperScan;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(OrderApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-2-实现远程调用"><a href="#2-4-2-实现远程调用" class="headerlink" title="2.4.2 实现远程调用"></a>2.4.2 实现远程调用</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/bc23f328b85642b59261a347a836f54d.png" alt="在这里插入图片描述"></p><blockquote><p>这样再次访问<a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a> 就能在查询订单信息的时候查询出用户相关信息</p></blockquote><h2 id="2-5-提供者和消费者"><a href="#2-5-提供者和消费者" class="headerlink" title="2.5 提供者和消费者"></a>2.5 提供者和消费者</h2><p>在服务调用关系中，会有两个不同的角色：</p><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）<br><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/a0118f83b9714fb2bf8395391f7bc75c.png" alt="在这里插入图片描述"></p><blockquote><p>但是提供者和消费者只是相对而言，没有绝对的定义，需要依据提供的服务以及使用的服务进行决定的。</p></blockquote><h1 id="3-Eureka注册中心"><a href="#3-Eureka注册中心" class="headerlink" title="3 Eureka注册中心"></a>3 Eureka注册中心</h1><h2 id="3-1-Eureka的作用"><a href="#3-1-Eureka的作用" class="headerlink" title="3.1 Eureka的作用"></a>3.1 Eureka的作用</h2><p>当user-service部署多个的时候，存在一下几个问题：</p><ol><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时该如何选择？</li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li></ol><p>因此针对上面的问题，利用SpringCloud的注册中心就可以解决，其中最广为人知的注册中心就是Eureka。</p><h2 id="3-2-Eureka结构"><a href="#3-2-Eureka结构" class="headerlink" title="3.2 Eureka结构"></a>3.2 Eureka结构</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/8741664e455749d497bcdb3980c86fd9.png" alt="在这里插入图片描述"></p><blockquote><p>问题1：order-service如何得知user-service实例地址？</p></blockquote><p>获取地址信息的流程如下：</p><ol><li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li><li>eureka-server保存服务名称到服务实例地址列表的映射关系。</li><li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取。</li></ol><p></p><blockquote><p>问题2：order-service如何从多个user-service实例中选择具体的实例？</p></blockquote><ol><li>order-service从实例列表中利用负载均衡算法选中一个实例地址向该实例地址发起远程调用。</li></ol><blockquote><p>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p></blockquote><ol><li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除order-service拉取服务时，就能将故障实例排除了。</li></ol><blockquote><p>一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p></blockquote><h2 id="3-3-动手搭建"><a href="#3-3-动手搭建" class="headerlink" title="3.3 动手搭建"></a>3.3 动手搭建</h2><p>首先搭建注册中心服务端：eureka-server，这必须是一个独立的微服务</p><h3 id="3-3-1-创建eureka-server"><a href="#3-3-1-创建eureka-server" class="headerlink" title="3.3.1 创建eureka-server"></a>3.3.1 创建eureka-server</h3><ol><li>新建模块：在cloud-demo父工程下，创建一个子模块：</li></ol><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/dceb951554ea45ff8f24622683b598c6.png" alt="在这里插入图片描述"></p><ol start="2"><li><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.eureka;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EurekaApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用@EnableEurekaServer注解，这样就开启eureka的注册中心功能</p></blockquote></li><li><p>编写配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure></li></ol><p>启动该服务，发现无任何异常</p><h3 id="3-3-2-服务注册"><a href="#3-3-2-服务注册" class="headerlink" title="3.3.2 服务注册"></a>3.3.2 服务注册</h3><blockquote><p>即：哪个服务需要对外提供服务能力，哪个服务进行注册</p></blockquote><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>修改配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure></li><li><p>启动多user-service实例</p><p>复制原user-service启动配置</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/f0477881f8f7468eb48324345044edab.png" alt="在这里插入图片描述"></p><p>修改配置信息：<code>-Dserver.port=8082</code></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/6184869fa3664d76b2e9251fee9fc0ca.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/c961dce6e36f465895f9108d7ee8b752.png" alt="在这里插入图片描述"></p></li></ol><h3 id="3-3-3-服务发现"><a href="#3-3-3-服务发现" class="headerlink" title="3.3.3 服务发现"></a>3.3.3 服务发现</h3><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">orderservice</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure></li><li><p>服务拉取和负载均衡</p><ol><li><p>在order-service中的Application中添加一个<code>@LoadBalanced</code></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/f88b90b50646464d99f33d67cd62311e.png" alt="在这里插入图片描述"></p></li><li><p>修改之前的url，使用服务名代替ip和端口：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/2bfb7abae1424039a2e4e56f30471f1f.png" alt="在这里插入图片描述"></p></li><li><p>重启后访问：<code>http://localhost:8080/order/102</code>和<code>http://localhost:8080/order/101</code>发现两个服务都有日志输出。</p></li></ol></li></ol><h1 id="4-Ribbon负载均衡"><a href="#4-Ribbon负载均衡" class="headerlink" title="4 Ribbon负载均衡"></a>4 Ribbon负载均衡</h1><h2 id="4-1-负载均衡原理"><a href="#4-1-负载均衡原理" class="headerlink" title="4.1 负载均衡原理"></a>4.1 负载均衡原理</h2><p>在SpringCloud的底层其实使用了一个名为Ribbon的组件，实现了负载均衡。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/427b8ac5ff424fe2b9e0c18163259664.png" alt="在这里插入图片描述"></p><h2 id="4-2-源码跟踪"><a href="#4-2-源码跟踪" class="headerlink" title="4.2 源码跟踪"></a>4.2 源码跟踪</h2><p>在源码跟踪前，思考一下为什么我们使用服务名替换了原来的ip和端口就可以访问了，并且请求明明是<a href="http://userservice/user/1%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E5%90%8E%E5%8F%98%E6%88%90%E4%BA%86http://localhost:8081">http://userservice/user/1，为什么最后变成了http://localhost:8081</a></p><h3 id="4-2-1-LoadBalacerInterceptor"><a href="#4-2-1-LoadBalacerInterceptor" class="headerlink" title="4.2.1 LoadBalacerInterceptor"></a>4.2.1 LoadBalacerInterceptor</h3><p>这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/65f941536921415ebb9d8f4ad03db934.png" alt="在这里插入图片描述"></p><p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p><ul><li>request.getURI()：获取请求uri，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li>originalUri.getHost()：获取uri路径的主机名，其实就是服务id，user-service</li><li>this.loadBalancer.execute()：处理服务id，和用户请求。</li></ul><p>这里的this.loadBalancer是LoadBalancerClient类型，我们继续跟入。</p><h3 id="4-2-2-LoadBalancerClient"><a href="#4-2-2-LoadBalancerClient" class="headerlink" title="4.2.2 LoadBalancerClient"></a>4.2.2 LoadBalancerClient</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/4892fef950334acdbe8a9af7418e78d3.png" alt="在这里插入图片描述"></p><ul><li><p>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</p></li><li><p>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</p></li></ul><p>放行后，再次访问并跟踪，发现获取的是8081：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/8becd127c28342ba8cab27fb2c30b55b.png" alt="在这里插入图片描述"><br>果然实现了负载均衡。</p><h3 id="4-2-3-负载均衡策略IRule"><a href="#4-2-3-负载均衡策略IRule" class="headerlink" title="4.2.3 负载均衡策略IRule"></a>4.2.3 负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡，内部跟进</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/76f1b0fa3d5140de96e04b631fa81858.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/7e985520a5ca4bc983eed85213c3a50c.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/c017c1a23cb042838967b61311d6427f.png" alt="在这里插入图片描述"></p><p>那么这个<code>RoundRobinRule</code>就是轮询策略</p><h3 id="4-2-4-总结"><a href="#4-2-4-总结" class="headerlink" title="4.2.4 总结"></a>4.2.4 总结</h3><p>pringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/9cf9b4759d2542c0a1b512f1a15edf17.png" alt="在这里插入图片描述"></p><p>基本流程如下：</p><ol><li>拦截我们的RestTemplate请求<a href="http://userservice/user/1">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost:8081、localhost:8082</li><li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82%E3%80%82">http://localhost:8081/user/1，发起真实请求。</a></li></ol><h2 id="4-3-负载均衡策略"><a href="#4-3-负载均衡策略" class="headerlink" title="4.3 负载均衡策略"></a>4.3 负载均衡策略</h2><h3 id="4-3-1-类图"><a href="#4-3-1-类图" class="headerlink" title="4.3.1 类图"></a>4.3.1 类图</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/7cd2c1f4ec164e44a859bb348e364edd.png" alt="在这里插入图片描述"></p><table><thead><tr><th align="center"><strong>内置负载均衡规则类</strong></th><th align="center"><strong>规则描述</strong></th></tr></thead><tbody><tr><td align="center">RoundRobinRule</td><td align="center">简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td align="center">AvailabilityFilteringRule</td><td align="center">对以下两种服务器进行忽略： （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的&lt; clientName &gt;.&lt; clientConfigNameSpace &gt;.ActiveConnectionsLimit属性进行配置。</td></tr><tr><td align="center">WeightedResponseTimeRule</td><td align="center">为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td align="center">ZoneAvoidanceRule</td><td align="center">以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td align="center">BestAvailableRule</td><td align="center">忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td align="center">RandomRule</td><td align="center">随机选择一个可用的服务器。</td></tr><tr><td align="center">RetryRule</td><td align="center">重试机制的选择逻辑</td></tr></tbody></table><blockquote><p>默认实现：ZoneAvoidanceRule</p></blockquote><h3 id="4-3-2-自定义负载均衡策略"><a href="#4-3-2-自定义负载均衡策略" class="headerlink" title="4.3.2 自定义负载均衡策略"></a>4.3.2 自定义负载均衡策略</h3><ul><li><p>方式1：代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> IRule <span class="hljs-title function_">randomRule</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomRule</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方式2：配置文件：在order-service的application.yml文件中，添加新的配置也可以修改规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-4-饥饿加载"><a href="#4-4-饥饿加载" class="headerlink" title="4.4 饥饿加载"></a>4.4 饥饿加载</h2><p>当重启重启order-service，访问<code>http://localhost:8080/order/101</code></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/7c63c6a080c94711bdae4a780534a92a.png" alt="在这里插入图片描述"></p><p>发现耗时很高，重新刷新后<br><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/00904d8277e84aa7982d27efb0810a2b.png" alt="在这里插入图片描述"></p><p>为何差别如此大？</p><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p><p>如何降低第一次访问耗时？</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/3ca809a32bab4ccab6c813741cb076c2.png" alt="在这里插入图片描述"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">eager-load:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">clients:</span> <span class="hljs-string">userservice</span><br>      <span class="hljs-comment"># 多个需要用-分割、换行</span><br>      <span class="hljs-comment"># -userservice1</span><br>      <span class="hljs-comment"># -userservice2</span><br></code></pre></td></tr></table></figure><h1 id="5-Nacos注册中心"><a href="#5-Nacos注册中心" class="headerlink" title="5 Nacos注册中心"></a>5 Nacos注册中心</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</p><h2 id="5-2-依赖"><a href="#5-2-依赖" class="headerlink" title="5.2 依赖"></a>5.2 依赖</h2><p>项目根目录下的pom.xml引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>nacos客户端依赖包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- nacos客户端依赖包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-3-服务注册"><a href="#5-3-服务注册" class="headerlink" title="5.3 服务注册"></a>5.3 服务注册</h2><ol><li><p>引入依赖</p><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置nacos地址</p><p>在user-service和order-service的配置文件添加nacos地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br><br></code></pre></td></tr></table></figure></li><li><p>重启服务</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/73e620b393084d2c90a27cc4ca4d71fa.png" alt="在这里插入图片描述"></p></li></ol><h2 id="5-4-服务分级存储模型"><a href="#5-4-服务分级存储模型" class="headerlink" title="5.4 服务分级存储模型"></a>5.4 服务分级存储模型</h2><p>一个服务可以有多个实例，例如我们的user-service，可以有:</p><p>127.0.0.1:8081<br>127.0.0.1:8082<br>127.0.0.1:8083<br>假如这些实例分布于全国各地的不同机房，例如：</p><p>127.0.0.1:8081，在上海机房<br>127.0.0.1:8082，在上海机房<br>127.0.0.1:8083，在杭州机房<br>Nacos就将同一机房内的实例 划分为一个集群。</p><p>即：user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/5e6274232dfc4164b3e80166ff5655c4.png" alt="在这里插入图片描述"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。</p><h3 id="5-4-1-user-service配置集群"><a href="#5-4-1-user-service配置集群" class="headerlink" title="5.4.1 user-service配置集群"></a>5.4.1 user-service配置集群</h3><p>修改user-service的application.yml文件，添加集群相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称</span><br></code></pre></td></tr></table></figure><p>重启两个user-service实例：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/5db68262da6e4debae8b32f6ad4bff05.png" alt="在这里插入图片描述"></p><p>同时再复制一个user-service启动配置，添加相关属性<code>-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH</code></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/90575cea053140a1bc9a5bbe67d04f99.png" alt="在这里插入图片描述"></p><p>启动UserApplication3后再次查看nacos控制台</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/3c050141842d4b4987ea1e335ff6c672.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/3c050141842d4b4987ea1e335ff6c672-20240316203202823.png" alt="在这里插入图片描述"></p><h3 id="5-4-2-同集群优先的负载均衡"><a href="#5-4-2-同集群优先的负载均衡" class="headerlink" title="5.4.2 同集群优先的负载均衡"></a>5.4.2 同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。<br>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><ol><li><p>修改order-service的application.yaml文件，添加集群相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称</span><br></code></pre></td></tr></table></figure><blockquote><p>但是多次访问后还是轮询调用，我们现在只想访问HZ集群下的，不想让SH集群的实例被访问</p></blockquote></li><li><p>修改order-service的application.yml文件，修改负载均衡规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">userservice:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure><blockquote><p>随后再访问发现SH集群下载user-service3没有任何日志输出</p></blockquote></li><li><p>当HZ集群都停掉，此时会调用SH集群下的服务</p></li></ol><h2 id="5-5-权重配置"><a href="#5-5-权重配置" class="headerlink" title="5.5 权重配置"></a>5.5 权重配置</h2><p>实际部署中会出现这样的场景：<br>• 服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/6cd6cf71d26c4b42b459a1b35a0a12fe.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/452379c893e8478ea9ba036f1d6ba472.png" alt="在这里插入图片描述"></p><blockquote><p>如果权重修改为0，则该实例永远不会被访问<br>权重为0通常用于系统升级。<br>先将某个服务器的权重设置为0，然后做升级，升级完后，把权重调小，放一部分用户进来，无问题，再把权重扩大。(平滑升级)</p></blockquote><h2 id="5-6-环境隔离"><a href="#5-6-环境隔离" class="headerlink" title="5.6 环境隔离"></a>5.6 环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><blockquote><p>其实namespace针对开发人员解决开发环境、测试环境、生产环境切换等。</p></blockquote><h3 id="5-6-1-创建namespace"><a href="#5-6-1-创建namespace" class="headerlink" title="5.6.1 创建namespace"></a>5.6.1 创建namespace</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/9ccfa49c759947a4926479031b9f8c65.png" alt="在这里插入图片描述"></p><p>我们可以点击页面新增按钮，添加一个namespace：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/89e4e7075c9c40ccacc59a1b3798233a.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/467548a3855b45a4969ed3b5bd66a8d1.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/d7ea78da1471401daa9d2485149e6535.png" alt="在这里插入图片描述"></p><h3 id="5-6-2-服务配置namespace"><a href="#5-6-2-服务配置namespace" class="headerlink" title="5.6.2 服务配置namespace"></a>5.6.2 服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p><p>例如，修改order-service的application.yml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="hljs-comment"># 命名空间，填ID</span><br></code></pre></td></tr></table></figure><h2 id="5-7-Nacos和Eureka区别"><a href="#5-7-Nacos和Eureka区别" class="headerlink" title="5.7 Nacos和Eureka区别"></a>5.7 Nacos和Eureka区别</h2><p>Nacos的服务实例分为两种l类型：</p><ul><li>临时实例：每隔30秒会向Nacos发送心跳，靠Nacos进行监控，一旦发现超时未发送心跳，就会被Nacos从服务列表中移除。</li><li>非临时实例：不会发送心跳，是Nacos主动向provider进行询问。如果询问超时也不会剔除服务列表，而是仅仅标记为不健康，等待其恢复健康即可。</li></ul><p>默认情况下，所有实例都是临时实例</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/a64d9c2786504f7ba4b50a061989bb53.png" alt="在这里插入图片描述"></p><h3 id="5-7-1-修改为永久实例"><a href="#5-7-1-修改为永久实例" class="headerlink" title="5.7.1 修改为永久实例"></a>5.7.1 修改为永久实例</h3><p>Order-service:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">ephemeral:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 设置为非临时实例</span><br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/SpringCloud/5606af21ad904041b9c03beeb68bc9c4.png" alt="在这里插入图片描述"></p><p>当关闭的时候，nacos控制台只是把它标记为不健康</p><h3 id="5-7-2-区别"><a href="#5-7-2-区别" class="headerlink" title="5.7.2 区别"></a>5.7.2 区别</h3><p>相同点：</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul><p>不同点：</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式(强调服务可用性)，当集群中存在非临时实例时，采用CP模式(可靠性和一致性)；Eureka采用AP方式。</li></ul>]]></content>
    
    
    <categories>
      
      <category>springcloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis-附近&amp;签到&amp;UV</title>
    <link href="/redis-%E9%99%84%E8%BF%91-%E7%AD%BE%E5%88%B0-UV/91f9a5d4aa12/"/>
    <url>/redis-%E9%99%84%E8%BF%91-%E7%AD%BE%E5%88%B0-UV/91f9a5d4aa12/</url>
    
    <content type="html"><![CDATA[<h1 id="1-附近的店铺"><a href="#1-附近的店铺" class="headerlink" title="1 附近的店铺"></a>1 附近的店铺</h1><h2 id="1-1-GEO数据结构的基本用法"><a href="#1-1-GEO数据结构的基本用法" class="headerlink" title="1.1 GEO数据结构的基本用法"></a>1.1 GEO数据结构的基本用法</h2><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li>GEODIST：计算指定的两个点之间的距离并返回</li><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li><li>GEOPOS：返回指定member的坐标</li><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能。</li></ul><h2 id="1-2-附近的店铺导入GEO"><a href="#1-2-附近的店铺导入GEO" class="headerlink" title="1.2 附近的店铺导入GEO"></a>1.2 附近的店铺导入GEO</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/b618a38193b04d26bb0dea88c35d4d32.png" alt="在这里插入图片描述"></p><p>分析shop对应的数据库表，发现有一个typeId字段，表明是什么类型的，那么此时可以根据这个字段将店铺进行分组</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/a55fc0a0189144c39835a8e5dd7f0a89.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">loadShopData</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.查询店铺信息</span><br>    List&lt;Shop&gt; list = shopService.list();<br>    <span class="hljs-comment">// 2.把店铺按照typeId分组，typeId一样的分一组</span><br>    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));<br><br>    <span class="hljs-comment">// 3.分批完成写入Redis</span><br>    Set&lt;Map.Entry&lt;Long, List&lt;Shop&gt;&gt;&gt; entries = map.entrySet();<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : entries) &#123;<br>        <span class="hljs-comment">// 3.1获取typeId</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">typeId</span> <span class="hljs-operator">=</span> entry.getKey();<br><br>        <span class="hljs-comment">// 3.2获取同类型的店铺的集合</span><br>        List&lt;Shop&gt; value = entry.getValue();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.SHOP_GEO_KEY + typeId;<br>        <span class="hljs-comment">// 3.3 写入Redis</span><br><br>        <span class="hljs-comment">// 方法一：打开shop实体类集合，一条店铺一条店铺添加(比较慢)</span><br>        <span class="hljs-comment">/*for (Shop shop : value) &#123;</span><br><span class="hljs-comment">            stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span><br><span class="hljs-comment">        &#125;*/</span><br><br>        <span class="hljs-comment">// 方法二：locations</span><br>        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(value.size());<br>        <span class="hljs-keyword">for</span> (Shop shop : value) &#123;<br>            locations.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(shop.getId().toString(),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(shop.getX(), shop.getY())));<br>        &#125;<br>        stringRedisTemplate.opsForGeo().add(key, locations);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-获取附近的店铺"><a href="#1-3-获取附近的店铺" class="headerlink" title="1.3 获取附近的店铺"></a>1.3 获取附近的店铺</h2><p>SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.lettuce<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lettuce-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/of/type&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopByType</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span><br><span class="hljs-params">)</span> &#123;<br>   <span class="hljs-keyword">return</span> shopService.queryShopByType(typeId, current, x, y);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> //根据商铺类型分页查询商铺信息(加入坐标)</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopByType</span><span class="hljs-params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;<br>    <span class="hljs-comment">// 1.判断是否需要根据坐标查询，如果需要再按照坐标</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == x || <span class="hljs-literal">null</span> == y) &#123;<br>        <span class="hljs-comment">// 根据类型分页查询</span><br>        Page&lt;Shop&gt; page = query()<br>                .eq(<span class="hljs-string">&quot;type_id&quot;</span>, typeId)<br>                .page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));<br>        <span class="hljs-comment">// 返回数据</span><br>        <span class="hljs-keyword">return</span> Result.ok(page.getRecords());<br>    &#125;<br><br>    <span class="hljs-comment">// 2.分页参数的计算</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前页的起始数据是第几条</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> (current - <span class="hljs-number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前页的结束数据是第几条</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;<br><br>    <span class="hljs-comment">// 3.查询redis，按照距离排序和分页 结果 shopId ,distance</span><br>    <span class="hljs-comment">// GEOSEARCH g1 FROMLONLAT 116.397904 39.909005 BYRADIUS 10 km WITHDIST</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.SHOP_GEO_KEY + typeId;<br>    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo()<br>            .search(key,<br>                    GeoReference.fromCoordinate(x, y),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Distance</span>(RedisConstants.GEO_DISTANT),<br>                    RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeDistance().limit(end)<br>            );<br><br>    <span class="hljs-comment">// 4.解析shopId</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == results) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();<br>    ArrayList&lt;Long&gt; shopIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list.size());<br>    Map&lt;String, Distance&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(list.size());<br>    <span class="hljs-comment">// 4.1 截取从from 到 end</span><br>    list.stream().skip(from).forEach(result -&gt; &#123;<br>        <span class="hljs-comment">// 4.2获取店铺id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopIdStr</span> <span class="hljs-operator">=</span> result.getContent().getName();<br>        shopIds.add(Long.valueOf(shopIdStr));<br><br>        <span class="hljs-comment">// 4.3获取距离</span><br>        <span class="hljs-type">Distance</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> result.getDistance();<br><br>        map.put(shopIdStr, distance);<br>    &#125;);<br><br>    <span class="hljs-comment">// 5.根据id查询shop</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">joinStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, shopIds);<br>    List&lt;Shop&gt; shops = query().in(<span class="hljs-string">&quot;id&quot;</span>, shopIds).last(<span class="hljs-string">&quot;order by field(id,&quot;</span> + joinStr + <span class="hljs-string">&quot;)&quot;</span>).list();<br>    <span class="hljs-keyword">for</span> (Shop shop : shops) &#123;<br>        shop.setDistance(map.get(shop.getId().toString()).getValue());<br>    &#125;<br><br>    <span class="hljs-comment">// 6.返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(shops);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是此时测试的时候，到最后的时候向下拉却报错了</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/6856c73dfc814521b58138fc3dfa70a7.png" alt="在这里插入图片描述"></p><p>原因分析：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/5abe1713f1ef422780ff4cae726be1e2.png" alt="在这里插入图片描述"></p><p>最后在截取的时候，跳过之后就没有任何值了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> //根据商铺类型分页查询商铺信息(加入坐标)</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopByType</span><span class="hljs-params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;<br>    <span class="hljs-comment">// 1.判断是否需要根据坐标查询，如果需要再按照坐标</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == x || <span class="hljs-literal">null</span> == y) &#123;<br>        <span class="hljs-comment">// 根据类型分页查询</span><br>        Page&lt;Shop&gt; page = query()<br>                .eq(<span class="hljs-string">&quot;type_id&quot;</span>, typeId)<br>                .page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));<br>        <span class="hljs-comment">// 返回数据</span><br>        <span class="hljs-keyword">return</span> Result.ok(page.getRecords());<br>    &#125;<br><br>    <span class="hljs-comment">// 2.分页参数的计算</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前页的起始数据是第几条</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> (current - <span class="hljs-number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前页的结束数据是第几条</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;<br><br>    <span class="hljs-comment">// 3.查询redis，按照距离排序和分页 结果 shopId ,distance</span><br>    <span class="hljs-comment">// GEOSEARCH g1 FROMLONLAT 116.397904 39.909005 BYRADIUS 10 km WITHDIST</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.SHOP_GEO_KEY + typeId;<br>    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo()<br>            .search(key,<br>                    GeoReference.fromCoordinate(x, y),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Distance</span>(RedisConstants.GEO_DISTANT),<br>                    RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeDistance().limit(end)<br>            );<br><br>    <span class="hljs-comment">// 4.解析shopId</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == results) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();<br>    ArrayList&lt;Long&gt; shopIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list.size());<br>    <span class="hljs-keyword">if</span>(list.size () &lt;= from) &#123;<br>      <span class="hljs-comment">// 已经没有下一页了</span><br>      <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    Map&lt;String, Distance&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(list.size());<br>    <span class="hljs-comment">// 4.1 截取从from 到 end</span><br>    list.stream().skip(from).forEach(result -&gt; &#123;<br>        <span class="hljs-comment">// 4.2获取店铺id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopIdStr</span> <span class="hljs-operator">=</span> result.getContent().getName();<br>        shopIds.add(Long.valueOf(shopIdStr));<br><br>        <span class="hljs-comment">// 4.3获取距离</span><br>        <span class="hljs-type">Distance</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> result.getDistance();<br><br>        map.put(shopIdStr, distance);<br>    &#125;);<br><br>    <span class="hljs-comment">// 5.根据id查询shop</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">joinStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, shopIds);<br>    List&lt;Shop&gt; shops = query().in(<span class="hljs-string">&quot;id&quot;</span>, shopIds).last(<span class="hljs-string">&quot;order by field(id,&quot;</span> + joinStr + <span class="hljs-string">&quot;)&quot;</span>).list();<br>    <span class="hljs-keyword">for</span> (Shop shop : shops) &#123;<br>        shop.setDistance(map.get(shop.getId().toString()).getValue());<br>    &#125;<br><br>    <span class="hljs-comment">// 6.返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(shops);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-签到"><a href="#2-签到" class="headerlink" title="2 签到"></a>2 签到</h1><h2 id="2-1-MySQL实现签到"><a href="#2-1-MySQL实现签到" class="headerlink" title="2.1 MySQL实现签到"></a>2.1 MySQL实现签到</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/8e553025f3df4520a2cc7d1339f1d409.png" alt="在这里插入图片描述"></p><p>缺点：</p><p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p><p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p><h2 id="2-2-优化"><a href="#2-2-优化" class="headerlink" title="2.2 优化"></a>2.2 优化</h2><p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示。</p><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 232个bit位。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/e35598cef7e547e8ab05eae512c65f0d.png" alt="在这里插入图片描述"></p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1,从0开始</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><p>那么，如何完成用户签到？</p><p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/sign&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-keyword">return</span> userService.sign();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> //签到</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br><br>    <span class="hljs-comment">// 3.拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.USER_SIGN_KEY + userId + keySuffix;<br><br>    <span class="hljs-comment">// 4.获取今天是本月的第几天</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br><br>    <span class="hljs-comment">// 5.写入Redis SETBIT key offset 1</span><br>    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-统计连续签到"><a href="#2-3-统计连续签到" class="headerlink" title="2.3 统计连续签到"></a>2.3 统计连续签到</h2><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p><p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p><p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p><p>BITFIELD key GET u[dayOfMonth] 0</p><p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p><p><strong>问题3：</strong>如何从后向前遍历每个bit位？</p><p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/sign/count&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">signCount</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> userService.signCount();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> //合计签到总数</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">signCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br><br>    <span class="hljs-comment">// 3.拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.USER_SIGN_KEY + userId + keySuffix;<br><br>    <span class="hljs-comment">// 4.获取今天是本月的第几天</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br><br>    <span class="hljs-comment">// 5.获取本月截至今天为止所有的签到记录，返回的是一个十进制的数字</span><br>    <span class="hljs-comment">// BITFIELD bm1 GET u2 0</span><br>    List&lt;Long&gt; results = stringRedisTemplate.opsForValue().bitField(<br>            key, BitFieldSubCommands.create()<br>                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth))<br>                    .valueAt(<span class="hljs-number">0</span>)<br>    );<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == results || results.isEmpty()) &#123;<br>        <span class="hljs-comment">// 没有任何签到结果</span><br>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> results.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == num || <span class="hljs-number">0</span> == num) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 6.循环遍历</span><br>    <span class="hljs-comment">// 计数器</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">calCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 7.让这个数字与1做与运算，得到数字的最后一个bit位</span><br>        <span class="hljs-keyword">if</span> ((num &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 判断这个bit位是否为0，如果为0说明未签到，结束</span><br>            <span class="hljs-keyword">break</span>;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果不为0，说明已签到，计数器 + 1</span><br>            calCount++;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 把数字(无符号)右移一位，抛弃最后一个bit位，继续下一个bit位</span><br>        num = (num &gt;&gt;&gt; <span class="hljs-number">1</span>);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> Result.ok(calCount);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-UV统计"><a href="#3-UV统计" class="headerlink" title="3 UV统计"></a>3 UV统计</h1><h2 id="3-1-UV统计的基本思路"><a href="#3-1-UV统计的基本思路" class="headerlink" title="3.1 UV统计的基本思路"></a>3.1 UV统计的基本思路</h2><ul><li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li></ul><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">Hyperloglog算法</a></p><p>Redis中的HLL是基于string结构实现的，单个HLL的内存永远小于16kb，内存占用低的令人发指！作为代价，其测量结果是概率性的，有小于0.81％的误差。不过对于UV统计来说，这完全可以忽略。</p><h2 id="3-2-HypeLogLog实现统计"><a href="#3-2-HypeLogLog实现统计" class="headerlink" title="3.2 HypeLogLog实现统计"></a>3.2 HypeLogLog实现统计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHyperLog</span><span class="hljs-params">()</span> &#123;<br>    String[] values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">1000</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>        j = i % <span class="hljs-number">1000</span>;<br>        values[j] = <span class="hljs-string">&quot;user_&quot;</span> + i;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">999</span>) &#123;<br>            <span class="hljs-comment">// 发送到Redis</span><br>            stringRedisTemplate.opsForHyperLogLog().add(<span class="hljs-string">&quot;hl&quot;</span>, values);<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 统计数量</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForHyperLogLog().size(<span class="hljs-string">&quot;hl&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;统计的总数是：&quot;</span> + count);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>计算出来统计的总数是997593</li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis-探店&amp;关注</title>
    <link href="/redis-%E6%8E%A2%E5%BA%97-%E5%85%B3%E6%B3%A8/47cab89a5a24/"/>
    <url>/redis-%E6%8E%A2%E5%BA%97-%E5%85%B3%E6%B3%A8/47cab89a5a24/</url>
    
    <content type="html"><![CDATA[<h1 id="1-达人探店"><a href="#1-达人探店" class="headerlink" title="1 达人探店"></a>1 达人探店</h1><h2 id="1-1-分享探店图文"><a href="#1-1-分享探店图文" class="headerlink" title="1.1 分享探店图文"></a>1.1 分享探店图文</h2><h3 id="1-1-1-发布探店笔记"><a href="#1-1-1-发布探店笔记" class="headerlink" title="1.1.1 发布探店笔记"></a>1.1.1 发布探店笔记</h3><p>涉及两个数据库表：</p><ul><li>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等</li><li>tb_blog_comments：其他用户对探店笔记的评价</li></ul><p>发布流程：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/b5533c1860f44bf3956b673ff727a4be.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;upload&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br><br>    <span class="hljs-meta">@PostMapping(&quot;blog&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">uploadImage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取原始文件名称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();<br>            <span class="hljs-comment">// 生成新文件名</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> createNewFileName(originalFilename);<br>            <span class="hljs-comment">// 保存文件</span><br>            image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));<br>            <span class="hljs-comment">// 返回结果</span><br>            log.debug(<span class="hljs-string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);<br>            <span class="hljs-keyword">return</span> Result.ok(fileName);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;文件上传失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">IMAGE_UPLOAD_DIR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxxx&quot;</span>;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/blog&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IBlogService blogService;<br><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveBlog</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Blog blog)</span> &#123;<br>        <span class="hljs-comment">//获取登录用户</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>        blog.setUpdateTime(user.getId());<br>        <span class="hljs-comment">//保存探店博文</span><br>        blogService.saveBlog(blog);<br>        <span class="hljs-comment">//返回id</span><br>        <span class="hljs-keyword">return</span> Result.ok(blog.getId());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-1-2-查看探店笔记"><a href="#1-1-2-查看探店笔记" class="headerlink" title="1.1.2 查看探店笔记"></a>1.1.2 查看探店笔记</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/6112d227a59c43dd85cf76245c024656.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/hot&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryHotBlog</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current)</span> &#123;<br>    <span class="hljs-keyword">return</span> blogService.queryHotBlog(current);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> //查看笔记详情页面</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-keyword">return</span> blogService.queryBlogById(id);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;BlogMapper, Blog&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBlogService</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IUserService userService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryHotBlog</span><span class="hljs-params">(Integer current)</span> &#123;<br>        <span class="hljs-comment">// 根据用户查询</span><br>        Page&lt;Blog&gt; page = query()<br>                .orderByDesc(<span class="hljs-string">&quot;liked&quot;</span>)<br>                .page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));<br>        <span class="hljs-comment">// 获取当前页数据</span><br>        List&lt;Blog&gt; records = page.getRecords();<br>        <span class="hljs-comment">// 查询用户</span><br>        records.forEach(<span class="hljs-built_in">this</span>::queryBlogUser);<br>        <span class="hljs-keyword">return</span> Result.ok(records);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //查看笔记详情页面</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-comment">// 1.查询blog</span><br>        <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> getById(id);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == blog) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;笔记不存在!&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 2.查询blog相关的用户</span><br>        queryBlogUser(blog);<br>        <span class="hljs-keyword">return</span> Result.ok(blog);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryBlogUser</span><span class="hljs-params">(Blog blog)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> blog.getUserId();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getById(userId);<br>        blog.setName(user.getNickName());<br>        blog.setIcon(user.getIcon());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1-2-点赞功能"><a href="#1-2-点赞功能" class="headerlink" title="1.2 点赞功能"></a>1.2 点赞功能</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-comment">//修改点赞数量</span><br>    blogService.update().setSql(<span class="hljs-string">&quot;liked = liked +1 &quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这样会有一个问题，一个用户可以多次的点赞</p></blockquote><h3 id="1-2-1-修改"><a href="#1-2-1-修改" class="headerlink" title="1.2.1 修改"></a>1.2.1 修改</h3><ol><li><p>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableField(exist = false)</span><br><span class="hljs-keyword">private</span> Boolean isLike;<br></code></pre></td></tr></table></figure></li><li><p>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</p></li><li><p>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</p></li><li><p>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PutMapping(&quot;/like/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-comment">// 修改点赞数量 update tb_blog set liked = liked where id = ?</span><br>    <span class="hljs-comment">//blogService.update().setSql(&quot;liked = liked + 1&quot;).eq(&quot;id&quot;, id).update();</span><br>    <span class="hljs-keyword">return</span> blogService.likeBlog(id);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;BlogMapper, Blog&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBlogService</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IUserService userService;<br><br>    <span class="hljs-meta">@Resource</span><br>    StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryHotBlog</span><span class="hljs-params">(Integer current)</span> &#123;<br>        <span class="hljs-comment">// 根据用户查询</span><br>        Page&lt;Blog&gt; page = query()<br>                .orderByDesc(<span class="hljs-string">&quot;liked&quot;</span>)<br>                .page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));<br>        <span class="hljs-comment">// 获取当前页数据</span><br>        List&lt;Blog&gt; records = page.getRecords();<br>        <span class="hljs-comment">// 查询用户</span><br>        records.forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;Blog&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Blog blog)</span> &#123;<br>                queryBlogUser(blog);<br>                isBlogLiked(blog);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//records.forEach(this::queryBlogUser);</span><br>        <span class="hljs-keyword">return</span> Result.ok(records);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //查看笔记详情页面</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-comment">// 1.查询blog</span><br>        <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> getById(id);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == blog) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;笔记不存在!&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 2.查询blog相关的用户</span><br>        queryBlogUser(blog);<br>        <span class="hljs-comment">// 3.查询blog是否被点赞</span><br>        isBlogLiked(blog);<br>        <span class="hljs-keyword">return</span> Result.ok(blog);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //当前笔记是否被当前用户点赞</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isBlogLiked</span><span class="hljs-params">(Blog blog)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> blog.getId();<br>        <span class="hljs-comment">// 1.获取当前登录用户</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">// 2.判断当前登录用户是否点赞 key  &quot;blog:liked:&quot; + id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isMember</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> BooleanUtil.isTrue(isMember);<br>        blog.setIsLike(flag);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> // 点赞</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-comment">// 1.获取当前登录用户</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">// 2.判断当前登录用户是否点赞 key  &quot;blog:liked:&quot; + id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isMember</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> BooleanUtil.isTrue(isMember);<br><br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            <span class="hljs-comment">// 3.如果未点赞，可以点赞</span><br>            <span class="hljs-comment">// 3.1数据库点赞数+1</span><br>            <span class="hljs-comment">// 修改点赞数量 update tb_blog set liked = liked where id = ?</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>            <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                <span class="hljs-comment">// 3.2保存用户到Redis的set集合</span><br>                stringRedisTemplate.opsForSet().add(key, userId.toString());<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 4.如果已经点赞，取消点赞</span><br>            <span class="hljs-comment">// 4.1数据库点赞数 -1</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br><br>            <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                <span class="hljs-comment">// 4.2把用户从Redis的set集合移除</span><br>                stringRedisTemplate.opsForSet().remove(key, userId.toString());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryBlogUser</span><span class="hljs-params">(Blog blog)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> blog.getUserId();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getById(userId);<br>        blog.setName(user.getNickName());<br>        blog.setIcon(user.getIcon());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-基于List实现点赞用户列表"><a href="#1-3-基于List实现点赞用户列表" class="headerlink" title="1.3 基于List实现点赞用户列表"></a>1.3 基于List实现点赞用户列表</h2><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p><p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/4e5a3c274c654725b6ad8477171a5c13.png" alt="在这里插入图片描述"></p><h3 id="1-3-1-List-Set-SortedSet对比"><a href="#1-3-1-List-Set-SortedSet对比" class="headerlink" title="1.3.1 List&#x2F;Set&#x2F;SortedSet对比"></a>1.3.1 List&#x2F;Set&#x2F;SortedSet对比</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/d592308328fc46d5a4b4dfe0159cf0e2.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/c584590a6d3145d4a122928ceb96e99d.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;BlogMapper, Blog&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBlogService</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IUserService userService;<br><br>    <span class="hljs-meta">@Resource</span><br>    StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryHotBlog</span><span class="hljs-params">(Integer current)</span> &#123;<br>        <span class="hljs-comment">// 根据用户查询</span><br>        Page&lt;Blog&gt; page = query()<br>                .orderByDesc(<span class="hljs-string">&quot;liked&quot;</span>)<br>                .page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));<br>        <span class="hljs-comment">// 获取当前页数据</span><br>        List&lt;Blog&gt; records = page.getRecords();<br>        <span class="hljs-comment">// 查询用户</span><br>        records.forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;Blog&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Blog blog)</span> &#123;<br>                queryBlogUser(blog);<br>                isBlogLiked(blog);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//records.forEach(this::queryBlogUser);</span><br>        <span class="hljs-keyword">return</span> Result.ok(records);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //查看笔记详情页面</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-comment">// 1.查询blog</span><br>        <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> getById(id);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == blog) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;笔记不存在!&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 2.查询blog相关的用户</span><br>        queryBlogUser(blog);<br>        <span class="hljs-comment">// 3.查询blog是否被点赞</span><br>        isBlogLiked(blog);<br>        <span class="hljs-keyword">return</span> Result.ok(blog);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //当前笔记是否被当前用户点赞(Set)</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isBlogLikedSet</span><span class="hljs-params">(Blog blog)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> blog.getId();<br>        <span class="hljs-comment">// 1.获取当前登录用户</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == userId) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 2.判断当前登录用户是否点赞 key  &quot;blog:liked:&quot; + id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isMember</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> BooleanUtil.isTrue(isMember);<br>        blog.setIsLike(flag);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //当前笔记是否被当前用户点赞(SortedSet)</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isBlogLiked</span><span class="hljs-params">(Blog blog)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> blog.getId();<br>        <span class="hljs-comment">// 1.获取当前登录用户</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == userId) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 2.判断当前登录用户是否点赞 key  &quot;blog:liked:&quot; + id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;<br>        <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());<br>        blog.setIsLike(<span class="hljs-literal">null</span> != score);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> // 点赞(Set集合)</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlogSet</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-comment">// 1.获取当前登录用户</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">// 2.判断当前登录用户是否点赞 key  &quot;blog:liked:&quot; + id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isMember</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> BooleanUtil.isTrue(isMember);<br><br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            <span class="hljs-comment">// 3.如果未点赞，可以点赞</span><br>            <span class="hljs-comment">// 3.1数据库点赞数+1</span><br>            <span class="hljs-comment">// 修改点赞数量 update tb_blog set liked = liked where id = ?</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>            <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                <span class="hljs-comment">// 3.2保存用户到Redis的set集合</span><br>                stringRedisTemplate.opsForSet().add(key, userId.toString());<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 4.如果已经点赞，取消点赞</span><br>            <span class="hljs-comment">// 4.1数据库点赞数 -1</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br><br>            <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                <span class="hljs-comment">// 4.2把用户从Redis的set集合移除</span><br>                stringRedisTemplate.opsForSet().remove(key, userId.toString());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> // 点赞(SortedSet集合)</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-comment">// 1.获取当前登录用户</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">// 2.判断当前登录用户是否点赞 key  &quot;blog:liked:&quot; + id</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;<br>        <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == score) &#123;<br>            <span class="hljs-comment">// 3.如果未点赞，可以点赞</span><br>            <span class="hljs-comment">// 3.1数据库点赞数+1</span><br>            <span class="hljs-comment">// 修改点赞数量 update tb_blog set liked = liked where id = ?</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>            <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                <span class="hljs-comment">// 3.2保存用户到Redis的sortedset集合 zadd key score member</span><br>                stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 4.如果已经点赞，取消点赞</span><br>            <span class="hljs-comment">// 4.1数据库点赞数 -1</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br><br>            <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                <span class="hljs-comment">// 4.2把用户从Redis的set集合移除</span><br>                stringRedisTemplate.opsForZSet().remove(key, userId.toString());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryBlogUser</span><span class="hljs-params">(Blog blog)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> blog.getUserId();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getById(userId);<br>        blog.setName(user.getNickName());<br>        blog.setIcon(user.getIcon());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BlogController.java</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/likes/&#123;id&#125;&quot;</span>)<br>public Result <span class="hljs-built_in">queryBlogLikes</span>(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;id&quot;</span>) Long id) &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">blogService</span><span class="hljs-selector-class">.queryBlogLikes</span>(id);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>BlogServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> //查询点赞列表</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;<br>    <span class="hljs-comment">// 1.查询top5的点赞用户 zrange key 0 4</span><br>    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == top5 || top5.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br><br>    <span class="hljs-comment">// 2.解析出其中的用户id</span><br>    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br><br>    <span class="hljs-comment">// 3.根据用户id查询用户</span><br>    List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids).stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());<br><br>    <span class="hljs-comment">// 4.返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(userDTOS);<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>此时会发现点赞的顺序是反的，问题就出现在了SQL上<br><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/5eac4ff438384024bbf09f1ea6663725.png" alt="在这里插入图片描述"></p><p>那么此时修改SQL即可解决</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tb_user <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> FIELD(id,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3.根据用户id查询用户</span><br><span class="hljs-comment">//List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids).stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br>List&lt;UserDTO&gt; userDTOS = userService.query()<br>        <span class="hljs-comment">// SELECT * FROM tb_user WHERE id IN (&#x27;5&#x27;,&#x27;1&#x27;) ORDER BY FIELD(id,5,1);</span><br>        .in(<span class="hljs-string">&quot;id&quot;</span>, ids)<br>        .last(<span class="hljs-string">&quot;order by field (id,&quot;</span> + idsStr + <span class="hljs-string">&quot;) &quot;</span>).list()<br>        .stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))<br>        .collect(Collectors.toList());<br><br></code></pre></td></tr></table></figure></blockquote><h1 id="2-关注列表"><a href="#2-关注列表" class="headerlink" title="2 关注列表"></a>2 关注列表</h1><h2 id="2-1-添加关注"><a href="#2-1-添加关注" class="headerlink" title="2.1 添加关注"></a>2.1 添加关注</h2><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/ebe0a18a3d604e0a815444f0a591ac1a.png" alt="在这里插入图片描述"></p><p>涉及到数据库表tb_follow：<br><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/d1e397e897934c87818c67b44b717cea.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/follow&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FollowController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IFollowService iFollowService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //关注博主</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="hljs-meta">@PathVariable(&quot;isFollow&quot;)</span> <span class="hljs-type">boolean</span> isFollow)</span> &#123;<br>        <span class="hljs-keyword">return</span> iFollowService.follow(followUserId, isFollow);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //判断是否关注</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;<br>        <span class="hljs-keyword">return</span> iFollowService.isFollow(followUserId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FollowServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;FollowMapper, Follow&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFollowService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //关注</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, <span class="hljs-type">boolean</span> isFollow)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">// 1.判断是关注还是取关</span><br>        <span class="hljs-keyword">if</span> (isFollow) &#123;<br>            <span class="hljs-comment">// 2.关注，新增数据</span><br>            <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>            follow.setFollowUserId(followUserId);<br>            follow.setUserId(userId);<br>            <span class="hljs-comment">// insert into tb_follow values()</span><br>            save(follow);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 3.取关，删除</span><br>            <span class="hljs-comment">// delete from follow where user_id = ? and follow_user_id = ?</span><br>            LambdaQueryWrapper&lt;Follow&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>            remove(wrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //判断是否关注</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(Long followUserId)</span> &#123;<br>        <span class="hljs-comment">// 1.获取用户id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">// 2.查询是否关注 select * from tb_follow where  user_id = ? and follow_user_id = ?</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId).count();<br>        <span class="hljs-keyword">return</span> Result.ok(count &gt; <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-共同关注列表"><a href="#2-2-共同关注列表" class="headerlink" title="2.2 共同关注列表"></a>2.2 共同关注列表</h2><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p><p>1、去查询用户的详情</p><p>2、去查询用户的笔记</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/630737bdbb184d1dac25b2db1d30b4df.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// UserController 根据id查询用户</span><br><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;<br><span class="hljs-comment">// 查询详情</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getById(userId);<br><span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br><span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br><span class="hljs-comment">// 返回</span><br><span class="hljs-keyword">return</span> Result.ok(userDTO);<br>&#125;<br><br><span class="hljs-comment">// BlogController  根据id查询博主的探店笔记</span><br><span class="hljs-meta">@GetMapping(&quot;/of/user&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogByUserId</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span><br><span class="hljs-params"><span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> Long id)</span> &#123;<br><span class="hljs-comment">// 根据用户查询</span><br>Page&lt;Blog&gt; page = blogService.query()<br>.eq(<span class="hljs-string">&quot;user_id&quot;</span>, id).page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));<br><span class="hljs-comment">// 获取当前页数据</span><br>List&lt;Blog&gt; records = page.getRecords();<br><span class="hljs-keyword">return</span> Result.ok(records);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/d0cb2e5f62ab4f9c842e40615ec4a283.png" alt="在这里插入图片描述"></p><p>但是此时点击了之后发现共同关注报错，如何去解决共同关注的问题。模拟场景：A关注了B、C，而D关注了C、E，那么对于A和D来说他们的共同关注就是C，在Redis中可以使用set求交集</p><h3 id="2-2-1-修改"><a href="#2-2-1-修改" class="headerlink" title="2.2.1 修改"></a>2.2.1 修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> //关注</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, <span class="hljs-type">boolean</span> isFollow)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.FOLLOW_USER_LIST + userId;<br>    <span class="hljs-comment">// 1.判断是关注还是取关</span><br>    <span class="hljs-keyword">if</span> (isFollow) &#123;<br>        <span class="hljs-comment">// 2.关注，新增数据</span><br>        <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>        follow.setFollowUserId(followUserId);<br>        follow.setUserId(userId);<br>        <span class="hljs-comment">// insert into tb_follow values()</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(follow);<br><br>        <span class="hljs-comment">// 加入Redis,实现共同关注</span><br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            <span class="hljs-comment">// 把关注用户的id，加入redis的set集合  sadd userId followUserId</span><br>            stringRedisTemplate.opsForSet().add(key, followUserId.toString());<br>        &#125;<br><br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 3.取关，删除</span><br>        <span class="hljs-comment">// delete from follow where user_id = ? and follow_user_id = ?</span><br>        LambdaQueryWrapper&lt;Follow&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> remove(wrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId));<br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            <span class="hljs-comment">// 从Redis中移除,实现取关</span><br>            <span class="hljs-comment">// 把关注用户的id，从redis的set集合中移除  srem userId followUserId</span><br>            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-共同关注"><a href="#2-2-2-共同关注" class="headerlink" title="2.2.2 共同关注"></a>2.2.2 共同关注</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> //查询共同关注</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@GetMapping(&quot;/common/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">followCommons</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-keyword">return</span> iFollowService.followCommons(id);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> //共同关注</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">followCommons</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.FOLLOW_USER_LIST + userId;<br><br>    <span class="hljs-comment">// 目标用户</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keyFollow</span> <span class="hljs-operator">=</span> RedisConstants.FOLLOW_USER_LIST + id;<br><br>    <span class="hljs-comment">// 2.求交集</span><br>    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, keyFollow);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == intersect || intersect.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br><br>    <span class="hljs-comment">// 3.解析id集合</span><br>    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());<br>    List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids)<br>            .stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());<br><br>    <span class="hljs-comment">// 查询用户</span><br>    <span class="hljs-keyword">return</span> Result.ok(userDTOS);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-关注用户发布消息-Feed流"><a href="#2-3-关注用户发布消息-Feed流" class="headerlink" title="2.3 关注用户发布消息-Feed流"></a>2.3 关注用户发布消息-Feed流</h2><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p><p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/d458c8be7fc34397abc1d78e0179521e.png" alt="在这里插入图片描述"></p><p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/f68b671793f44d3f93c8ecec5e386ba7.png" alt="在这里插入图片描述"></p><p>Feed流产品有两种常见模式：<br>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p><p>优点：信息全面，不会有缺失。并且实现也相对简单<br>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低<br>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p><p>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷<br>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</p><ul><li>拉模式</li><li>推模式</li><li>推拉结合</li></ul><h3 id="2-3-1-拉模式-读扩散"><a href="#2-3-1-拉模式-读扩散" class="headerlink" title="2.3.1 拉模式-读扩散"></a>2.3.1 拉模式-读扩散</h3><p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p><p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p><p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p><h3 id="2-3-2-推模式-写扩散"><a href="#2-3-2-推模式-写扩散" class="headerlink" title="2.3.2 推模式-写扩散"></a>2.3.2 推模式-写扩散</h3><p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p><p>优点：时效快，不用临时拉取</p><p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p><h3 id="2-3-3-推拉结合-读写混合"><a href="#2-3-3-推拉结合-读写混合" class="headerlink" title="2.3.3 推拉结合-读写混合"></a>2.3.3 推拉结合-读写混合</h3><p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p><h2 id="2-4-探店推送"><a href="#2-4-探店推送" class="headerlink" title="2.4 探店推送"></a>2.4 探店推送</h2><p>需要实现当关注用户增加一个新的笔记后，能推送到分析收件箱</p><h3 id="2-4-1-分析"><a href="#2-4-1-分析" class="headerlink" title="2.4.1 分析"></a>2.4.1 分析</h3><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><p>传统的分页在feed流是不适用的，因为我们的数据会随时发生变化。</p><p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10 ~ 6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6~2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/5c2f4b732747435e9d69f031efa7aaa3.png" alt="在这里插入图片描述"></p><h3 id="2-4-2-Feed流滚动分页"><a href="#2-4-2-Feed流滚动分页" class="headerlink" title="2.4.2 Feed流滚动分页"></a>2.4.2 Feed流滚动分页</h3><p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p><p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/d4bbb4ac74004ec786f746ada0dbbb68.png" alt="在这里插入图片描述"></p><blockquote><p>即：在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveBlog</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Blog blog)</span> &#123;<br>    <span class="hljs-keyword">return</span> blogService.saveBlog(blog);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> //使用push模式</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveBlog</span><span class="hljs-params">(Blog blog)</span> &#123;<br>    <span class="hljs-comment">// 1.获取登录用户</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br><br>    blog.setUserId(user.getId());<br>    <span class="hljs-comment">// 2.保存探店博文</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(blog);<br>    <span class="hljs-keyword">if</span> (!isSuccess) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;新增笔记失败,请重新发布!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.查询笔记作者的所有粉丝</span><br>    <span class="hljs-comment">// select user_id from tb_follow where follow_user_id = ?</span><br>    LambdaQueryWrapper&lt;Follow&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    wrapper.eq(Follow::getFollowUserId, user.getId());<br>    List&lt;Follow&gt; follows = followService.list(wrapper);<br>    <span class="hljs-comment">// 4.推送笔记id给所有粉丝</span><br>    <span class="hljs-keyword">for</span> (Follow follow : follows) &#123;<br>        <span class="hljs-comment">// 4.1获取粉丝id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">fansId</span> <span class="hljs-operator">=</span> follow.getUserId();<br>        <span class="hljs-comment">// 4.2推送给粉丝</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.FEED_KEY + fansId;<br>        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());<br>    &#125;<br><br><br>    <span class="hljs-comment">// 5.返回id</span><br>    <span class="hljs-keyword">return</span> Result.ok(blog.getId());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-好有关注页分页查询"><a href="#2-5-好有关注页分页查询" class="headerlink" title="2.5 好有关注页分页查询"></a>2.5 好有关注页分页查询</h2><p>在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/f5e417eb93be4b7a931c527cf484dbfa.png" alt="在这里插入图片描述"></p><p>正序：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/b1c97a920dc74be3b5c527ce4c1c8030.png" alt="在这里插入图片描述"></p><p>倒序：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/ad6cd28c982b496fb4c91c80a876458f.png" alt="在这里插入图片描述"></p><p>带分数：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/31c0aa410a2d48b4b3ae54d9da5e971d.png" alt="在这里插入图片描述"></p><p>滚动分页规律：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 第一次</span><br>ZREVRANGEBYSCORE key 设定一个最大值 <span class="hljs-number">0</span> WITHSCORES <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">0</span> 每页展示几条<br><span class="hljs-comment">-- 之后</span><br>ZREVRANGEBYSCORE key 第一条最小的角标 <span class="hljs-number">0</span> WITHSCORES <span class="hljs-keyword">LIMIT</span> 第一页中与最小值相等的元素的个数 每页展示几条<br></code></pre></td></tr></table></figure><h3 id="2-5-1-新增实体类"><a href="#2-5-1-新增实体类" class="headerlink" title="2.5.1 新增实体类"></a>2.5.1 新增实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrollResult</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;?&gt; list;<br>    <span class="hljs-keyword">private</span> Long minTime;<br>    <span class="hljs-keyword">private</span> Integer offset;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/of/follow&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogOfFollow</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="hljs-meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;<br>    <span class="hljs-keyword">return</span> blogService.queryBlogOfFollow(max, offset);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> //滚动分页查询关注列表</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogOfFollow</span><span class="hljs-params">(Long max, Integer offset)</span> &#123;<br>    <span class="hljs-comment">// 1.查询当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.找到收件箱</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.FEED_KEY + userId;<br><br>    <span class="hljs-comment">// 滚动分页查询(第一次查询)</span><br>    <span class="hljs-comment">//ZREVRANGEBYSCORE z1 1000 0 WITHSCORES LIMIT 0 5</span><br>    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; set = stringRedisTemplate<br>            .opsForZSet()<br>            .reverseRangeByScoreWithScores(key, <span class="hljs-number">0</span>, max, offset, <span class="hljs-number">2L</span>);<br><br>    <span class="hljs-comment">// 3.非空判断</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == set || set.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br><br>    <span class="hljs-comment">// 4.解析收件箱的数据:blogId,minTime(时间戳),offset</span><br>    ArrayList&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(set.size());<br>    <span class="hljs-type">long</span> <span class="hljs-variable">minTime</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">off</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : set) &#123;<br>        <span class="hljs-comment">// 4.1获取id</span><br>        ids.add(Long.valueOf(tuple.getValue()));<br>        <span class="hljs-comment">// 4.2 获取分数(时间戳)</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> tuple.getScore().longValue();<br>        <span class="hljs-keyword">if</span> (time == minTime) &#123;<br>            off++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            minTime = minTime &lt; tuple.getScore().longValue() ? minTime : time;<br>            off = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//List&lt;Blog&gt; blogs = listByIds(ids);</span><br>    <span class="hljs-comment">// select * from tb_blog where id in () order by field(id,max,min)</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">joinStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>    <span class="hljs-comment">// 5.根据blogId查询blog</span><br>    List&lt;Blog&gt; blogs = query().in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;order by field(id,&quot;</span> + joinStr + <span class="hljs-string">&quot;)&quot;</span>).list();<br>    <span class="hljs-keyword">for</span> (Blog blog : blogs) &#123;<br>        <span class="hljs-comment">// 2.查询blog相关的用户</span><br>        queryBlogUser(blog);<br>        <span class="hljs-comment">// 3.查询blog是否被点赞</span><br>        isBlogLiked(blog);<br>    &#125;<br><br>    <span class="hljs-comment">// 6.封装并返回</span><br>    <span class="hljs-type">ScrollResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScrollResult</span>();<br>    result.setList(blogs);<br>    result.setOffset(off);<br>    result.setMinTime(minTime);<br><br>    <span class="hljs-keyword">return</span> Result.ok(result);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis-秒杀优化</title>
    <link href="/redis-%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96/fb2025be556d/"/>
    <url>/redis-%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96/fb2025be556d/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Redis实现秒杀优化"><a href="#1-Redis实现秒杀优化" class="headerlink" title="1 Redis实现秒杀优化"></a>1 Redis实现秒杀优化</h1><h2 id="1-1-秒杀流程"><a href="#1-1-秒杀流程" class="headerlink" title="1.1 秒杀流程"></a>1.1 秒杀流程</h2><p>1、查询优惠卷</p><p>2、判断秒杀库存是否足够</p><p>3、查询订单</p><p>4、校验是否是一人一单</p><p>5、扣减库存</p><p>6、创建订单</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/1e4c5e6f63884971b9bc1d26dfe20803.png" alt="在这里插入图片描述"></p><p>在流程上，这是同步操作，即：会按照顺序进行执行，但是这样一个一个执行会有一个很大的缺陷：效率很低。那么是否可以提高效率呢？</p><p>可以：使用异步进行优化。</p><p>将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/7d7263c57bee48f2adbb64fdfd85f57f.png" alt="在这里插入图片描述"></p><p>但是此时会有两个问题：</p><ol><li>怎么在redis中去快速校验一人一单，还有库存判断。</li><li>由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</li></ol><p>针对问题1：</p><p>当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作。</p><p>针对问题2：</p><p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p><h2 id="1-2-流程优化"><a href="#1-2-流程优化" class="headerlink" title="1.2 流程优化"></a>1.2 流程优化</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/6327c7cc9c8e430f8914819371d115aa.png" alt="在这里插入图片描述"></p><h3 id="1-2-1-优惠券添加至Redis"><a href="#1-2-1-优惠券添加至Redis" class="headerlink" title="1.2.1 优惠券添加至Redis"></a>1.2.1 优惠券添加至Redis</h3><blockquote><p>在添加秒杀优惠券的时候，将优惠券id和个数添加至redis中</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;VoucherMapper, Voucher&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoucherService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ISeckillVoucherService seckillVoucherService;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryVoucherOfShop</span><span class="hljs-params">(Long shopId)</span> &#123;<br>        <span class="hljs-comment">// 查询优惠券信息</span><br>        List&lt;Voucher&gt; vouchers = getBaseMapper().queryVoucherOfShop(shopId);<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> Result.ok(vouchers);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional(rollbackFor = &#123;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(Voucher voucher)</span> &#123;<br>        <span class="hljs-comment">// 保存优惠券</span><br>        save(voucher);<br>        <span class="hljs-comment">// 保存秒杀信息</span><br>        <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeckillVoucher</span>();<br>        seckillVoucher.setVoucherId(voucher.getId());<br>        seckillVoucher.setStock(voucher.getStock());<br>        seckillVoucher.setBeginTime(voucher.getBeginTime());<br>        seckillVoucher.setEndTime(voucher.getEndTime());<br>        seckillVoucherService.save(seckillVoucher);<br><br>        <span class="hljs-comment">// 保存秒杀库存到Redis中(永久保存即可)</span><br>        <span class="hljs-comment">// key   seckill:stock: + voucherId</span><br>        <span class="hljs-comment">// value 库存</span><br>        stringRedisTemplate.opsForValue().set(RedisConstants.SECKILL_STOCK_KEY + voucher.getId(), seckillVoucher.getStock().toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-2-Lua脚本"><a href="#1-2-2-Lua脚本" class="headerlink" title="1.2.2 Lua脚本"></a>1.2.2 Lua脚本</h3><p>Lua脚本用来保证下单的时候不会超卖和一人一单，原子化操作放在同一个脚本中。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 1.参数列表</span><br><span class="hljs-comment">-- 1.1优惠券id</span><br><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 1.2用户id</span><br><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<br><br><span class="hljs-comment">-- 2.数据key</span><br><span class="hljs-comment">-- 2.1 库存key</span><br><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<br><span class="hljs-comment">-- 2.2 订单key</span><br><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order:&#x27;</span> .. voucherId<br><br><span class="hljs-comment">-- 3.脚本业务</span><br><span class="hljs-comment">-- 3.1 判断库存是否充足 get stockKet</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 库存不足返回1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.2 判断用户是否下单 SISMEMBER orderKey userId</span><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.3 存在，说明重复下单</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.4 扣库存 incrby stockKey -1</span><br>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, <span class="hljs-number">-1</span>)<br><span class="hljs-comment">-- 3.5 下单 (保存用户) sadd orderKey userId</span><br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="1-2-3-添加异步阻塞队列"><a href="#1-2-3-添加异步阻塞队列" class="headerlink" title="1.2.3 添加异步阻塞队列"></a>1.2.3 添加异步阻塞队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoucherOrderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ISeckillVoucherService iSeckillVoucherService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisWorker redisWorker;<br><br>    <span class="hljs-meta">@Resource</span><br>    StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        SECKILL_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        SECKILL_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;seckill.lua&quot;</span>));<br>        SECKILL_SCRIPT.setResultType(Long.class);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 阻塞队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; blockingQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程池</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">fixedThreadPool</span> <span class="hljs-operator">=</span> CacheClient.newFixedThreadPool(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">private</span> IVoucherOrderService proxy;<br><br>    <span class="hljs-comment">// 保证一加载就执行该方法</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        fixedThreadPool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 1.获取队列中的订单信息 take是阻塞方法，获取队列头部，如果需要则等待直到元素可用</span><br>                        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> blockingQueue.take();<br>                        <span class="hljs-comment">// 2.创建订单</span><br>                        handleVoucherOrder(voucherOrder);<br><br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        log.error(<span class="hljs-string">&quot;处理订单异常:&quot;</span> + e.getMessage());<br>                    &#125;<br><br><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>                <span class="hljs-comment">// 1.创建锁对象</span><br>                <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>                <span class="hljs-comment">// 2.创建锁对象</span><br>                <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(RedisConstants.LOCK_VOUVHER_ORDER_KEY + userId);<br>                <span class="hljs-comment">// 3.获取锁</span><br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> lock.tryLock();<br>                <span class="hljs-comment">// 4.判断锁是否获取成功</span><br>                <span class="hljs-keyword">if</span> (!flag) &#123;<br>                    <span class="hljs-comment">// 4.1 获取锁失败</span><br>                    log.error(<span class="hljs-string">&quot;不允许重复下单！&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    proxy.createVoucherOrderThread(voucherOrder);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">// 1. 执行Lua脚本</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(<br>                SECKILL_SCRIPT,<br>                Collections.emptyList(),<br>                voucherId.toString(),<br>                userId.toString()<br>        );<br><br>        <span class="hljs-comment">// 2.判断结果是否为0</span><br>        <span class="hljs-keyword">if</span> (result.intValue() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 2.1 不为0 说明没有购买资格</span><br>            <span class="hljs-keyword">return</span> Result.fail(result == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;优惠券已售罄，感谢参与！&quot;</span> : <span class="hljs-string">&quot;您已经购买过该优惠券，优惠券限制每人仅购买一次！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 2.2 为0 说明 存在购买资格，把下单信息保存到阻塞队列中</span><br>        <span class="hljs-comment">// 订单ID</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisWorker.nextID(RedisConstants.VOUVHER_ORDER_KEY);<br>        <span class="hljs-comment">// 2.3 保存到阻塞队列 优惠券ID 用户ID 订单ID</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        voucherOrder.setVoucherId(voucherId);<br>        voucherOrder.setUserId(userId);<br>        voucherOrder.setId(orderId);<br><br>        <span class="hljs-comment">// 2.4获取代理对象(事务)</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> AopContext.currentProxy();<br>        <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) o;<br><br>        <span class="hljs-comment">// 2.5 放入阻塞队列</span><br>        blockingQueue.add(voucherOrder);<br><br><br>        <span class="hljs-comment">// 3.返回订单信息</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional(rollbackFor = &#123;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createVoucherOrderThread</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userID</span> <span class="hljs-operator">=</span> voucherOrder.getId();<br><br><br>        <span class="hljs-comment">// 5.实现1人1单加入逻辑：根据优惠券id和用户id查询订单</span><br>        <span class="hljs-comment">// 5.1查询订单,并不用查询出具体的值，而是查询出数量即可</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userID).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();<br>        <span class="hljs-comment">// 5.2判断订单是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 5.2.1 存在就返回异常结果</span><br>            log.error(<span class="hljs-string">&quot;秒杀优惠券每人限购1张,感谢配合,本优惠券最终解释权归ty公司所有!&quot;</span>);<br>            <span class="hljs-comment">//return Result.fail(&quot;秒杀优惠券每人限购1张,感谢配合,本优惠券最终解释权归ty公司所有!&quot;);</span><br>        &#125;<br><br>        <span class="hljs-comment">// 5.2.2 不存在再减少库存</span><br><br>        <span class="hljs-comment">// 6.1扣减库存(会出现超卖问题)</span><br>        <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ?</span><br>        <span class="hljs-comment">/*boolean result = iSeckillVoucherService.update()</span><br><span class="hljs-comment">                .setSql(&quot;stock = stock -1&quot;)</span><br><span class="hljs-comment">                .eq(&quot;voucher_id&quot;, voucherId).update();*/</span><br><br>        <span class="hljs-comment">// 6.2扣减库存(针对超卖问题用乐观锁CAS解决)</span><br>        <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ? and stock = ?</span><br>        <span class="hljs-comment">/*boolean result = iSeckillVoucherService.update()</span><br><span class="hljs-comment">                .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="hljs-comment">                .eq(&quot;voucher_id&quot;, voucherId)</span><br><span class="hljs-comment">                .eq(&quot;stock&quot;, stock)</span><br><span class="hljs-comment">                .update();*/</span><br><br>        <span class="hljs-comment">// 6.3扣减库存(针对使用乐观锁CAS，没卖完解决)</span><br>        <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ? and stock &gt; 0</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> iSeckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId())<br>                .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>                .update();<br><br>        <span class="hljs-keyword">if</span> (!result) &#123;<br>            log.error(<span class="hljs-string">&quot;商品已经售罄!&quot;</span>);<br>            <span class="hljs-comment">//return Result.fail(&quot;商品已经售罄!&quot;);</span><br>        &#125;<br><br>        <span class="hljs-comment">// 7.创建订单</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取订单id</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisWorker.nextID(RedisConstants.VOUVHER_ORDER_KEY);<br><br>        <span class="hljs-comment">// 将订单信息保存到数据库</span><br>        <span class="hljs-comment">// insert into tb_voucher_order values ()</span><br>        save(voucherOrder);<br><br>        <span class="hljs-comment">//8.返回订单id</span><br>        <span class="hljs-comment">//return Result.ok(orderId);</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1-3-基于阻塞队列存在的问题"><a href="#1-3-基于阻塞队列存在的问题" class="headerlink" title="1.3 基于阻塞队列存在的问题"></a>1.3 基于阻塞队列存在的问题</h2><ol><li>内存限制问题</li><li>数据安全问题</li></ol><h1 id="2-秒杀的异步优化"><a href="#2-秒杀的异步优化" class="headerlink" title="2 秒杀的异步优化"></a>2 秒杀的异步优化</h1><h2 id="2-1-Redis的消息队列"><a href="#2-1-Redis的消息队列" class="headerlink" title="2.1 Redis的消息队列"></a>2.1 Redis的消息队列</h2><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/2c0469d2897240ca9f1cad49aa492c14.png" alt="在这里插入图片描述"></p><h3 id="2-1-1-基于List结构的消息队列"><a href="#2-1-1-基于List结构的消息队列" class="headerlink" title="2.1.1 基于List结构的消息队列"></a>2.1.1 基于List结构的消息队列</h3><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/08a71cbcf388440c96c7c62c4b8cd6ea.png" alt="在这里插入图片描述"></p><p>优点：</p><ul><li>利用Redis存储，<strong>不受限</strong>于JVM<strong>内存</strong>上限</li><li>基于Redis的<strong>持久化</strong>机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li><strong>无法避免消息丢失</strong></li><li>只支持<strong>单消费者</strong></li></ul><h3 id="2-1-2-基于PubSub的消息队列"><a href="#2-1-2-基于PubSub的消息队列" class="headerlink" title="2.1.2 基于PubSub的消息队列"></a>2.1.2 基于PubSub的消息队列</h3><p>PubSub（发布publish订阅subscribe）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p>SUBSCRIBE channel [channel] ：订阅一个或多个频道<br>PUBLISH channel msg ：向一个频道发送消息<br>PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p><blockquote><p>[注]pattern:通配符</p><p>? 一个字符<br>*0个或者多个<br>[ab]a或者b</p></blockquote><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/5dd860483d1c485a9496b15bbf13c8f7.png" alt="在这里插入图片描述"></p><p>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，<strong>超出时数据丢失</strong></li></ul><h3 id="2-1-3-基于stream的消息队列"><a href="#2-1-3-基于stream的消息队列" class="headerlink" title="2.1.3 基于stream的消息队列"></a>2.1.3 基于stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><h4 id="2-1-3-1-发送消息"><a href="#2-1-3-1-发送消息" class="headerlink" title="2.1.3.1 发送消息"></a>2.1.3.1 发送消息</h4><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/bccca7480df045bfb8c3a6e49eb86b4a.png" alt="在这里插入图片描述"></p><blockquote><p>XADD<br>key – 键值<br>NOMKSTREAM – 如果队列不存在，是否开启创建队列，默认是创建队列<br>MAXLEN – 最大消息数量<br>ID – 消息的唯一id，如果设置*代表Redis自动生成,格式是”时间戳-递增数字”<br>field – 消息体<br>value – 消息值</p></blockquote><h4 id="2-1-3-2-读取消息"><a href="#2-1-3-2-读取消息" class="headerlink" title="2.1.3.2 读取消息"></a>2.1.3.2 读取消息</h4><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/749c22c23c814806af8191a13733f24a.png" alt="在这里插入图片描述"></p><blockquote><p>XREAD<br>count – 每次读取消息的最大数量<br>block – 当前没有消息时，是否阻塞，阻塞时长，0是永久等待<br>streams keys – 要从哪个队列中读取消息，key是队列名<br>ID – 起始id，只返回大于该ID的消息，其中0代表第一条纤细，$代表最新的消息。</p></blockquote><p>阻塞读取</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/93509c89537647759e84b5a9fcac807c.png" alt="在这里插入图片描述"></p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h4 id="2-1-3-3-stream消费者组模式"><a href="#2-1-3-3-stream消费者组模式" class="headerlink" title="2.1.3.3 stream消费者组模式"></a>2.1.3.3 stream消费者组模式</h4><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/853f7f45bfd54e8ea3d06f256436439d.png" alt="在这里插入图片描述"></p><h5 id="2-1-3-3-1-创建消费者组"><a href="#2-1-3-3-1-创建消费者组" class="headerlink" title="2.1.3.3.1 创建消费者组"></a>2.1.3.3.1 创建消费者组</h5><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/84267bf83cf848adbcb85af1350bb7df.png" alt="在这里插入图片描述"></p><blockquote><p>key：队列名称。<br>groupName：消费者组名称。<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息。<br>MKSTREAM：队列不存在时自动创建队列。</p></blockquote><h5 id="2-1-3-3-2-消费者组读取消息"><a href="#2-1-3-3-2-消费者组读取消息" class="headerlink" title="2.1.3.3.2 消费者组读取消息"></a>2.1.3.3.2 消费者组读取消息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...] &gt;<br></code></pre></td></tr></table></figure><blockquote><p>group：消费组名称<br>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者<br>count：本次查询的最大数量<br>BLOCK milliseconds：当没有消息时最长等待时间<br>NOACK：无需手动ACK，获取到消息后自动确认<br>STREAMS key：指定队列名称<br>ID：获取消息的起始ID：<br>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第1个消息开始。</p></blockquote><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><h3 id="2-1-4-对比"><a href="#2-1-4-对比" class="headerlink" title="2.1.4 对比"></a>2.1.4 对比</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/09c07cdce23144ef9565a8a72937a048.png" alt="在这里插入图片描述"></p><h2 id="2-2-使用Stream消息队列优化异步秒杀"><a href="#2-2-使用Stream消息队列优化异步秒杀" class="headerlink" title="2.2 使用Stream消息队列优化异步秒杀"></a>2.2 使用Stream消息队列优化异步秒杀</h2><h3 id="2-2-1-创建消息队列"><a href="#2-2-1-创建消息队列" class="headerlink" title="2.2.1 创建消息队列"></a>2.2.1 创建消息队列</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">XGROUP CREATE stream.orders g1 0 MKSTREAM<br></code></pre></td></tr></table></figure><h3 id="2-2-2-修改lua脚本"><a href="#2-2-2-修改lua脚本" class="headerlink" title="2.2.2 修改lua脚本"></a>2.2.2 修改lua脚本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">-- <span class="hljs-number">1.</span>参数列表<br>-- <span class="hljs-number">1.1</span>优惠券id<br><span class="hljs-type">local</span> <span class="hljs-variable">voucherId</span> <span class="hljs-operator">=</span> ARGV[<span class="hljs-number">1</span>]<br>-- <span class="hljs-number">1.2</span>用户id<br><span class="hljs-type">local</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> ARGV[<span class="hljs-number">2</span>]<br>-- <span class="hljs-number">1.3</span>订单id<br><span class="hljs-type">local</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> ARGV[<span class="hljs-number">3</span>]<br><br>-- <span class="hljs-number">2.</span>数据key<br>-- <span class="hljs-number">2.1</span> 库存key<br><span class="hljs-type">local</span> <span class="hljs-variable">stockKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<br>-- <span class="hljs-number">2.2</span> 订单key<br><span class="hljs-type">local</span> <span class="hljs-variable">orderKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;seckill:order:&#x27;</span> .. voucherId<br><br>-- <span class="hljs-number">3.</span>脚本业务<br>-- <span class="hljs-number">3.1</span> 判断库存是否充足 get stockKet<br><span class="hljs-title function_">if</span> <span class="hljs-params">(tonumber(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)</span>) &lt;= <span class="hljs-number">0</span>) then<br>    -- 库存不足返回<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>end<br>-- <span class="hljs-number">3.2</span> 判断用户是否下单 SISMEMBER orderKey userId<br><span class="hljs-title function_">if</span> <span class="hljs-params">(redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId)</span> == <span class="hljs-number">1</span>) then<br>    -- <span class="hljs-number">3.3</span> 存在，说明重复下单<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>end<br>-- <span class="hljs-number">3.4</span> 扣库存 incrby stockKey -<span class="hljs-number">1</span><br>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, -<span class="hljs-number">1</span>)<br>-- <span class="hljs-number">3.5</span> 下单 (保存用户) sadd orderKey userId<br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br>-- <span class="hljs-number">3.6</span> 发送到消息队列中 VoucherOrder实体类中主键就叫id，所以这里也是id,不要叫orderId<br>redis.call(<span class="hljs-string">&#x27;xadd&#x27;</span>, <span class="hljs-string">&#x27;stream.orders&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;userId&#x27;</span>, userId, <span class="hljs-string">&#x27;id&#x27;</span>, orderId, <span class="hljs-string">&#x27;voucherId&#x27;</span>, voucherId)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>即：每次下单保存了用户之后，还需要将消息发送至消息队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoucherOrderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ISeckillVoucherService iSeckillVoucherService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisWorker redisWorker;<br><br>    <span class="hljs-meta">@Resource</span><br>    StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        SECKILL_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        SECKILL_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;seckill.lua&quot;</span>));<br>        SECKILL_SCRIPT.setResultType(Long.class);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 阻塞队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; blockingQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br><br><br>    <span class="hljs-keyword">private</span> IVoucherOrderService proxy;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程池</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> CacheClient.newFixedThreadPool(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@PostConstruct</span> 保证一加载就执行该方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//异步处理线程池</span><br>        executorService.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrderHandler</span>());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> wty</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> // 成员内部类</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> RedisConstants.STREAM_QUEUE_NAME;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 1.获取队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.order &gt;</span><br>                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(<br>                            Consumer.from(<span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>),<br>                            StreamReadOptions.empty().count(<span class="hljs-number">1</span>).block(Duration.ofSeconds(<span class="hljs-number">2L</span>)),<br>                            StreamOffset.create(queueName, ReadOffset.lastConsumed())<br>                    );<br><br>                    <span class="hljs-comment">// 2.判断消息获取是否成功</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == list || list.isEmpty()) &#123;<br>                        <span class="hljs-comment">// 2.1如果获取失败，说明没有消息，继续下一次循环</span><br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 3.解析list</span><br>                    MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="hljs-number">0</span>);<br>                    Map&lt;Object, Object&gt; map = record.getValue();<br>                    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>(), <span class="hljs-literal">true</span>);<br><br>                    <span class="hljs-comment">// 4.如果获取成功，可以下单创建订单</span><br>                    handleVoucherOrder(voucherOrder);<br>                    <span class="hljs-comment">// 5.ACK确认 队列名 组名 消息ID SACK stream.order g1 消息id</span><br>                    stringRedisTemplate.opsForStream().acknowledge(queueName, <span class="hljs-string">&quot;g1&quot;</span>, record.getId());<br><br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    log.error(<span class="hljs-string">&quot;处理订单异常:&quot;</span> + e);<br>                    handlePendingList();<br>                &#125;<br><br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //处理PendingList中的消息</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlePendingList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> RedisConstants.STREAM_QUEUE_NAME;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 1.获取队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 STREAMS stream.order 0</span><br>                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(<br>                        Consumer.from(<span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>),<br>                        StreamReadOptions.empty().count(<span class="hljs-number">1</span>),<br>                        StreamOffset.create(queueName, ReadOffset.from(<span class="hljs-string">&quot;0&quot;</span>))<br>                );<br><br>                <span class="hljs-comment">// 2.判断消息获取是否成功</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == list || list.isEmpty()) &#123;<br>                    <span class="hljs-comment">// 2.1如果获取失败，说明没有消息，结束循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 3.解析list</span><br>                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="hljs-number">0</span>);<br>                Map&lt;Object, Object&gt; map = record.getValue();<br>                <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>(), <span class="hljs-literal">true</span>);<br><br>                <span class="hljs-comment">// 4.如果获取成功，可以下单创建订单</span><br>                handleVoucherOrder(voucherOrder);<br>                <span class="hljs-comment">// 5.ACK确认 队列名 组名 消息ID SACK stream.order g1 消息id</span><br>                stringRedisTemplate.opsForStream().acknowledge(queueName, <span class="hljs-string">&quot;g1&quot;</span>, record.getId());<br><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理PendingList订单异常:&quot;</span> + e);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">20</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>                    ex.printStackTrace();<br>                &#125;<br>            &#125;<br><br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //处理订单</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>        <span class="hljs-comment">// 1.创建锁对象</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>        <span class="hljs-comment">// 2.创建锁对象</span><br>        <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(RedisConstants.LOCK_VOUVHER_ORDER_KEY + userId);<br>        <span class="hljs-comment">// 3.获取锁</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> lock.tryLock();<br>        <span class="hljs-comment">// 4.判断锁是否获取成功</span><br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            <span class="hljs-comment">// 4.1 获取锁失败</span><br>            log.error(<span class="hljs-string">&quot;不允许重复下单！&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            proxy.createVoucherOrderThread(voucherOrder);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> // 秒杀优惠券(消息队列+优化Lua脚本)</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-comment">// 用户ID</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">// 订单ID</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisWorker.nextID(RedisConstants.VOUVHER_ORDER_KEY);<br>        <span class="hljs-comment">// 1. 执行Lua脚本</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(<br>                SECKILL_SCRIPT,<br>                Collections.emptyList(),<br>                voucherId.toString(),<br>                userId.toString(),<br>                String.valueOf(orderId)<br>        );<br><br>        <span class="hljs-comment">// 2.判断结果是否为0</span><br>        <span class="hljs-keyword">if</span> (result.intValue() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 2.1 不为0 说明没有购买资格</span><br>            <span class="hljs-keyword">return</span> Result.fail(result == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;优惠券已售罄，感谢参与！&quot;</span> : <span class="hljs-string">&quot;您已经购买过该优惠券，优惠券限制每人仅购买一次！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 3.获取代理对象(事务)</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> AopContext.currentProxy();<br>        proxy = (IVoucherOrderService) o;<br><br><br>        <span class="hljs-comment">// 4.返回订单信息</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //根据优惠券id和用户id查询订单 减少库存生成订单(方法废弃)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>: voucherId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span> 2023/2/15 22:12</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> wty</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userID</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><br>        <span class="hljs-comment">// 5.实现1人1单加入逻辑：根据优惠券id和用户id查询订单</span><br>        <span class="hljs-comment">// 5.1查询订单,并不用查询出具体的值，而是查询出数量即可</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userID).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>        <span class="hljs-comment">// 5.2判断订单是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 5.2.1 存在就返回异常结果</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀优惠券每人限购1张,感谢配合,本优惠券最终解释权归ty公司所有!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 5.2.2 不存在再减少库存</span><br><br>        <span class="hljs-comment">// 6.1扣减库存(会出现超卖问题)</span><br>        <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ?</span><br>        <span class="hljs-comment">/*boolean result = iSeckillVoucherService.update()</span><br><span class="hljs-comment">                .setSql(&quot;stock = stock -1&quot;)</span><br><span class="hljs-comment">                .eq(&quot;voucher_id&quot;, voucherId).update();*/</span><br><br>        <span class="hljs-comment">// 6.2扣减库存(针对超卖问题用乐观锁CAS解决)</span><br>        <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ? and stock = ?</span><br>        <span class="hljs-comment">/*boolean result = iSeckillVoucherService.update()</span><br><span class="hljs-comment">                .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="hljs-comment">                .eq(&quot;voucher_id&quot;, voucherId)</span><br><span class="hljs-comment">                .eq(&quot;stock&quot;, stock)</span><br><span class="hljs-comment">                .update();*/</span><br><br>        <span class="hljs-comment">// 6.3扣减库存(针对使用乐观锁CAS，没卖完解决)</span><br>        <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ? and stock &gt; 0</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> iSeckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>                .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>                .update();<br><br>        <span class="hljs-keyword">if</span> (!result) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;商品已经售罄!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 7.创建订单</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取订单id</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisWorker.nextID(RedisConstants.VOUVHER_ORDER_KEY);<br><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        voucherOrder.setId(orderId);<br>        voucherOrder.setVoucherId(voucherId);<br>        voucherOrder.setUserId(userID);<br><br>        <span class="hljs-comment">// 将订单信息保存到数据库</span><br>        <span class="hljs-comment">// insert into tb_voucher_order values ()</span><br>        save(voucherOrder);<br><br>        <span class="hljs-comment">//8.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reids-分布式锁</title>
    <link href="/reids-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/62a2e5871819/"/>
    <url>/reids-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/62a2e5871819/</url>
    
    <content type="html"><![CDATA[<h1 id="1-分布式锁"><a href="#1-分布式锁" class="headerlink" title="1 分布式锁"></a>1 分布式锁</h1><p>在之前分析过，集群模式下的一人一单存在问题，其根源就在锁监视器上。因此需要一个分布式锁，满足<strong>分布式系统</strong>或<strong>集群</strong>模式下多进程可见并且<strong>互斥</strong>的锁。</p><p>核心思想：让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/cc2afb0cee29412091e3544bb74229ee.png" alt="在这里插入图片描述"></p><h2 id="1-1-分布式要求"><a href="#1-1-分布式要求" class="headerlink" title="1.1 分布式要求"></a>1.1 分布式要求</h2><ul><li><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p></li><li><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p></li><li><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p></li><li><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p></li><li><p>安全性：安全也是程序中必不可少的一环</p></li></ul><h2 id="1-2-常见的分布式锁"><a href="#1-2-常见的分布式锁" class="headerlink" title="1.2 常见的分布式锁"></a>1.2 常见的分布式锁</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/49ff52e8ebed4ec685048ca0b6661eb9.png" alt="在这里插入图片描述"></p><h2 id="1-3-redis实现分布式锁"><a href="#1-3-redis实现分布式锁" class="headerlink" title="1.3 redis实现分布式锁"></a>1.3 redis实现分布式锁</h2><ol><li>获取锁：要求确保当前只能有一个线程获取到锁。（set key value ex ttl nx ）利用set nx的特性保证只能有一个获取线程</li><li>释放锁：要求可以手动释放，也要有超时释放做兜底。（del key）</li></ol><h2 id="1-4-加锁"><a href="#1-4-加锁" class="headerlink" title="1.4 加锁"></a>1.4 加锁</h2><p>增加一个接口：ILock.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hmdp.lock;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILock</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean true获取锁成功，false获取锁失败</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //获取尝试锁</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>: expireTime 锁持有的超时时间，过期后自动释放</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> expireTime)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //释放锁</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unLock</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁前缀</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义锁的名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String lockName;<br><br>    StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String lockName, StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lockName = lockName;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> expireTime)</span> &#123;<br>        <span class="hljs-comment">// 获取当前线程的标识</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-comment">// set key &quot;1&quot; ex expireTime nx</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>                .setIfAbsent(KEY_PREFIX + lockName, threadId + <span class="hljs-string">&quot;&quot;</span>, expireTime, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unLock</span><span class="hljs-params">()</span> &#123;<br>        stringRedisTemplate.delete(KEY_PREFIX + lockName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改VoucherOrderServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoucherOrderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ISeckillVoucherService iSeckillVoucherService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisWorker redisWorker;<br><br>    <span class="hljs-meta">@Resource</span><br>    StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //秒杀优惠券</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>: voucherId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span> 2023/2/15 22:09</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> wty</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-comment">// 1.查询秒杀优惠券信息</span><br>        <span class="hljs-comment">// select * from tb_seckill_voucher where voucher_id = ?</span><br>        <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> iSeckillVoucherService.getById(voucherId);<br><br>        <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">beginTime</span> <span class="hljs-operator">=</span> seckillVoucher.getBeginTime();<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> seckillVoucher.getEndTime();<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><br>        <span class="hljs-keyword">if</span> (now.isBefore(beginTime)) &#123;<br>            <span class="hljs-comment">// 当前时间早于秒杀开始时间，说明秒杀没有开始</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始,请耐心等待！秒杀开始时间:&quot;</span> + beginTime.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));<br>        &#125;<br>        <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>        <span class="hljs-keyword">if</span> (now.isAfter(endTime)) &#123;<br>            <span class="hljs-comment">// 当前时间晚于秒杀结束时间，说明秒杀结束了</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束,感谢支持!&quot;</span>);<br>        &#125;<br><br><br>        <span class="hljs-comment">// 4.判断库存是否充足</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> seckillVoucher.getStock();<br>        <span class="hljs-keyword">if</span> (stock &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;商品已经售罄!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 实现一人一单，获取user对象锁</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userID</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">/*// 使用JDK提供的锁监视器synchronized来实现</span><br><span class="hljs-comment">        synchronized (userID.toString().intern()) &#123;</span><br><span class="hljs-comment">            // 调用本类方法的时候，Spring事务是失效的，解决方案二：调用AopContext API</span><br><span class="hljs-comment">            Object o = AopContext.currentProxy();</span><br><span class="hljs-comment">            IVoucherOrderService proxy = (IVoucherOrderService) o;</span><br><span class="hljs-comment">            return proxy.createVoucherOrder(voucherId);</span><br><span class="hljs-comment">        &#125;*/</span><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>修改的地方 尝试自定义锁监视器</span><br>        <span class="hljs-type">SimpleRedisLock</span> <span class="hljs-variable">simpleRedisLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + userID.toString().intern(), stringRedisTemplate);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> simpleRedisLock.tryLock(RedisConstants.LOCK_VOUVHER_ORDER_TTL);<br>      <br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            <span class="hljs-comment">// 获取锁失败,就直接返回错误信息即可</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;[秒杀优惠券]不允许重复下单!本秒杀业务一切解释器归ty公司所有&quot;</span>);<br>        &#125;<br><br>        Result result;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> AopContext.currentProxy();<br>            <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) o;<br>            <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            simpleRedisLock.unLock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> com.hmdp.dto.Result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //根据优惠券id和用户id查询订单 减少库存生成订单</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>: voucherId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span> 2023/2/15 22:12</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> wty</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userID</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><br>        <span class="hljs-comment">// 5.实现1人1单加入逻辑：根据优惠券id和用户id查询订单</span><br>        <span class="hljs-comment">// 5.1查询订单,并不用查询出具体的值，而是查询出数量即可</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userID).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>        <span class="hljs-comment">// 5.2判断订单是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 5.2.1 存在就返回异常结果</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀优惠券每人限购1张,感谢配合,本优惠券最终解释权归ty公司所有!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 5.2.2 不存在再减少库存</span><br><br>        <span class="hljs-comment">// 6.1扣减库存(会出现超卖问题)</span><br>        <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ?</span><br>        <span class="hljs-comment">/*boolean result = iSeckillVoucherService.update()</span><br><span class="hljs-comment">                .setSql(&quot;stock = stock -1&quot;)</span><br><span class="hljs-comment">                .eq(&quot;voucher_id&quot;, voucherId).update();*/</span><br><br>        <span class="hljs-comment">// 6.2扣减库存(针对超卖问题用乐观锁CAS解决)</span><br>        <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ? and stock = ?</span><br>        <span class="hljs-comment">/*boolean result = iSeckillVoucherService.update()</span><br><span class="hljs-comment">                .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="hljs-comment">                .eq(&quot;voucher_id&quot;, voucherId)</span><br><span class="hljs-comment">                .eq(&quot;stock&quot;, stock)</span><br><span class="hljs-comment">                .update();*/</span><br><br>        <span class="hljs-comment">// 6.3扣减库存(针对使用乐观锁CAS，没卖完解决)</span><br>        <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ? and stock &gt; 0</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> iSeckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>                .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>                .update();<br><br>        <span class="hljs-keyword">if</span> (!result) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;商品已经售罄!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 7.创建订单</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取订单id</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisWorker.nextID(<span class="hljs-string">&quot;order&quot;</span>);<br><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        voucherOrder.setId(orderId);<br>        voucherOrder.setVoucherId(voucherId);<br>        voucherOrder.setUserId(userID);<br><br>        <span class="hljs-comment">// 将订单信息保存到数据库</span><br>        <span class="hljs-comment">// insert into tb_voucher_order values ()</span><br>        save(voucherOrder);<br><br>        <span class="hljs-comment">//8.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-6-锁误删问题"><a href="#1-6-锁误删问题" class="headerlink" title="1.6 锁误删问题"></a>1.6 锁误删问题</h2><h3 id="1-6-1-介绍"><a href="#1-6-1-介绍" class="headerlink" title="1.6.1 介绍"></a>1.6.1 介绍</h3><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放。</p><p>这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/f7653066583248bfa31dc22d0d0d28ad.png" alt="img"></p><h3 id="1-6-2-解决方案"><a href="#1-6-2-解决方案" class="headerlink" title="1.6.2 解决方案"></a>1.6.2 解决方案</h3><p>在获取锁之前，增加一个标识，每次删除锁的时候，判断当前的锁是否属于自己，属于自己就删除，不属于自己就不删除。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/4faba0a102f848dda0e705cb7db88dda.png" alt="在这里插入图片描述"></p><p>步骤：</p><ol><li>在获取锁时存入线程标示（可以用UUID表示）</li><li>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</li></ol><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/7775969edfce41b382998626f005e5b1.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁前缀</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程ID前缀</span><br><span class="hljs-comment">     * true是可以把UUID中的横线去掉</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">THREAD_ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义锁的名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String lockName;<br><br>    StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String lockName, StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lockName = lockName;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> // 获取锁</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>: expireTime</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span> 2023/2/16 12:24</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> wty</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> expireTime)</span> &#123;<br>        <span class="hljs-comment">// 获取当前线程的标识</span><br>        <span class="hljs-comment">//long threadId = Thread.currentThread().getId();</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> THREAD_ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-comment">// set key &quot;1&quot; ex expireTime nx</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>                .setIfAbsent(KEY_PREFIX + lockName, threadId + <span class="hljs-string">&quot;&quot;</span>, expireTime, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span> //释放锁</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span> 2023/2/16 12:24</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> wty</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取当前线程的ID</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> THREAD_ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId_Redis</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + lockName);<br>        <span class="hljs-comment">// 只有redis中的线程和当前的线程是同一个才允许释放锁</span><br>        <span class="hljs-keyword">if</span> (String.valueOf(threadId).equals(threadId_Redis)) &#123;<br>            stringRedisTemplate.delete(KEY_PREFIX + lockName);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-7-分布式锁原子性操作问题"><a href="#1-7-分布式锁原子性操作问题" class="headerlink" title="1.7 分布式锁原子性操作问题"></a>1.7 分布式锁原子性操作问题</h2><h3 id="1-7-1-介绍"><a href="#1-7-1-介绍" class="headerlink" title="1.7.1 介绍"></a>1.7.1 介绍</h3><p>在上述部分绝大部分情况都能满足业务生产使用，但是在最后判断和删除的时候还是有可能出现阻塞，例如：判断完属于自己的锁，正准备删除的时候，此时应用出现full gc，这个时候就出现了阻塞，同理，其他线程此时由于线程1的阻塞导致的释放锁而拿到了锁，线程1等阻塞完成之后还是会删除锁</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/9b1f9f9a5e1e4bf0a62a74283f41cf7a.png" alt="在这里插入图片描述"></p><h3 id="1-7-2-解决方案"><a href="#1-7-2-解决方案" class="headerlink" title="1.7.2 解决方案"></a>1.7.2 解决方案</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html">菜鸟教程</a>。</p><h4 id="1-7-2-1-更改释放锁逻辑"><a href="#1-7-2-1-更改释放锁逻辑" class="headerlink" title="1.7.2.1 更改释放锁逻辑"></a>1.7.2.1 更改释放锁逻辑</h4><p>原逻辑：</p><ol><li>获取锁中的线程标示</li><li>判断是否与指定的标示（当前线程标示）一致</li><li>如果一致则释放锁（删除）</li><li>如果不一致则什么都不做</li></ol><p>使用Lua脚本更改</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 锁的key</span><br><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>]<br><br><span class="hljs-comment">-- 当前线程的标识</span><br><span class="hljs-keyword">local</span> threadID = ARGV[<span class="hljs-number">1</span>]<br><br><span class="hljs-comment">-- 获取锁中的线程标识</span><br><span class="hljs-keyword">local</span> threadID_Redis = redis.call(<span class="hljs-string">&#x27;get&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<br><br><span class="hljs-comment">-- 比较线程的标识与锁中的标识是否一致</span><br><span class="hljs-keyword">if</span>(ARGV[<span class="hljs-number">1</span>] == threadID_Redis) <span class="hljs-keyword">then</span><br><span class="hljs-comment">-- 一致就释放锁</span><br>redis.call(<span class="hljs-string">&#x27;del&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>java代码调用Lua脚本，更改分布式锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 锁前缀</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 线程ID前缀</span><br><span class="hljs-comment">   * true是可以把UUID中的横线去掉</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">THREAD_ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 定义锁的名称</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> String lockName;<br><br>  StringRedisTemplate stringRedisTemplate;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<br><br>  <span class="hljs-comment">// 在类第一次启动的时候就进行加载</span><br>  <span class="hljs-keyword">static</span> &#123;<br>      UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>      UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));<br>      UNLOCK_SCRIPT.setResultType(Long.class);<br>  &#125;<br><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String lockName, StringRedisTemplate stringRedisTemplate)</span> &#123;<br>      <span class="hljs-built_in">this</span>.lockName = lockName;<br>      <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> void</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@description</span> //释放锁(基于Lua脚本)</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@date</span> 2023/2/16 15:37</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@author</span> wty</span><br><span class="hljs-comment">   **/</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unLock</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 调用Lua脚本</span><br>      stringRedisTemplate.execute(<br>              UNLOCK_SCRIPT,<br>              Collections.singletonList(KEY_PREFIX + lockName),<br>              THREAD_ID_PREFIX + Thread.currentThread().getId()<br>      );<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-8-Redisssion分布式锁"><a href="#1-8-Redisssion分布式锁" class="headerlink" title="1.8 Redisssion分布式锁"></a>1.8 Redisssion分布式锁</h2><p>使用setnx实现分布式锁存在以下问题：</p><ol><li>重入问题：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</li><li>不可重试：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</li><li>超时释放：我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患。</li><li>主从一致性： 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</li></ol><h3 id="1-8-1-关于Redission"><a href="#1-8-1-关于Redission" class="headerlink" title="1.8.1 关于Redission"></a>1.8.1 关于Redission</h3><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>官网：<a href="https://redisson.org/">Redisson官网</a></p><h3 id="1-8-2-引入pom依赖"><a href="#1-8-2-引入pom依赖" class="headerlink" title="1.8.2 引入pom依赖"></a>1.8.2 引入pom依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-8-3-增加配置"><a href="#1-8-3-增加配置" class="headerlink" title="1.8.3 增加配置"></a>1.8.3 增加配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 配置类</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        <span class="hljs-comment">// 添加redis地址，这里添加了单点的地址(虚拟机地址)，也可以使用config.useClusterServers()添加集群地址</span><br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://192.168.150.101:6379&quot;</span>)<br>            .setPassword(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 创建RedissonClient对象</span><br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-8-4-使用Redission解决一人一单"><a href="#1-8-4-使用Redission解决一人一单" class="headerlink" title="1.8.4 使用Redission解决一人一单"></a>1.8.4 使用Redission解决一人一单</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoucherOrderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ISeckillVoucherService iSeckillVoucherService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisWorker redisWorker;<br><br>    <span class="hljs-meta">@Resource</span><br>    StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-comment">// 1.查询秒杀优惠券信息</span><br>        <span class="hljs-comment">// select * from tb_seckill_voucher where voucher_id = ?</span><br>        <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> iSeckillVoucherService.getById(voucherId);<br><br>        <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">beginTime</span> <span class="hljs-operator">=</span> seckillVoucher.getBeginTime();<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> seckillVoucher.getEndTime();<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><br>        <span class="hljs-keyword">if</span> (now.isBefore(beginTime)) &#123;<br>            <span class="hljs-comment">// 当前时间早于秒杀开始时间，说明秒杀没有开始</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始,请耐心等待！秒杀开始时间:&quot;</span> + beginTime.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));<br>        &#125;<br>        <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>        <span class="hljs-keyword">if</span> (now.isAfter(endTime)) &#123;<br>            <span class="hljs-comment">// 当前时间晚于秒杀结束时间，说明秒杀结束了</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束,感谢支持!&quot;</span>);<br>        &#125;<br><br><br>        <span class="hljs-comment">// 4.判断库存是否充足</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> seckillVoucher.getStock();<br>        <span class="hljs-keyword">if</span> (stock &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;商品已经售罄!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 实现一人一单，获取user对象锁</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userID</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 用Redisson提供的可重入锁</span><br>        <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userID.toString().intern());<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> lock.tryLock();<br><br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            <span class="hljs-comment">// 获取锁失败,就直接返回错误信息即可</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;[秒杀优惠券]不允许重复下单!本秒杀业务一切解释器归ty公司所有&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> AopContext.currentProxy();<br>            <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) o;<br>            <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-8-5-Redission的可重入锁原理"><a href="#1-8-5-Redission的可重入锁原理" class="headerlink" title="1.8.5 Redission的可重入锁原理"></a>1.8.5 Redission的可重入锁原理</h3><p>在JDK中，lock锁和synchronized锁都是可重入锁，可重入锁就是当前一个线程在调就是一个线程不用释放，可以重复的获取一个锁n次，只是在释放的时候，也需要相应的释放n次。</p><p>那么猜想Redisssion可以实现可重入就一定有一个记录获取锁次数的变量。</p><h4 id="1-8-5-1-Redis无法实现可重入锁"><a href="#1-8-5-1-Redis无法实现可重入锁" class="headerlink" title="1.8.5.1 Redis无法实现可重入锁"></a>1.8.5.1 Redis无法实现可重入锁</h4><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/d60b998ce29541f4ac08ae0826f664e9.png" alt="img"></p><p>可以看到没有一个变量用来计数锁获取次数</p><h4 id="1-8-5-2-Redisssion可实现可重入锁"><a href="#1-8-5-2-Redisssion可实现可重入锁" class="headerlink" title="1.8.5.2 Redisssion可实现可重入锁"></a>1.8.5.2 Redisssion可实现可重入锁</h4><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/d3a7a25fca934160bb031920d883a9c0.png" alt="img"></p><h4 id="1-8-5-3-Lua脚本实现获取锁（可重入）"><a href="#1-8-5-3-Lua脚本实现获取锁（可重入）" class="headerlink" title="1.8.5.3 Lua脚本实现获取锁（可重入）"></a>1.8.5.3 Lua脚本实现获取锁（可重入）</h4><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/8d8ec511048c40368a6421e563122019.png" alt="img"></p><h4 id="1-8-5-4-Lua脚本实现释放锁（可重入）"><a href="#1-8-5-4-Lua脚本实现释放锁（可重入）" class="headerlink" title="1.8.5.4 Lua脚本实现释放锁（可重入）"></a>1.8.5.4 Lua脚本实现释放锁（可重入）</h4><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/8829602506d245c4860e65bba88333cb.png" alt="img"></p><h4 id="1-8-5-5-测试代码"><a href="#1-8-5-5-测试代码" class="headerlink" title="1.8.5.5 测试代码"></a>1.8.5.5 测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonTest</span> &#123;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br> <br>    <span class="hljs-keyword">private</span> RLock lock;<br> <br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span>&#123;<br>        lock=redissonClient.getLock(<span class="hljs-string">&quot;order&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br>        <span class="hljs-keyword">if</span>(!isLock)&#123;<br>            log.error(<span class="hljs-string">&quot;获取锁失败……1&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span>&#123;<br>            log.info(<span class="hljs-string">&quot;获取锁成功……1&quot;</span>);<br>            method2();<br>            log.info(<span class="hljs-string">&quot;开始执行业务……1&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            log.warn(<span class="hljs-string">&quot;准备释放锁……1&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br>        <span class="hljs-keyword">if</span>(!isLock)&#123;<br>            log.error(<span class="hljs-string">&quot;获取锁失败……2&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span>&#123;<br>            log.info(<span class="hljs-string">&quot;获取锁成功……2&quot;</span>);<br>            log.info(<span class="hljs-string">&quot;开始执行业务……2&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            log.warn(<span class="hljs-string">&quot;准备释放锁……2&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/071adc4a6e234f9d9a8f76c530c48dbe.png" alt="img"></p><h4 id="1-8-5-6-源码"><a href="#1-8-5-6-源码" class="headerlink" title="1.8.5.6 源码"></a>1.8.5.6 源码</h4><p>tryLock():</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/635c000583ed40a8a788767ca9bfb6aa.png" alt="img"></p><p>unLock():</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/6ea4be4c364b4c1ca518b57d92126d3e.png" alt="img"></p><blockquote><p>注：在最后删除锁之后，还进行了一个发布动作</p></blockquote><h3 id="1-8-6-Redission的锁重试和看门狗机制"><a href="#1-8-6-Redission的锁重试和看门狗机制" class="headerlink" title="1.8.6 Redission的锁重试和看门狗机制"></a>1.8.6 Redission的锁重试和看门狗机制</h3><h4 id="1-8-6-1-获取锁重试"><a href="#1-8-6-1-获取锁重试" class="headerlink" title="1.8.6.1 获取锁重试"></a>1.8.6.1 获取锁重试</h4><p>redis获取锁只尝试一次就返回false，没有更多的尝试机制。</p><p>整体流程：<br><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/47d24705269d4683b5dec4f3bb553a51.png" alt="img"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240225204126277.png" alt="image-20240225204126277"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240225204221016.png" alt="image-20240225204221016"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240225204321817.png" alt="image-20240225204321817"></p><p>同时计算获取锁耗时，再使用等待时间-获取锁耗时时间</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//将最大获取锁等待时间转化为毫秒</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> unit.toMillis(waitTime);<br>    <span class="hljs-comment">//获取当前时间的毫秒值</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-comment">//获取线程标识</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>    <span class="hljs-comment">//尝试获取锁,如果获取锁失败ttl应该是一个具体值，而不是null</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">ttl</span> <span class="hljs-operator">=</span> tryAcquire(waitTime, leaseTime, unit, threadId);<br>    <span class="hljs-comment">// lock acquired</span><br>    <span class="hljs-keyword">if</span> (ttl == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//获取到锁，直接返回true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">//计算最大等待时间减去第一次尝试获取锁的时间，得到剩余等待时间 </span><br>    time -= System.currentTimeMillis() - current;<br>    <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//如果不存在剩余时间</span><br>        acquireFailed(waitTime, unit, threadId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//如果还存在剩余时间，接着获取当前时间</span><br>    current = System.currentTimeMillis();<br>    <span class="hljs-comment">//订阅释放锁的信号（就是开头说的释放锁时会发布的那条信息），这里也是异步执行，因此返回类型为Future</span><br>    CompletableFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//获取等待结果，如果超过了剩余最大等待时间会抛出异常，执行TimeOutException中的catch代码</span><br>        subscribeFuture.get(time, TimeUnit.MILLISECONDS);<br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>        <span class="hljs-keyword">if</span> (!subscribeFuture.completeExceptionally(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTimeoutException</span>(<br>                <span class="hljs-string">&quot;Unable to acquire subscription lock after &quot;</span> + time + <span class="hljs-string">&quot;ms. &quot;</span> +<br>                        <span class="hljs-string">&quot;Try to increase &#x27;subscriptionsPerConnection&#x27; and/or &#x27;subscriptionConnectionPoolSize&#x27; parameters.&quot;</span>))) &#123;<br>            subscribeFuture.whenComplete((res, ex) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (ex == <span class="hljs-literal">null</span>) &#123;<br>                    unsubscribe(res, threadId);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        acquireFailed(waitTime, unit, threadId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>        acquireFailed(waitTime, unit, threadId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">//走到这一步说明还存在剩余时间并获取到了锁释放信息</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//更新剩余时间</span><br>        time -= System.currentTimeMillis() - current;<br>        <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>            acquireFailed(waitTime, unit, threadId);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br> <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-comment">//再次尝试获取锁，如果失败获取到ttl存活时间</span><br>            ttl = tryAcquire(waitTime, leaseTime, unit, threadId);<br>            <span class="hljs-comment">// lock acquired</span><br>            <span class="hljs-keyword">if</span> (ttl == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">//执行到这说明又没有获取到锁，更新剩余时间</span><br>            time -= System.currentTimeMillis() - currentTime;<br>            <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>                acquireFailed(waitTime, unit, threadId);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br> <br>            <span class="hljs-comment">// waiting for message</span><br>            currentTime = System.currentTimeMillis();<br>            <span class="hljs-keyword">if</span> (ttl &gt;= <span class="hljs-number">0</span> &amp;&amp; ttl &lt; time) &#123;<br>                <span class="hljs-comment">//如果锁剩余时间小于当前线程剩余等待时间，再次获取锁，最大等待时间为锁的释放时间</span><br>                commandExecutor.getNow(subscribeFuture).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果锁的剩余时间大于当前线程剩余等待时间，再次获取锁，最大等待时间为当前线程的剩余时间</span><br>                commandExecutor.getNow(subscribeFuture).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);<br>            &#125;<br>            <span class="hljs-comment">//如果还没有获取到锁，while循环执行上述代码</span><br>            time -= System.currentTimeMillis() - currentTime;<br>            <span class="hljs-keyword">if</span> (time &lt;= <span class="hljs-number">0</span>) &#123;<br>                acquireFailed(waitTime, unit, threadId);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        unsubscribe(commandExecutor.getNow(subscribeFuture), threadId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-8-6-2-看门狗机制（刷新有效期）"><a href="#1-8-6-2-看门狗机制（刷新有效期）" class="headerlink" title="1.8.6.2 看门狗机制（刷新有效期）"></a>1.8.6.2 看门狗机制（刷新有效期）</h4><h5 id="1-8-6-2-1-获取锁"><a href="#1-8-6-2-1-获取锁" class="headerlink" title="1.8.6.2.1 获取锁"></a>1.8.6.2.1 获取锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="hljs-title function_">tryAcquireAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId)</span> &#123;<br>    <span class="hljs-comment">//返回的值赋值给该变量，该变量是一个Future，因为是异步执行lua脚本，因此无法立刻拿到返回值</span><br>    RFuture&lt;Long&gt; ttlRemainingFuture;<br>    <span class="hljs-keyword">if</span> (leaseTime &gt; <span class="hljs-number">0</span>) &#123;<br>        ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,<br>                TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);<br>    &#125;<br>  <br>  <span class="hljs-comment">// 刷新有效期</span><br>    <span class="hljs-comment">//回调函数，当拿到返回值ttlRemaining</span><br>    CompletionStage&lt;Long&gt; f = ttlRemainingFuture.thenApply(ttlRemaining -&gt; &#123;<br>        <span class="hljs-comment">// lock acquired</span><br>        <span class="hljs-comment">//说明获取锁成功</span><br>        <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//如果我们配置了锁的过期时间，那么将其转化为毫秒后覆盖掉默认的锁释放时间（同时也会取消看门狗机制）</span><br>            <span class="hljs-keyword">if</span> (leaseTime &gt; <span class="hljs-number">0</span>) &#123;<br>                internalLockLeaseTime = unit.toMillis(leaseTime);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果没有指定锁的过期施放时间，那么定时将锁的有效时间进行更新</span><br>                scheduleExpirationRenewal(threadId);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ttlRemaining;<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFutureWrapper</span>&lt;&gt;(f);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleExpirationRenewal</span><span class="hljs-params">(<span class="hljs-type">long</span> threadId)</span> &#123;<br><span class="hljs-comment">//该对象主要存储了两个属性，线程标识，Timeout对象（一个定时任务），我们可以理解为一个锁对象</span><br>    <span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpirationEntry</span>();<br><span class="hljs-comment">//MAP对象存储的是不同业务中的不同锁对象。getEntryName()实际上获取到的是getLock(name)方法中的name</span><br><span class="hljs-comment">//如果第一次获取，返回值为null，如果map中已经存在该业务类型的锁那么返回的是entry对象</span><br>    <span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">oldEntry</span> <span class="hljs-operator">=</span> EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);<br>    <span class="hljs-keyword">if</span> (oldEntry != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//说明map中以及存在该业务类型的锁了，更新该业务锁的线程标识id</span><br>        oldEntry.addThreadId(threadId);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//第一次向map中存放该业务类型的锁，更新该业务锁的线程标识id</span><br>        entry.addThreadId(threadId);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//续约方法</span><br>            renewExpiration();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                cancelExpirationRenewal(threadId);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renewExpiration</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//获取业务锁对象</span><br>    <span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">ee</span> <span class="hljs-operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>    <span class="hljs-keyword">if</span> (ee == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//这里有三个参数，第一个是定时任务需要执行的逻辑代码，第二个是延时执行时间，第三个延时执行时间单位</span><br>    <span class="hljs-comment">//延时执行时间是锁的过期释放时间的三分之一</span><br>    <span class="hljs-type">Timeout</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-comment">//获取锁对象</span><br>            <span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">ent</span> <span class="hljs-operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>            <span class="hljs-keyword">if</span> (ent == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//获取锁对象中的线程标识</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ent.getFirstThreadId();<br>            <span class="hljs-keyword">if</span> (threadId == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//刷新锁的有效时间</span><br>            CompletionStage&lt;Boolean&gt; future = renewExpirationAsync(threadId);<br>            <span class="hljs-comment">//刷新锁的有效时间结束后，调用下面方法</span><br>            future.whenComplete((res, e) -&gt; &#123;<br>                <span class="hljs-comment">//如果刷新锁的有效时间抛出异常，抛出日志并将锁对象从map中移除</span><br>                <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                    log.error(<span class="hljs-string">&quot;Can&#x27;t update lock &#123;&#125; expiration&quot;</span>, getRawName(), e);<br>                    EXPIRATION_RENEWAL_MAP.remove(getEntryName());<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-comment">//如果刷新成功</span><br>                <span class="hljs-keyword">if</span> (res) &#123;<br>                    <span class="hljs-comment">// 递归调用本方法</span><br>                    renewExpiration();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//如果返回值为null，那么就取消定时任务</span><br>                    cancelExpirationRenewal(<span class="hljs-literal">null</span>);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;, internalLockLeaseTime / <span class="hljs-number">3</span>, TimeUnit.MILLISECONDS);<br>    <br>    ee.setTimeout(task);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> CompletionStage&lt;Boolean&gt; <span class="hljs-title function_">renewExpirationAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> threadId)</span> &#123;<br>    <span class="hljs-keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,<br>            <span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +<br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +<br>                    <span class="hljs-string">&quot;return 1; &quot;</span> +<br>                    <span class="hljs-string">&quot;end; &quot;</span> +<br>                    <span class="hljs-string">&quot;return 0;&quot;</span>,<br>            Collections.singletonList(getRawName()),<br>            internalLockLeaseTime, getLockName(threadId));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-8-6-2-2-释放锁"><a href="#1-8-6-2-2-释放锁" class="headerlink" title="1.8.6.2.2 释放锁"></a>1.8.6.2.2 释放锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RFuture&lt;Void&gt; <span class="hljs-title function_">unlockAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> threadId)</span> &#123;<br>    RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId);<br><span class="hljs-comment">//当取消锁成功时，执行该回调方法</span><br>    CompletionStage&lt;Void&gt; f = future.handle((opStatus, e) -&gt; &#123;<br>        <span class="hljs-comment">//取消续约定时任务</span><br>        cancelExpirationRenewal(threadId);<br> <br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionException</span>(e);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (opStatus == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">IllegalMonitorStateException</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;attempt to unlock lock, not locked by current thread by node id: &quot;</span><br>                    + id + <span class="hljs-string">&quot; thread-id: &quot;</span> + threadId);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionException</span>(cause);<br>        &#125;<br> <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFutureWrapper</span>&lt;&gt;(f);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelExpirationRenewal</span><span class="hljs-params">(Long threadId)</span> &#123;<br><span class="hljs-comment">//根据key获取到锁对象</span><br>    <span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());<br><span class="hljs-comment">//如果不存在锁，那么直接返回</span><br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (threadId != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//移除锁对象中的线程标识</span><br>        task.removeThreadId(threadId);<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span> (threadId == <span class="hljs-literal">null</span> || task.hasNoThreads()) &#123;<br>        <span class="hljs-type">Timeout</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> task.getTimeout();<br>        <span class="hljs-keyword">if</span> (timeout != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//如果锁对象中的定时任务不为空，那么就取消</span><br>            timeout.cancel();<br>        &#125;<br>        <span class="hljs-comment">//移除map中的锁对象</span><br>        EXPIRATION_RENEWAL_MAP.remove(getEntryName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-8-7-Redission的multiLock问题"><a href="#1-8-7-Redission的multiLock问题" class="headerlink" title="1.8.7 Redission的multiLock问题"></a>1.8.7 Redission的multiLock问题</h3><h4 id="1-8-7-1-背景"><a href="#1-8-7-1-背景" class="headerlink" title="1.8.7.1 背景"></a>1.8.7.1 背景</h4><p>Redisson分布式锁主从一致性问题<br>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例<br>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/52f67dbfbe044fb899ca21af38ea1d9d.png" alt="在这里插入图片描述"></p><h4 id="1-8-7-2-解决"><a href="#1-8-7-2-解决" class="headerlink" title="1.8.7.2 解决"></a>1.8.7.2 解决</h4><p>redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/a6cc34e028ac4edf93d14e55119051ef.png" alt="在这里插入图片描述"></p><h4 id="1-8-7-3-使用示例"><a href="#1-8-7-3-使用示例" class="headerlink" title="1.8.7.3 使用示例"></a>1.8.7.3 使用示例</h4><p>修改配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 配置类</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        <span class="hljs-comment">// 添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址</span><br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://192.168.183.145:6379&quot;</span>)<br>                .setPassword(<span class="hljs-string">&quot;112453&quot;</span>);<br>        <span class="hljs-comment">// 创建RedissonClient对象</span><br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 配置类</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        <span class="hljs-comment">// 添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址</span><br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://192.168.193.175:6380&quot;</span>)<br>                .setPassword(<span class="hljs-string">&quot;557724&quot;</span>);<br>        <span class="hljs-comment">// 创建RedissonClient对象</span><br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 配置类</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        <span class="hljs-comment">// 添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址</span><br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://192.168.177.145:6381&quot;</span>)<br>                .setPassword(<span class="hljs-string">&quot;5896&quot;</span>);<br>        <span class="hljs-comment">// 创建RedissonClient对象</span><br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonTest</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient2;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient3;<br><br>    RLock lock;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">RLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>        <span class="hljs-type">RLock</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>        <span class="hljs-type">RLock</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br><br>        <span class="hljs-comment">// 创建连锁</span><br>        lock = redissonClient.getMultiLock(lock1, lock2, lock3);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br>        <span class="hljs-keyword">if</span> (!isLock) &#123;<br>            log.error(<span class="hljs-string">&quot;获取锁失败1&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.info(<span class="hljs-string">&quot;获取锁成功,1&quot;</span>);<br>            method2();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.info(<span class="hljs-string">&quot;释放锁,1&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br>        <span class="hljs-keyword">if</span> (!isLock) &#123;<br>            log.error(<span class="hljs-string">&quot;获取锁失败2&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.info(<span class="hljs-string">&quot;获取锁成功,2&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.info(<span class="hljs-string">&quot;释放锁,2&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-8-7-4-源码"><a href="#1-8-7-4-源码" class="headerlink" title="1.8.7.4 源码"></a>1.8.7.4 源码</h4><p>getMultiLock()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里相对简单，就是创建了一个RLock集合，为了后续分别去获取锁</span><br><span class="hljs-keyword">final</span> List&lt;RLock&gt; locks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> RLock <span class="hljs-title function_">getMultiLock</span><span class="hljs-params">(RLock... locks)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedissonMultiLock</span>(locks);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">RedissonMultiLock</span><span class="hljs-params">(RLock... locks)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locks.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Lock objects are not defined&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.locks.addAll(Arrays.asList(locks));<br>&#125;<br></code></pre></td></tr></table></figure><p>加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设传入的waitTime=2s leaseTime=2s</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-comment">// 定义了一个新的释放时间newLeaseTime=-1</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">newLeaseTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 如果传入了时间的tryLock，leaseTime就不等于-1，不传默认值为-1</span><br>        <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 将新的锁释放时间设置为waitTime的2倍，重试耗时时间较久，预防重试没完就释放了</span><br>            newLeaseTime = unit.toMillis(waitTime)*<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-comment">// 获取当前时间（毫秒）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-comment">// remain==保持，先翻译为保持时间，定义为-1</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">remainTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (waitTime != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 保持时间设置为waitTime，2000ms</span><br>            remainTime = unit.toMillis(waitTime);<br>        &#125;<br>    <span class="hljs-comment">// calcLockWaitTime(remainTime);--&gt;return Math.max(remainTime / locks.size(), 1);</span><br>    <span class="hljs-comment">// 300ms=lockWaitTime</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">lockWaitTime</span> <span class="hljs-operator">=</span> calcLockWaitTime(remainTime);<br>        <span class="hljs-comment">// failedLocksLimit -&gt; 0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">failedLocksLimit</span> <span class="hljs-operator">=</span> failedLocksLimit();<br>        List&lt;RLock&gt; acquiredLocks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(locks.size());<br>    <span class="hljs-comment">// 循环获取锁</span><br>        <span class="hljs-keyword">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;<br>            <span class="hljs-comment">// 获取到的redisson实例生成的锁</span><br>            <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-comment">// 锁获取标识</span><br>            <span class="hljs-type">boolean</span> lockAcquired;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (waitTime == -<span class="hljs-number">1</span> &amp;&amp; leaseTime == -<span class="hljs-number">1</span>) &#123;<br>                    lockAcquired = lock.tryLock();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">awaitTime</span> <span class="hljs-operator">=</span> Math.min(lockWaitTime, remainTime);<br>                    <span class="hljs-comment">// 直接去获取锁，返回true or false</span><br>                    lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (RedisResponseTimeoutException e) &#123;<br>                <span class="hljs-comment">// 如果发生了RedisResponseTimeoutException，会先解锁。因为这个时候不确定是否加锁成功了，所以解锁设置标识为失败。</span><br>                unlockInner(Arrays.asList(lock));<br>                lockAcquired = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-comment">// 其他异常设置标识为false</span><br>                lockAcquired = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (lockAcquired) &#123;<br>                <span class="hljs-comment">// 如果加锁成功 放入集合中</span><br>                acquiredLocks.add(lock);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 获取锁数量等于锁总数量</span><br>                <span class="hljs-keyword">if</span> (locks.size() - acquiredLocks.size() == failedLocksLimit()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>              <br>                <span class="hljs-keyword">if</span> (failedLocksLimit == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 会把获取到锁的一次性解锁</span><br>                    unlockInner(acquiredLocks);<br>                    <span class="hljs-keyword">if</span> (waitTime == -<span class="hljs-number">1</span> &amp;&amp; leaseTime == -<span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 重置failedLocksLimit=0</span><br>                    failedLocksLimit = failedLocksLimit();<br>                    <span class="hljs-comment">// 清空获取到锁的集合</span><br>                    acquiredLocks.clear();<br>                    <span class="hljs-comment">// 重置迭代器的指针</span><br>                    <span class="hljs-keyword">while</span> (iterator.hasPrevious()) &#123;<br>                        iterator.previous();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// RedissonRedLock才会进入这个逻辑</span><br>                    failedLocksLimit--;<br>                &#125;<br>            &#125;<br><span class="hljs-comment">// 如果remainTime不为-1</span><br>            <span class="hljs-comment">// remainTime=2000ms</span><br>            <span class="hljs-keyword">if</span> (remainTime != -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 查看remainTime的剩余时间</span><br>                remainTime -= System.currentTimeMillis() - time;<br>                <span class="hljs-comment">// 重置time</span><br>                time = System.currentTimeMillis();<br>                <span class="hljs-comment">// 如果保持时间也就是之前的waitTime小于0，也就是说超过了尝试获取锁时最长的等待时间，释放所有已获得的锁，并返回false，加锁失败</span><br>                <span class="hljs-keyword">if</span> (remainTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    unlockInner(acquiredLocks);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>  <br><span class="hljs-comment">// 如果自己手动传入了锁释放时间，释放时间为-1的时候触发看门狗机制</span><br>        <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 创建了一个RFuture集合</span><br>            List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(acquiredLocks.size());<br>           <span class="hljs-comment">// 由于每个锁获取到手的时间不同，等所有锁都拿到手之后，重新给所有锁重新设置有效期</span><br>            <span class="hljs-keyword">for</span> (RLock rLock : acquiredLocks) &#123;<br>                <span class="hljs-comment">//为每个锁设置过期时间，是一个异步的操作</span><br>                RFuture&lt;Boolean&gt; future = ((RedissonLock) rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);<br>                futures.add(future);<br>            &#125;<br>            <br>            <span class="hljs-keyword">for</span> (RFuture&lt;Boolean&gt; rFuture : futures) &#123;<br>                <span class="hljs-comment">// 阻塞当前线程，同步等待每个异步操作的结果</span><br>                rFuture.syncUninterruptibly();<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reids-优惠券秒杀</title>
    <link href="/reids-%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/92ed990d85c4/"/>
    <url>/reids-%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/92ed990d85c4/</url>
    
    <content type="html"><![CDATA[<h1 id="0-目录"><a href="#0-目录" class="headerlink" title="0 目录"></a>0 目录</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240225111852122.png" alt="image-20240225111852122"></p><h1 id="1-全局ID生成器"><a href="#1-全局ID生成器" class="headerlink" title="1 全局ID生成器"></a>1 全局ID生成器</h1><h2 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h2><p>使用数据库自增ID会存在两个问题：</p><ul><li>id的规律性太明显（如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适）</li><li>受单表数据量的限制（随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。）</li></ul><p>因此就需要就一个<strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><ul><li>唯一性：想到了关键字incrby</li><li>高可用：集群方案、主从方案、哨兵方案</li><li>高性能：内存存储性能好</li><li>递增：采用递增</li><li>安全性：自增然后再拼接一些其它信息，让规律不要那么明显</li></ul><h2 id="1-2-组成"><a href="#1-2-组成" class="headerlink" title="1.2 组成"></a>1.2 组成</h2><p>数据库的id选择数值类型（占用空间更小），对应Java的Long（8字节，64比特位）</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/d3650cb15c06465fb160f86d7d0d7f17.png" alt="在这里插入图片描述"></p><ul><li>符号位：1bit，永远为0</li><li>时间戳：31bit，以秒为单位，可以使用69年</li><li>序列号：32bit，秒内的计数器，支持每秒产生232个不同ID</li></ul><h2 id="1-3-代码"><a href="#1-3-代码" class="headerlink" title="1.3 代码"></a>1.3 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisWorker</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 把距离当前时间的偏移量作为时间戳</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> 计算出当前的时间戳;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列号的长度(位数)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextID</span><span class="hljs-params">(String keyPrefix)</span> &#123;<br>        <span class="hljs-comment">// 1.生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_TIMESTAMP;<br><br>        <span class="hljs-comment">// 2.生成序列号</span><br>        <span class="hljs-comment">// 2.1 获取当前日期，精确到天,保证一天生成一个key</span><br>        <span class="hljs-comment">// 2.2 自增长</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyyMMdd&quot;</span>));<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">sequence</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br><br>        <span class="hljs-comment">//3.拼接返回</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> (timestamp &lt;&lt; COUNT_BITS) | sequence;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-4-多线程测试"><a href="#1-4-多线程测试" class="headerlink" title="1.4 多线程测试"></a>1.4 多线程测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pools</span> <span class="hljs-operator">=</span> CacheClient.newFixedThreadPool(<span class="hljs-number">500</span>);<br>    <span class="hljs-comment">// 程序计数器 设置的数量和循环数量一致</span><br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">300</span>);<br><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> redisWorker.nextID(<span class="hljs-string">&quot;order&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;id:&quot;</span> + id);<br>            &#125;<br>            <span class="hljs-comment">// 每一个线程跑完，就剪掉一次计数(倒计时)</span><br>            latch.countDown();<br>        &#125;<br>    &#125;;<br>  <br>    runnable.run();<br>  <br>    <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300</span>; i++) &#123;<br>        pools.submit(runnable);<br>    &#125;<br>    latch.await(); <span class="hljs-comment">//等待所有的执行完毕</span><br>  <br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;总时间是:&quot;</span> + (end - begin));<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="2-优惠券秒杀下单"><a href="#2-优惠券秒杀下单" class="headerlink" title="2 优惠券秒杀下单"></a>2 优惠券秒杀下单</h1><h2 id="2-1-接口"><a href="#2-1-接口" class="headerlink" title="2.1 接口"></a>2.1 接口</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/02af1e94c857425d831a773723f43e39.png" alt="在这里插入图片描述"></p><blockquote><p>考虑的点：</p><ol><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ol></blockquote><h2 id="2-2-分析及代码实现"><a href="#2-2-分析及代码实现" class="headerlink" title="2.2 分析及代码实现"></a>2.2 分析及代码实现</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/82ccfe860b3b4c64b2e50f4fbe35dbeb.png" alt="在这里插入图片描述"></p><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/voucher-order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> VoucherOrderServiceImpl voucherOrderService;<br><br>    <span class="hljs-meta">@PostMapping(&quot;seckill/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long voucherId)</span> &#123;<br>        <span class="hljs-keyword">return</span> voucherOrderService.seckillVoucher(voucherId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoucherOrderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ISeckillVoucherService iSeckillVoucherService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisWorker redisWorker;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-comment">// 1.查询秒杀优惠券信息</span><br>        <span class="hljs-comment">// select * from tb_seckill_voucher where voucher_id = ?</span><br>        <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> iSeckillVoucherService.getById(voucherId);<br><br>        <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">beginTime</span> <span class="hljs-operator">=</span> seckillVoucher.getBeginTime();<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> seckillVoucher.getEndTime();<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><br>        <span class="hljs-keyword">if</span> (now.isBefore(beginTime)) &#123;<br>            <span class="hljs-comment">// 当前时间早于秒杀开始时间，说明秒杀没有开始</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始,请耐心等待！秒杀开始时间:&quot;</span> + beginTime.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));<br>        &#125;<br>        <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>        <span class="hljs-keyword">if</span> (now.isAfter(endTime)) &#123;<br>            <span class="hljs-comment">// 当前时间晚于秒杀结束时间，说明秒杀结束了</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束,感谢支持!&quot;</span>);<br>        &#125;<br><br><br>        <span class="hljs-comment">// 4.判断库存是否充足</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> seckillVoucher.getStock();<br>        <span class="hljs-keyword">if</span> (stock &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;商品已经售罄!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 5.扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> iSeckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock -1&quot;</span>)<br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update();<br><br>        <span class="hljs-keyword">if</span> (!result) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;商品已经售罄!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 6.创建订单</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取订单id</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisWorker.nextID(<span class="hljs-string">&quot;order&quot;</span>);<br><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        voucherOrder.setId(orderId);<br>        voucherOrder.setVoucherId(voucherId);<br>        voucherOrder.setUserId(UserHolder.getUser().getId());<br><br>        <span class="hljs-comment">// 将订单信息保存到数据库</span><br>        <span class="hljs-comment">// insert into tb_voucher_order values ()</span><br>        save(voucherOrder);<br><br>        <span class="hljs-comment">// 7.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-超卖问题"><a href="#3-超卖问题" class="headerlink" title="3 超卖问题"></a>3 超卖问题</h1><h2 id="3-1-背景"><a href="#3-1-背景" class="headerlink" title="3.1 背景"></a>3.1 背景</h2><p>如果只有同一时间只有一个用户下单没有任何的问题，但是此时如果统一时间有多个用户下单，QPS较高的情况此时就会出现并发的问题</p><h2 id="3-2-超卖模拟"><a href="#3-2-超卖模拟" class="headerlink" title="3.2 超卖模拟"></a>3.2 超卖模拟</h2><p>将库存恢复（tb_seckill_voucher），清空订单数据（tb_voucher_order），使用Jemeter</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/35415018536b4fa395eab6b764c0d44a.png" alt="在这里插入图片描述"></p><ul><li>post请求设置</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/de596be2297d4bb7819d001e08a1101d.png" alt="在这里插入图片描述"></p><ul><li>配置头</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/be0fcbaf17fc449eac9499cefd72c359.png" alt="在这里插入图片描述"></p><ul><li>设置断言</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/084556d444fe45e5b8e8189779f03bed-20240225124652133.png"></p><ul><li>启动</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/a5644e9f12f846519f1e63f55b856156.png" alt="在这里插入图片描述"></p><ul><li>结果</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/c7e8f8b8eb7449a7b83d56c878691f17.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/76187badbe3e429a82c3d0d7b22e7dd1.png" alt="在这里插入图片描述"></p><h2 id="3-3-原因分析"><a href="#3-3-原因分析" class="headerlink" title="3.3 原因分析"></a>3.3 原因分析</h2><p>当库存还有1的时候，线程1查询库存的时候，得到库存为大于0，正准备扣减库存，此时正好线程2过来也进行查询，库存也是大于0，线程2同样准备扣减库存，当两个线程结束的时候，库存被-2了。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/795fd813c2944d5db9e20ad25ca59130.png" alt="在这里插入图片描述"></p><h2 id="3-4-锁"><a href="#3-4-锁" class="headerlink" title="3.4 锁"></a>3.4 锁</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/60f90535f95c4569b419a36f2260b5e4.png" alt="在这里插入图片描述"></p><h3 id="3-4-1-悲观锁"><a href="#3-4-1-悲观锁" class="headerlink" title="3.4.1 悲观锁"></a>3.4.1 悲观锁</h3><p>悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等。</p><h3 id="3-4-2-乐观锁"><a href="#3-4-2-乐观锁" class="headerlink" title="3.4.2 乐观锁"></a>3.4.2 乐观锁</h3><p>乐观锁：增加一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功。</p><p>这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过。</p><p>当然乐观锁还有一些变种的处理方式比如cas：compare and set</p><h2 id="3-5-解决"><a href="#3-5-解决" class="headerlink" title="3.5 解决"></a>3.5 解决</h2><h3 id="3-5-1-方案一"><a href="#3-5-1-方案一" class="headerlink" title="3.5.1 方案一"></a>3.5.1 方案一</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/1ce17bb7620e4c1697112fbf340dbd5e.png" alt="在这里插入图片描述"></p><p>根据乐观锁分析，只需要比对和上次的version相同即可，如果版本相同那么证明是没有被修改过，此时扣减库存，同时version++，如果不同，那么证明已经被修改了。</p><p>但是发现库存和版本号同样也可以做到这个功能，因此无需多增加版本信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 5.2扣减库存(针对超卖问题用乐观锁CAS解决)</span><br><span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ? and stock = ?</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> iSeckillVoucherService.update()<br>        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>        .eq(<span class="hljs-string">&quot;stock&quot;</span>, stock)<br>        .update();<br><br></code></pre></td></tr></table></figure><p>即：比对库存是否相同即可。</p><p>问题：有很多失败的，售卖出去的很少，没有实现超卖</p><p>原因：这样修改只保证了同一时间查询出来的库存相同的时候，多个线程只有一个会成功，其他的都会失败。</p><h3 id="3-5-2-方案二"><a href="#3-5-2-方案二" class="headerlink" title="3.5.2 方案二"></a>3.5.2 方案二</h3><p>针对方案1的问题，只需要将库存设置为大于0即可，不需要严格的按照cas去做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 5.3扣减库存(针对使用乐观锁CAS，没卖完解决)</span><br><span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ? and stock &gt; 0</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> iSeckillVoucherService.update()<br>        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>        .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>        .update();<br></code></pre></td></tr></table></figure><h1 id="4-一人一单"><a href="#4-一人一单" class="headerlink" title="4 一人一单"></a>4 一人一单</h1><h2 id="4-1-背景"><a href="#4-1-背景" class="headerlink" title="4.1 背景"></a>4.1 背景</h2><p>在优惠券不超卖的情况下需要考虑一个问题：每个用户只能领取一个优惠券，不能多次重复的领取</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/d6d485a3accd4231bfc8bc1a972bce28.png" alt="在这里插入图片描述"></p><h2 id="4-2-修改"><a href="#4-2-修改" class="headerlink" title="4.2 修改"></a>4.2 修改</h2><p>增加对优惠券id和用户id进行判断</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/f32d9de8c5744798928847432ed32c33.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">userID</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-comment">// 5.实现1人1单加入逻辑：根据优惠券id和用户id查询订单</span><br><span class="hljs-comment">// 5.1查询订单,并不用查询出具体的值，而是查询出数量即可</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userID).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br><span class="hljs-comment">// 5.2判断订单是否存在</span><br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 5.2.1 存在就返回异常结果</span><br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀优惠券每人限购1张,感谢配合,本优惠券最终解释权归ty公司所有!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Jemeter测试：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/2e1d73c74891476da6e0923622412049.png" alt="在这里插入图片描述"></p><h2 id="4-3-分析"><a href="#4-3-分析" class="headerlink" title="4.3 分析"></a>4.3 分析</h2><p>此时问题出现在了查询至修改库存的地方，多线程过来之后，查询到都不存在订单，因此某几个线程还是会一起去创建订单</p><h2 id="4-4-解决"><a href="#4-4-解决" class="headerlink" title="4.4 解决"></a>4.4 解决</h2><p>使用悲观锁进行解决</p><p>对代码的分析，此时只需要对创建订单这个方法进行抽取，使用sychronized加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userID</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 5.实现1人1单加入逻辑：根据优惠券id和用户id查询订单</span><br>    <span class="hljs-comment">// 5.1查询订单,并不用查询出具体的值，而是查询出数量即可</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userID).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>    <span class="hljs-comment">// 5.2判断订单是否存在</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 5.2.1 存在就返回异常结果</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀优惠券每人限购1张,感谢配合,本优惠券最终解释权归ty公司所有!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 5.2.2 不存在再减少库存</span><br><br>    <span class="hljs-comment">// 6.1扣减库存(会出现超卖问题)</span><br>    <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ?</span><br>    <span class="hljs-comment">/*boolean result = iSeckillVoucherService.update()</span><br><span class="hljs-comment">            .setSql(&quot;stock = stock -1&quot;)</span><br><span class="hljs-comment">            .eq(&quot;voucher_id&quot;, voucherId).update();*/</span><br><br>    <span class="hljs-comment">// 6.2扣减库存(针对超卖问题用乐观锁CAS解决)</span><br>    <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ? and stock = ?</span><br>    <span class="hljs-comment">/*boolean result = iSeckillVoucherService.update()</span><br><span class="hljs-comment">            .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="hljs-comment">            .eq(&quot;voucher_id&quot;, voucherId)</span><br><span class="hljs-comment">            .eq(&quot;stock&quot;, stock)</span><br><span class="hljs-comment">            .update();*/</span><br><br>    <span class="hljs-comment">// 6.3扣减库存(针对使用乐观锁CAS，没卖完解决)</span><br>    <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ? and stock &gt; 0</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> iSeckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>            .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>            .update();<br><br>    <span class="hljs-keyword">if</span> (!result) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;商品已经售罄!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 7.创建订单</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取订单id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisWorker.nextID(<span class="hljs-string">&quot;order&quot;</span>);<br><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    voucherOrder.setId(orderId);<br>    voucherOrder.setVoucherId(voucherId);<br>    voucherOrder.setUserId(userID);<br><br>    <span class="hljs-comment">// 将订单信息保存到数据库</span><br>    <span class="hljs-comment">// insert into tb_voucher_order values ()</span><br>    save(voucherOrder);<br><br>    <span class="hljs-comment">//8.返回订单id</span><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-1-问题一"><a href="#4-4-1-问题一" class="headerlink" title="4.4.1 问题一"></a>4.4.1 问题一</h3><p>此时sychronized加锁的话，锁粒度很粗，直接锁住的是整个方法，导致性能较差，因此考虑缩小锁的范围</p><blockquote><p>此时使用用户ID作为锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userID</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><br>    <span class="hljs-comment">// 通过悲观锁，锁住用户，实现一人一单</span><br>    <span class="hljs-keyword">synchronized</span> (userID.toString().intern()) &#123; <span class="hljs-comment">//如果不加Intern的话，那么在toString底层每次都是New一个新的对象，那么锁就失效了</span><br>        <span class="hljs-comment">// 5.实现1人1单加入逻辑：根据优惠券id和用户id查询订单</span><br>        <span class="hljs-comment">// 5.1查询订单,并不用查询出具体的值，而是查询出数量即可</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userID).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>        <span class="hljs-comment">// 5.2判断订单是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 5.2.1 存在就返回异常结果</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀优惠券每人限购1张,感谢配合,本优惠券最终解释权归ty公司所有!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 5.2.2 不存在再减少库存</span><br><br>        <span class="hljs-comment">// 6.1扣减库存(会出现超卖问题)</span><br>        <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ?</span><br>    <span class="hljs-comment">/*boolean result = iSeckillVoucherService.update()</span><br><span class="hljs-comment">            .setSql(&quot;stock = stock -1&quot;)</span><br><span class="hljs-comment">            .eq(&quot;voucher_id&quot;, voucherId).update();*/</span><br><br>        <span class="hljs-comment">// 6.2扣减库存(针对超卖问题用乐观锁CAS解决)</span><br>        <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ? and stock = ?</span><br>    <span class="hljs-comment">/*boolean result = iSeckillVoucherService.update()</span><br><span class="hljs-comment">            .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="hljs-comment">            .eq(&quot;voucher_id&quot;, voucherId)</span><br><span class="hljs-comment">            .eq(&quot;stock&quot;, stock)</span><br><span class="hljs-comment">            .update();*/</span><br><br>        <span class="hljs-comment">// 6.3扣减库存(针对使用乐观锁CAS，没卖完解决)</span><br>        <span class="hljs-comment">// update tb_seckill_voucher set stock = stock -1 where voucher_id = ? and stock &gt; 0</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> iSeckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>                .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>                .update();<br><br>        <span class="hljs-keyword">if</span> (!result) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;商品已经售罄!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 7.创建订单</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取订单id</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisWorker.nextID(<span class="hljs-string">&quot;order&quot;</span>);<br><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        voucherOrder.setId(orderId);<br>        voucherOrder.setVoucherId(voucherId);<br>        voucherOrder.setUserId(userID);<br><br>        <span class="hljs-comment">// 将订单信息保存到数据库</span><br>        <span class="hljs-comment">// insert into tb_voucher_order values ()</span><br>        save(voucherOrder);<br><br>        <span class="hljs-comment">//8.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-2-问题二"><a href="#4-4-2-问题二" class="headerlink" title="4.4.2 问题二"></a>4.4.2 问题二</h3><p>当前方法加了<code>@Transactional</code>进行事务控制，在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，因此需要将方法整体包起来，确保事务不会出现问题</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/5c92409485eb439f8fda941ba9ed4b19.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现一人一单，锁住对象</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">userID</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-keyword">synchronized</span> (userID.toString().intern()) &#123;<br>    <span class="hljs-keyword">return</span> createVoucherOrder(voucherId);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-3-问题三"><a href="#4-4-3-问题三" class="headerlink" title="4.4.3 问题三"></a>4.4.3 问题三</h3><p>此时事务的标志是在createVocherOrder方法上，并没有在seckillVoucher方法上，在调用createVocherOrder的时候使用的this方式里调用的，因此是VoucherOrderServiceImpl而不是VoucherOrderService的代理对象。因此我们需要获得原始的事务对象， 来操作事务。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/c664f5bd083042349de129575b8337a3.png" alt="在这里插入图片描述"></p><p>VoucherOrderServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现一人一单，获取user对象锁</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">userID</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><span class="hljs-keyword">synchronized</span> (userID.toString().intern()) &#123;<br>    <span class="hljs-comment">// 调用本类方法的时候，Spring事务是失效的，解决方案二：调用AopContext API</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> AopContext.currentProxy();<br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) o;<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>&#125;<br></code></pre></td></tr></table></figure><p>IVoucherOrderService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IVoucherOrderService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;VoucherOrder&gt; &#123;<br><br>    Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span>;<br><br>    Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>pom依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- Spring事务失效，采用AopContext API来处理 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;<br>    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br><br></code></pre></td></tr></table></figure><p>HmDianPingApplication.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy(exposeProxy = true)</span> <span class="hljs-comment">//暴露代理对象，默认不暴露</span><br></code></pre></td></tr></table></figure><h1 id="5-集群模式下的一人一单"><a href="#5-集群模式下的一人一单" class="headerlink" title="5 集群模式下的一人一单"></a>5 集群模式下的一人一单</h1><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><ol><li><p>我们将服务启动两份，端口分别为8081和8082：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/7249a1b7643c443d8598279efc3e7ac9.png" alt="在这里插入图片描述"></p></li><li><p>重新指定新服务端口</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/aabca2e47e0d4c06a20cc9324787432b-20240225134656691.png"></p></li><li><p>debug启动</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/3bb5bade6df74a959fa8e0ac7344e875.png" alt="在这里插入图片描述"></p></li><li><p>nginx修改</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/c3ef5952ae2f413f8169a2760d5c5d71.png" alt="在这里插入图片描述"></p></li><li><p>重启nginx</p></li><li><p>访问接口（<a href="http://localhost:8080/api/voucher/list/1%EF%BC%89%EF%BC%8C%E7%9B%B4%E8%87%B3%E4%B8%A4%E4%B8%AA%E6%9C%8D%E5%8A%A1%E9%83%BD%E6%9C%89sql%E8%AF%AD%E5%8F%A5%E8%BE%93%E5%87%BA%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%A8%A1%E6%8B%9F%E9%9B%86%E7%BE%A4%E5%B0%B1%E7%94%9F%E6%95%88%E4%BA%86">http://localhost:8080/api/voucher/list/1），直至两个服务都有sql语句输出，这样模拟集群就生效了</a></p></li><li><p>使用postman配置2个http请求</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/410013ae88514d299a1838742bff18c3.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/0d58e777b7a847e29a4033cd52071a6a.png" alt="在这里插入图片描述"></p></li></ol><h2 id="5-1-问题"><a href="#5-1-问题" class="headerlink" title="5.1 问题"></a>5.1 问题</h2><p>此时使用Postman发送完成后</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/1b0874003c3f4a6b8c230899bfd8bc4b.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/cbc5e4aa165245b3916a857c9e54f62c.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/34a650a4e30f4540a31aadc45c124c55.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/8535a1623be546aaa5578b43bee31bfc.png" alt="在这里插入图片描述"></p><p>此时发现2个请求在查询的时候count都是0，那么说明都是可以下单的，此时说明这个是有问题的。</p><h2 id="5-2-分析"><a href="#5-2-分析" class="headerlink" title="5.2 分析"></a>5.2 分析</h2><p>此时启动的另外一个服务，相当于是新一个JVM。如果在同一个应用下，JVM只有一个，此时锁监视器也只有一个，因此是锁可以实现互斥的，但是现在存在两个JVM，锁监视器在每个JVM中存在一个，因此无法实现互斥</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/7bf47a4fa09246eab959c3f1aea0702a.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis-缓存&amp;逆向工程&amp;分页插件</title>
    <link href="/mybatis-%E7%BC%93%E5%AD%98-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/2990250b4e00/"/>
    <url>/mybatis-%E7%BC%93%E5%AD%98-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/2990250b4e00/</url>
    
    <content type="html"><![CDATA[<h1 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1 缓存"></a>1 缓存</h1><h2 id="1-1-一级缓存"><a href="#1-1-一级缓存" class="headerlink" title="1.1 一级缓存"></a>1.1 一级缓存</h2><ol><li>是默认开启的</li><li>是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问。</li></ol><h3 id="1-1-1-一级缓存失效"><a href="#1-1-1-一级缓存失效" class="headerlink" title="1.1.1 一级缓存失效"></a>1.1.1 一级缓存失效</h3><ol><li>不同的SqlSession对应不同的一级缓存</li><li>同一个SqlSession但是查询条件不同</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li><li>同一个SqlSession两次查询期间手动清空了缓存 （sqlsession.clearCache()）</li></ol><h2 id="1-2-二级缓存"><a href="#1-2-二级缓存" class="headerlink" title="1.2 二级缓存"></a>1.2 二级缓存</h2><ol><li>是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</li></ol><p>开启条件：</p><ol><li>在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;“true”，默认为true，不需要设置</li><li>在映射文件中设置标签&lt; cache &#x2F;&gt;</li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口</li></ol><h3 id="1-2-1-二级缓存失效"><a href="#1-2-1-二级缓存失效" class="headerlink" title="1.2.1 二级缓存失效"></a>1.2.1 二级缓存失效</h3><p>两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p><h2 id="1-3-二级缓存配置"><a href="#1-3-二级缓存配置" class="headerlink" title="1.3 二级缓存配置"></a>1.3 二级缓存配置</h2><p>在mapper配置文件中添加的cache标签可以设置一些属性：</p><p>eviction属性：缓存回收策略 默认的是 LRU。<br>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。<br>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。<br>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。<br>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</p><p>flushInterval属性：刷新间隔，单位毫秒 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</p><p>size属性：引用数目，正整数 代表缓存最多可以存储多少个对象，太大容易导致内存溢出</p><p>readOnly属性：只读，true&#x2F;false<br>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。<br>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。</p><h2 id="1-4-缓存查询的顺序"><a href="#1-4-缓存查询的顺序" class="headerlink" title="1.4 缓存查询的顺序"></a>1.4 缓存查询的顺序</h2><ul><li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。</li><li>如果二级缓存没有命中，再查询一级缓存</li><li>如果一级缓存也没有命中，则查询数据库</li><li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</li></ul><h1 id="2-逆向工程"><a href="#2-逆向工程" class="headerlink" title="2 逆向工程"></a>2 逆向工程</h1><ul><li><p>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程 的。</p></li><li><p>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：</p><ul><li>Java实体类</li><li>Mapper接口</li><li>Mapper映射文件</li></ul></li></ul><h2 id="2-1-添加依赖和插件"><a href="#2-1-添加依赖和插件" class="headerlink" title="2.1 添加依赖和插件"></a>2.1 添加依赖和插件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 依赖MyBatis核心包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 构建过程中用到的插件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 插件的依赖 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 数据库连接池 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- MySQL驱动 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-2-创建Mybatis的核心配置文件"><a href="#2-2-创建Mybatis的核心配置文件" class="headerlink" title="2.2 创建Mybatis的核心配置文件"></a>2.2 创建Mybatis的核心配置文件</h2><h2 id="2-3-创建逆向工程配置文件"><a href="#2-3-创建逆向工程配置文件" class="headerlink" title="2.3 创建逆向工程配置文件"></a>2.3 创建逆向工程配置文件</h2><p>文件名必须是：generatorConfig.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span> <span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--targetRuntime: 执行生成的逆向工程的版本</span><br><span class="hljs-comment">    MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span><br><span class="hljs-comment">    MyBatis3: 生成带条件的CRUD（奢华尊享版） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DB2Tables&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3Simple&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 数据库的连接信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- javaBean的生成策略--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.pojo&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper&quot;</span></span><br><span class="hljs-tag">                         <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\resources&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- Mapper接口的生成策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper&quot;</span></span><br><span class="hljs-tag">                             <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 逆向分析的表 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span><br>        <span class="hljs-comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_emp&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Emp&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_dept&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Dept&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-4-点击执行gerneate目标"><a href="#2-4-点击执行gerneate目标" class="headerlink" title="2.4 点击执行gerneate目标"></a>2.4 点击执行gerneate目标</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/aa6401a00d554b178e0f04cae6b1a015.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/7cd04e6ca0e745e09cbaee40849c1ef6.png" alt="在这里插入图片描述"></p><h1 id="3-分页插件"><a href="#3-分页插件" class="headerlink" title="3 分页插件"></a>3 分页插件</h1><h2 id="3-1-依赖"><a href="#3-1-依赖" class="headerlink" title="3.1 依赖"></a>3.1 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-2-配置分页插件"><a href="#3-2-配置分页插件" class="headerlink" title="3.2 配置分页插件"></a>3.2 配置分页插件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>    <br><span class="hljs-comment">&lt;!--设置分页插件--&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-3-使用"><a href="#3-3-使用" class="headerlink" title="3.3 使用"></a>3.3 使用</h2><ol><li><p>在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能<br>pageNum：当前页的页码<br>pageSize：每页显示的条数</p></li><li><p>在查询获取list集合之后，使用PageInfo pageInfo &#x3D; new PageInfo&lt;&gt;(List list, int navigatePages)获取分页相关数据<br>list：分页之后的数据<br>navigatePages：导航分页的页码数</p></li><li><p>分页相关数据<br>PageInfo{<br>pageNum&#x3D;8, pageSize&#x3D;4, size&#x3D;2, startRow&#x3D;29, endRow&#x3D;30, total&#x3D;30, pages&#x3D;8,<br>list&#x3D;Page{count&#x3D;true, pageNum&#x3D;8, pageSize&#x3D;4, startRow&#x3D;28, endRow&#x3D;32, total&#x3D;30, pages&#x3D;8, reasonable&#x3D;false, pageSizeZero&#x3D;false},<br>prePage&#x3D;7, nextPage&#x3D;0, isFirstPage&#x3D;false, isLastPage&#x3D;true, hasPreviousPage&#x3D;true, hasNextPage&#x3D;false, navigatePages&#x3D;5, navigateFirstPage4, navigateLastPage8, navigatepageNums&#x3D;[4, 5, 6, 7, 8] }</p></li></ol><p>常用数据：<br>pageNum：当前页的页码<br>pageSize：每页显示的条数<br>size：当前页显示的真实条数<br>total：总记录数<br>pages：总页数<br>prePage：上一页的页码<br>nextPage：下一页的页码<br>isFirstPage&#x2F;isLastPage：是否为第一页&#x2F;最后一页<br>hasPreviousPage&#x2F;hasNextPage：是否存在上一页&#x2F;下一页<br>navigatePages：导航分页的页码数<br>navigatepageNums：导航分页的页码，[1,2,3,4,5]</p>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis-动态SQL</title>
    <link href="/mybatis-%E5%8A%A8%E6%80%81SQL/127465e25950/"/>
    <url>/mybatis-%E5%8A%A8%E6%80%81SQL/127465e25950/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决 拼接SQL语句字符串时的痛点问题。</p></blockquote><h1 id="1-if"><a href="#1-if" class="headerlink" title="1 if"></a>1 if</h1><p>if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中 的内容不会执行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpListByMoreTJ(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpListByMoreTJ&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>    select * from t_emp where 1=1<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span><br>        and ename = #&#123;ename&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span><br>        and age = #&#123;age&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span><br>        and sex = #&#123;sex&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2-where"><a href="#2-where" class="headerlink" title="2 where"></a>2 where</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpListByMoreTJ2&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>    select * from t_emp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span><br>            ename = #&#123;ename&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span><br>            and age = #&#123;age&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span><br>            and sex = #&#123;sex&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>where和if一般结合使用： </p><ol><li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字</li><li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的 and去掉 注意：where标签不能去掉条件最后多余的and</li></ol></blockquote><h1 id="3-trim"><a href="#3-trim" class="headerlink" title="3 trim"></a>3 trim</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpListByMoreTJ&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>  select * from t_emp<br>  <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;and&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span><br>          ename = #&#123;ename&#125; and<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span><br>          age = #&#123;age&#125; and<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span><br>          sex = #&#123;sex&#125;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>trim用于去掉或添加标签中的内容<br>常用属性：<br>prefix：在trim标签中的内容的前面添加某些内容<br>prefixOverrides：在trim标签中的内容的前面去掉某些内容<br>suffix：在trim标签中的内容的后面添加某些内容<br>suffixOverrides：在trim标签中的内容的后面去掉某些内容</p></blockquote><h1 id="4-choose-when-otherwise"><a href="#4-choose-when-otherwise" class="headerlink" title="4 choose&#x2F;when&#x2F;otherwise"></a>4 choose&#x2F;when&#x2F;otherwise</h1><p>这个语句就像java中的if..else if..else</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--List&lt;Emp&gt; getEmpListByChoose(Emp emp);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmpListByChoose&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>    select * from t_emp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span><br>                ename = #&#123;ename&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span><br>                age = #&#123;age&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span><br>                sex = #&#123;sex&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != &#x27;&#x27; and email != null&quot;</span>&gt;</span><br>                email = #&#123;email&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="5-foreach"><a href="#5-foreach" class="headerlink" title="5 foreach"></a>5 foreach</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--int insertMoreEmp(List&lt;Emp&gt; emps);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertMoreEmp&quot;</span>&gt;</span><br>    insert into t_emp values<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        (null,#&#123;emp.ename&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--int deleteMoreByArray(int[] eids);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteMoreByArray&quot;</span>&gt;</span><br>    delete from t_emp where<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;eids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span><br>        eid = #&#123;eid&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span> <br><br><span class="hljs-comment">&lt;!--int deleteMoreByArray(int[] eids);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteMoreByArray&quot;</span>&gt;</span><br>    delete from t_emp where eid in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;eids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;eid&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br></code></pre></td></tr></table></figure><blockquote><p>属性：<br>collection：设置要循环的数组或集合<br>item：表示集合或数组中的每一个数据</p><p>separator：设置循环体之间的分隔符</p><p>open：设置foreach标签中的内容的开始符<br>close：设置foreach标签中的内容的结束符</p></blockquote><h1 id="6-SQL片段"><a href="#6-SQL片段" class="headerlink" title="6 SQL片段"></a>6 SQL片段</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empColumns&quot;</span>&gt;</span><br>    eid,ename,age,sex,did<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;deptEmpMap&quot;</span>&gt;</span><br>    select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;empColumns&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span> from t_emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis-特殊SQL执行&amp;自定义resultMap</title>
    <link href="/mybatis-%E7%89%B9%E6%AE%8ASQL%E6%89%A7%E8%A1%8C-%E8%87%AA%E5%AE%9A%E4%B9%89resultMap/7c02110b378d/"/>
    <url>/mybatis-%E7%89%B9%E6%AE%8ASQL%E6%89%A7%E8%A1%8C-%E8%87%AA%E5%AE%9A%E4%B9%89resultMap/7c02110b378d/</url>
    
    <content type="html"><![CDATA[<h1 id="1-特殊SQL"><a href="#1-特殊SQL" class="headerlink" title="1 特殊SQL"></a>1 特殊SQL</h1><h2 id="1-1-模糊查询"><a href="#1-1-模糊查询" class="headerlink" title="1.1 模糊查询"></a>1.1 模糊查询</h2><p>在SQL语句中，使用like关键字进行查询</p><p>推荐使用</p><ol><li><p>${}</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/6e685fc26d974b5a9d340111f393dcc0.png" alt="在这里插入图片描述"></p></li><li><p>concat</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/2bc95a35d7d44506a8cb4be2153d8dce.png" alt="在这里插入图片描述"></p></li><li><p>“%”#{}”%”</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/ae8a42b7f5c947419b633f132b43a8af.png" alt="在这里插入图片描述"></p></li></ol><h2 id="1-2-批量删除"><a href="#1-2-批量删除" class="headerlink" title="1.2 批量删除"></a>1.2 批量删除</h2><p>由于#{}会自动添加””，因此在批量删除的时候使用${}</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/42e01bec768b4bf4b23f5857f5283256.png" alt="在这里插入图片描述"></p><h2 id="1-3-动态设置表名"><a href="#1-3-动态设置表名" class="headerlink" title="1.3 动态设置表名"></a>1.3 动态设置表名</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/4c963feff23a484fa913defc18ab6397.png" alt="在这里插入图片描述"></p><h2 id="1-4-获取自增主键"><a href="#1-4-获取自增主键" class="headerlink" title="1.4 获取自增主键"></a>1.4 获取自增主键</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/61f21275105545cc97db452d09409943.png" alt="在这里插入图片描述"></p><p>注：</p><p>在标签中，</p><ol><li>使用userGeneratedKeys表示当前添加功能使用自增的主键</li><li>使用keyProperty表示将添加的数据自增主键赋值给实体类型对应的属性</li></ol><h1 id="2-自定义映射resultMap"><a href="#2-自定义映射resultMap" class="headerlink" title="2 自定义映射resultMap"></a>2 自定义映射resultMap</h1><p>若字段名和实体类中的属性名不一致，但是字段名符合数据库字段命名规则，实体类中的属性 名符合Java的规则（使用驼峰）<br>此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系<br>a&gt;可以通过为字段起别名的方式，保证和实体类中的属性名保持一致<br>b&gt;可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰<br>例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为 userName</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/6c7aa53ab23a44e0a743e1826ae652a0.png" alt="在这里插入图片描述"></p><h2 id="2-1-别名"><a href="#2-1-别名" class="headerlink" title="2.1 别名"></a>2.1 别名</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/51290bcc5b5c4099b1cef322bd27e49b.png" alt="在这里插入图片描述"></p><h2 id="2-2-全局配置"><a href="#2-2-全局配置" class="headerlink" title="2.2 全局配置"></a>2.2 全局配置</h2><p>将配置文件中设置settings标签，里面将mapUnderscoreToCamelCase设置为true</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/b90ca69407314c4689749999148f24cb.png" alt="在这里插入图片描述"></p><h2 id="2-3-resultMap"><a href="#2-3-resultMap" class="headerlink" title="2.3 resultMap"></a>2.3 resultMap</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/0e5181ced6fd40d1b4bc25f24c8d22e6.png" alt="在这里插入图片描述"></p><h2 id="2-4-多对一映射"><a href="#2-4-多对一映射" class="headerlink" title="2.4 多对一映射"></a>2.4 多对一映射</h2><p>例如：多个员工对应一个部门</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/8218abd41733406da7c462db903775d5.png" alt="在这里插入图片描述"></p><h3 id="2-4-1-使用级联方式处理"><a href="#2-4-1-使用级联方式处理" class="headerlink" title="2.4.1 使用级联方式处理"></a>2.4.1 使用级联方式处理</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/eeb6abf91bdd4019bd6d614bbee31e36.png" alt="在这里插入图片描述"></p><h3 id="2-4-2-使用association处理"><a href="#2-4-2-使用association处理" class="headerlink" title="2.4.2 使用association处理"></a>2.4.2 使用association处理</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/4e54b839d19c404cb9dea6c9b11752ae.png" alt="在这里插入图片描述"></p><p>association就是用来处理多对一的映射关系</p><p>property表示需要处理多对一的属性名</p><p>javaType表示该属性的类型</p><h3 id="2-4-3-分步查询"><a href="#2-4-3-分步查询" class="headerlink" title="2.4.3 分步查询"></a>2.4.3 分步查询</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/4d89accf87144df098bf871f9bcd1734.png" alt="在这里插入图片描述"></p><ol><li>根据多的一方的条件先进行查询，同样使用association处理多对一的关系<ol><li>property 设置实体类中dept对象的映射关系             </li><li>select 设置分布查询中dept对象的属性从另外哪个sql获取,这里取值是mapper接口中方法的全类名             </li><li>column 多表查询中外键字段的字段名</li></ol></li><li>根据一的一方进行查询</li></ol><blockquote><p>分步查询的优点：</p><ol><li>可以实现延迟加载，</li><li>必须在核心配置文件中设置全局配置信息：<ol><li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。</li><li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。</li><li>此时可通过association和 collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType&#x3D;“lazy(延迟加 载)|eager(立即加载)”</li></ol></li></ol></blockquote><h4 id="2-4-3-1-延迟加载"><a href="#2-4-3-1-延迟加载" class="headerlink" title="2.4.3.1 延迟加载"></a>2.4.3.1 延迟加载</h4><p>如果当前只查询员工信息，而不需要部门信息，那么就不会查询部门信息，即：不会进行第二步的查询，可以减少内存的消耗。<br>如果要开启延迟加载，需要开启配置信息</p><h5 id="2-4-3-1-1-lazyLoadingEnabled"><a href="#2-4-3-1-1-lazyLoadingEnabled" class="headerlink" title="2.4.3.1.1 lazyLoadingEnabled"></a>2.4.3.1.1 lazyLoadingEnabled</h5><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/e5c712c9f588470495809dc661f54a09.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/f1656e9d54754fa2b24416407a4ccc5b.png" alt="在这里插入图片描述"></p><h5 id="2-4-3-1-2-aggressiveLazyLoading"><a href="#2-4-3-1-2-aggressiveLazyLoading" class="headerlink" title="2.4.3.1.2 aggressiveLazyLoading"></a>2.4.3.1.2 aggressiveLazyLoading</h5><p>当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/1d718b34bcd1474ea53d061a05f2d605.png" alt="在这里插入图片描述"></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/b92f3e1ca7064d6d850124db2578331b.png" alt="在这里插入图片描述"></p><blockquote><p>此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。</p><p>此时可通过association和 collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType&#x3D;”lazy(延迟加 载)|eager(立即加载)”</p></blockquote><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/a10c2dc09a7a402aa1b1225e8b53b61b.png" alt="在这里插入图片描述"></p><h2 id="2-5-一对多映射"><a href="#2-5-一对多映射" class="headerlink" title="2.5 一对多映射"></a>2.5 一对多映射</h2><p>例如：查询一个部门下的所有员工</p><h3 id="2-5-1-使用collection处理"><a href="#2-5-1-使用collection处理" class="headerlink" title="2.5.1 使用collection处理"></a>2.5.1 使用collection处理</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/e8dfaa899a2e432eb926ab26e98bbb40.png" alt="在这里插入图片描述"></p><p>collection就是用来处理一对多的映射关系</p><p>property表示需要处理一对多的属性名</p><p>ofType表示该属性的类型</p><h3 id="2-5-2-分步查询"><a href="#2-5-2-分步查询" class="headerlink" title="2.5.2 分步查询"></a>2.5.2 分步查询</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/5e42024bd7734684bb6ae7943f2ada88.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis-参数获取&amp;查询</title>
    <link href="/mybatis-%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96-%E6%9F%A5%E8%AF%A2/ce8dcd6d1259/"/>
    <url>/mybatis-%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96-%E6%9F%A5%E8%AF%A2/ce8dcd6d1259/</url>
    
    <content type="html"><![CDATA[<h1 id="0-目录"><a href="#0-目录" class="headerlink" title="0 目录"></a>0 目录</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/image-20240219215146983.png" alt="image-20240219215146983"></p><h1 id="1-参数获取"><a href="#1-参数获取" class="headerlink" title="1 参数获取"></a>1 参数获取</h1><p>MyBatis获取参数值的两种方式：${}和#{}</p><p>${}的本质就是字符串拼接，**#{}的本质就是占位符赋值**</p><p>${}使用字符串拼接的方式拼接sql，<strong>若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号</strong>；</p><p>但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号。</p><h2 id="1-1-单个字面量"><a href="#1-1-单个字面量" class="headerlink" title="1.1 单个字面量"></a>1.1 单个字面量</h2><p>若mapper接口中的方法参数为单个的字面量类型 此时可以使用$ { }和 # { }以任意的名称获取参数的值。</p><p>注意${}需要手动加单引号</p><h2 id="1-2-多个字面量"><a href="#1-2-多个字面量" class="headerlink" title="1.2 多个字面量"></a>1.2 多个字面量</h2><p>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中，以arg0,arg1…为键，以参数为值；以 param1,param2…为键，以参数为值；因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值。</p><p>注意 $ { }需要手动加单引号</p><h2 id="1-3-map集合类型"><a href="#1-3-map集合类型" class="headerlink" title="1.3 map集合类型"></a>1.3 map集合类型</h2><p>若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中 只需要通过 $ {}和#{}访问map集合的键就可以获取相对应的值。</p><p>注意${}需要手动加单引号</p><h2 id="1-4-实体类型"><a href="#1-4-实体类型" class="headerlink" title="1.4 实体类型"></a>1.4 实体类型</h2><p>若mapper接口中的方法参数为实体类对象时<br>此时可以使用$ {}和#{}，通过访问实体类对象中的属性名获取属性值。只跟get&#x2F;set方法有关</p><p>注意${}需要手动加单引号</p><h2 id="1-5-Param"><a href="#1-5-Param" class="headerlink" title="1.5 @Param"></a>1.5 @Param</h2><p>命名参数<br>可以通过@Param注解标识mapper接口中的方法参数<br>此时，会将这些参数放在map集合中，以@Param注解的value属性值为键，以参数为值；以 param1,param2…为键，以参数为值；只需要通过${}和#{}访问map集合的键就可以获取相对应的值。</p><p> 注意 ${}需要手动加单引号</p><h1 id="2-查询"><a href="#2-查询" class="headerlink" title="2 查询"></a>2 查询</h1><h2 id="2-1-查询一个实体类对象"><a href="#2-1-查询一个实体类对象" class="headerlink" title="2.1 查询一个实体类对象"></a>2.1 查询一个实体类对象</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/7cabf542e63c4797b0eb92212f7181d8.png" alt="在这里插入图片描述"></p><h2 id="2-2-查询一个list集合"><a href="#2-2-查询一个list集合" class="headerlink" title="2.2 查询一个list集合"></a>2.2 查询一个list集合</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/b0bc187ef3ab45b8966d03a2ac9b94b8.png" alt="在这里插入图片描述"></p><h2 id="2-3-查询单个数据"><a href="#2-3-查询单个数据" class="headerlink" title="2.3 查询单个数据"></a>2.3 查询单个数据</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/b0405dadafee447cb3e3eb9bf469774c.png" alt="在这里插入图片描述"></p><h2 id="2-4-查询一条数据为map的集合"><a href="#2-4-查询一条数据为map的集合" class="headerlink" title="2.4 查询一条数据为map的集合"></a>2.4 查询一条数据为map的集合</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/4ae0054addb741278f9de439acd89fc2.png" alt="在这里插入图片描述"></p><h2 id="2-5-查询多条数据为map集合"><a href="#2-5-查询多条数据为map集合" class="headerlink" title="2.5 查询多条数据为map集合"></a>2.5 查询多条数据为map集合</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/6d9cf111808d472bb82db8aaf63093d6.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis-环境搭建</title>
    <link href="/mybatis-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/64bafa7e8456/"/>
    <url>/mybatis-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/64bafa7e8456/</url>
    
    <content type="html"><![CDATA[<h1 id="0-目录"><a href="#0-目录" class="headerlink" title="0 目录"></a>0 目录</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Mybatis/image-20240219205704269.png" alt="image-20240219205704269"></p><h1 id="1-Maven工程"><a href="#1-Maven工程" class="headerlink" title="1 Maven工程"></a>1 Maven工程</h1><ol><li><p>设置打包方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xxxx.xxx<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>MyBatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Mybatis核心 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- junit测试 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- MySQL驱动 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="2-数据库准备"><a href="#2-数据库准备" class="headerlink" title="2 数据库准备"></a>2 数据库准备</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_user` (<br>  `id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `username` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `password` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `gender` <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `email` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_general_ci;<br><br></code></pre></td></tr></table></figure><h1 id="3-创建Mybatis核心文件"><a href="#3-创建Mybatis核心文件" class="headerlink" title="3 创建Mybatis核心文件"></a>3 创建Mybatis核心文件</h1><p>核心文件取名：mybatis-config.xml，存放位置src&#x2F;main&#x2F;resources</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--设置连接数据库的环境--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入mybatis映射文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="4-实体类、mapper接口"><a href="#4-实体类、mapper接口" class="headerlink" title="4 实体类、mapper接口"></a>4 实体类、mapper接口</h1><ol><li><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>  <span class="hljs-keyword">private</span> Integer id;<br><br>  <span class="hljs-keyword">private</span> String username;<br><br>  <span class="hljs-keyword">private</span> String password;<br><br>  <span class="hljs-keyword">private</span> Integer age;<br><br>  <span class="hljs-keyword">private</span> String gender;<br><br>  <span class="hljs-keyword">private</span> String email;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-comment">//添加用户信息</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h1 id="5-映射文件"><a href="#5-映射文件" class="headerlink" title="5 映射文件"></a>5 映射文件</h1><blockquote><ol><li>mapper接口的全类名和映射文件的命名空间（namespace）保持一致，在resource下使用&#x2F;代替.</li><li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</li></ol></blockquote><p>UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.xxxx.xxx.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        mapper接口和映射文件要保证两个一致：</span><br><span class="hljs-comment">        1.mapper接口的全类名和映射文件的namespace一致</span><br><span class="hljs-comment">        2.mapper接口中的方法的方法名要和映射文件中的sql语句的id保持一致</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-comment">&lt;!--添加--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>        insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;男&#x27;,&quot;123@163.com&quot;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="6-测试"><a href="#6-测试" class="headerlink" title="6 测试"></a>6 测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisTest</span> &#123;<br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsertUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>      <span class="hljs-comment">//获取核心配置文件的输入流</span><br>      <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>      <span class="hljs-comment">//获取SqlSessionFactoryBuilder对象</span><br>      <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>      <span class="hljs-comment">//获取SqlSessionFactory对象</span><br>      <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(inputStream);<br>      <span class="hljs-comment">//获取sql的会话对象SqlSession(不会自动提交事务)，是MyBatis提供的操作数据库的对象</span><br>      <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>      <span class="hljs-comment">//获取sql的会话对象SqlSession(会自动提交事务)，是MyBatis提供的操作数据库的对象</span><br>      <span class="hljs-comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br>      <span class="hljs-comment">//获取UserMapper的代理实现对象getMapper(Class&lt;T&gt; var1)</span><br>      <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>      <span class="hljs-comment">//调用mapper接口中的方法，实现添加用户信息的功能</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.insertUser();<br>      <span class="hljs-comment">//通过sql语句的唯一标识找到sql并执行，唯一标识是namespace.sqlId</span><br>      <span class="hljs-comment">//int result = sqlSession.insert(&quot;com.xxxx.lln.mapper.UserMapper.insertUser&quot;);</span><br>      System.out.println(<span class="hljs-string">&quot;返回结果：&quot;</span>+result);<br>      <span class="hljs-comment">//提交事务</span><br>      sqlSession.commit();<br>      <span class="hljs-comment">//关闭会话</span><br>      sqlSession.close();<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-日志"><a href="#7-日志" class="headerlink" title="7 日志"></a>7 日志</h1><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- log4j日志 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li><li><p>log4j.xml，位置src&#x2F;main&#x2F;resources</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">log4j</span>:configuration <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;log4j.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">log4j:configuration</span> <span class="hljs-attr">xmlns:log4j</span>=<span class="hljs-string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Encoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ConversionPattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125;</span></span><br><span class="hljs-string"><span class="hljs-tag">%m (%F:%L) \n&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debug&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.ibatis&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;info&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debug&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">log4j:configuration</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li></ol><h1 id="8-工具类"><a href="#8-工具类" class="headerlink" title="8 工具类"></a>8 工具类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlSessionUtil</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//创建sql的会话对象SqlSession</span><br>      <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//获取核心配置文件的输入流</span><br>          <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>          <span class="hljs-comment">//获取SqlSessionFactoryBuilder对象</span><br>          <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>          <span class="hljs-comment">//获取SqlSessionFactory对象</span><br>          <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(inputStream);<br>          <span class="hljs-comment">//配置sql的会话对象SqlSession(会自动提交事务)，是MyBatis提供的操作数据库的对象</span><br>          sqlSession = sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>      &#125;<br>      <span class="hljs-keyword">return</span> sqlSession;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="9-增删改查"><a href="#9-增删改查" class="headerlink" title="9 增删改查"></a>9 增删改查</h1><ol><li><p>mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br><br>  <span class="hljs-comment">//添加用户信息</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">//删除用户信息</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteUser</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">//修改用户信息</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">//通过id查询一个实体类对象</span><br>  User <span class="hljs-title function_">getUserById</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">//查询实体类集合</span><br>  List&lt;User&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.xxxx.xxx.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        mapper接口和映射文件要保证两个一致：</span><br><span class="hljs-comment">        1.mapper接口的全类名和映射文件的namespace一致</span><br><span class="hljs-comment">        2.mapper接口中的方法的方法名要和映射文件中的sql语句的id保持一致</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-comment">&lt;!--添加用户信息--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>        insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;男&#x27;,&quot;123@163.com&quot;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--删除用户信息--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span>&gt;</span><br>        delete from t_user where id = 2<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--修改用户信息--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span>&gt;</span><br>        update t_user set username=&#x27;ybc&#x27;,password=&#x27;123&#x27; where id = 3<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        resultType：自动映射，用于属性名和表中字段名一致的情况</span><br><span class="hljs-comment">        resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-comment">&lt;!--通过id查询一个实体类对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.xxxx.lln.pojo.User&quot;</span>&gt;</span><br>        select * from t_user where id = 3<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--查询实体类集合--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.xxxx.lln.pojo.User&quot;</span>&gt;</span><br>        select * from t_user<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>代码测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisTest</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试添加用户信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsertUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//获取核心配置文件的输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        <span class="hljs-comment">//获取SqlSessionFactoryBuilder对象</span><br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">sqlSessionFactoryBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>        <span class="hljs-comment">//获取SqlSessionFactory对象</span><br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> sqlSessionFactoryBuilder.build(inputStream);<br>        <span class="hljs-comment">//获取sql的会话对象SqlSession(不会自动提交事务)，是MyBatis提供的操作数据库的对象</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>        <span class="hljs-comment">//获取sql的会话对象SqlSession(会自动提交事务)，是MyBatis提供的操作数据库的对象</span><br>        <span class="hljs-comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br>        <span class="hljs-comment">//获取UserMapper的代理实现对象getMapper(Class&lt;T&gt; var1)</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-comment">//调用mapper接口中的方法，实现添加用户信息的功能</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.insertUser();<br>        <span class="hljs-comment">//通过sql语句的唯一标识找到sql并执行，唯一标识是namespace.sqlId</span><br>        <span class="hljs-comment">//int result = sqlSession.insert(&quot;com.xxxx.lln.mapper.UserMapper.insertUser&quot;);</span><br>        System.out.println(<span class="hljs-string">&quot;返回结果：&quot;</span>+result);<br>        <span class="hljs-comment">//提交事务</span><br>        sqlSession.commit();<br>        <span class="hljs-comment">//关闭会话</span><br>        sqlSession.close();<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试删除用户信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtil.getSqlSession();<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        userMapper.deleteUser();<br>        sqlSession.close();<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试修改用户信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtil.getSqlSession();<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        userMapper.updateUser();<br>        sqlSession.close();<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过id查询一个实体类对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetUserById</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtil.getSqlSession();<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.getUserById();<br>        System.out.println(user);<br>        sqlSession.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询实体类对象集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetUserList</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtil.getSqlSession();<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        List&lt;User&gt; userList = userMapper.getUserList();<br>userList.forEach(System.out::println);<br>        sqlSession.close();<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><ol><li><p>查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系</p><ol><li>resultType：自动映射，用于属性名和表中字段名一致的情况</li><li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li></ol></li><li><p>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常</p><p>TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</p></li></ol></blockquote><h1 id="10-核心文件详解"><a href="#10-核心文件详解" class="headerlink" title="10 核心文件详解"></a>10 核心文件详解</h1><p>顺序：</p><p>properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,</p><p>reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--开启延迟加载--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            typeAlias：设置某个具体的类型的别名</span><br><span class="hljs-comment">            属性： type：需要设置别名的类型的全类名</span><br><span class="hljs-comment">            alias：设置此类型的别名，若不设置此属性，该类型拥有默认的别名，即类名且不区分大小写</span><br><span class="hljs-comment">            若设置此属性，此时该类型的别名只能使用alias所设置的值</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;abc&quot;&gt; &lt;/typeAlias&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.bean&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--environments：设置多个连接数据库的环境 属性： default：设置默认使用的环境的id --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;mysql_test&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            environment：设置具体的连接数据库的环境信息</span><br><span class="hljs-comment">            属性： id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id， 表示默认使用的环境</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql_test&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">                transactionManager：设置事务管理方式 属性：</span><br><span class="hljs-comment">                type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot; type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span><br><span class="hljs-comment">                type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span><br><span class="hljs-comment">            --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br><br><br>            <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">                dataSource：设置数据源</span><br><span class="hljs-comment">                属性：type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span><br><span class="hljs-comment">                type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span><br><span class="hljs-comment">                type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span><br><span class="hljs-comment">                type=&quot;JNDI&quot;：调用上下文中的数据源</span><br><span class="hljs-comment">            --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--设置驱动类的全类名--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-comment">&lt;!--设置连接数据库的连接地址--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-comment">&lt;!--设置连接数据库的用户名--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-comment">&lt;!--设置连接数据库的密码--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><br><br><br>    <span class="hljs-comment">&lt;!--引入映射文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;UserMapper.xml&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            以包为单位，将包下所有的映射文件引入核心配置文件</span><br><span class="hljs-comment">            注意：此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span><br><span class="hljs-comment">            接口名和映射文件名字一致</span><br><span class="hljs-comment">            创建包的时候以斜线为分隔符</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis-缓存</title>
    <link href="/redis-%E7%BC%93%E5%AD%98/22e726666a0f/"/>
    <url>/redis-%E7%BC%93%E5%AD%98/22e726666a0f/</url>
    
    <content type="html"><![CDATA[<h1 id="0-目录"><a href="#0-目录" class="headerlink" title="0 目录"></a>0 目录</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240217144633116.png" alt="image-20240217144633116"></p><h1 id="1-什么是缓存"><a href="#1-什么是缓存" class="headerlink" title="1 什么是缓存"></a>1 什么是缓存</h1><p>缓存就是数据交换的缓冲区（称作Cache），是存储数据的临时地方，一般读写性能较高</p><h2 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h2><ul><li>降低后端负载</li><li>提高读写效率，降低响应时间</li></ul><h2 id="1-2-成本"><a href="#1-2-成本" class="headerlink" title="1.2 成本"></a>1.2 成本</h2><ul><li>数据一致性成本</li><li>代码维护成本</li><li>运维成本</li></ul><h1 id="2-添加Redis缓存"><a href="#2-添加Redis缓存" class="headerlink" title="2 添加Redis缓存"></a>2 添加Redis缓存</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/f5fab07a6b6c428686526e0703545046.png" alt="img"></p><ul><li>即：在客户端和数据库之间加一层redis，这样就可以减轻数据库的压力。</li></ul><h1 id="3-缓存更新策略"><a href="#3-缓存更新策略" class="headerlink" title="3 缓存更新策略"></a>3 缓存更新策略</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/fab53328769e46539e642d34dad23b6b.png" alt="img"></p><h2 id="3-1-具体业务场景"><a href="#3-1-具体业务场景" class="headerlink" title="3.1 具体业务场景"></a>3.1 具体业务场景</h2><ul><li><p>低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存</p></li><li><p>高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存</p></li></ul><h2 id="3-2-主动更新策略"><a href="#3-2-主动更新策略" class="headerlink" title="3.2 主动更新策略"></a>3.2 主动更新策略</h2><p>即：由缓存调用者在更新数据库的同时更新缓存。</p><h3 id="3-2-1-注意点"><a href="#3-2-1-注意点" class="headerlink" title="3.2.1 注意点"></a>3.2.1 注意点</h3><ul><li>删除还是更新缓存？<ul><li>更新缓存：每次更新都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存（胜出）</li></ul></li><li>如何保证缓存和数据库的操作的同时成功或失败？<ul><li>更新缓存：每次更新都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存（胜出）</li></ul></li><li>先操作缓存还是先操作数据库？<ul><li>先操作数据库再删缓存，因为出现数据不一致的前提：1.  刚好缓存失效；2. 另一个线程写入时间在前一个线程查询数据库到写入缓存的几短时间内进行了更新操作</li></ul></li></ul><blockquote><ul><li>读操作：<ul><li>缓存命中就返回</li><li>缓存没有命中查数据库，写入缓存同时设定超时时间</li></ul></li><li>写操作：<ul><li>先写数据库再删缓存</li><li>确保数据库和缓存操作的原子性</li></ul></li></ul></blockquote><h2 id="3-3-实现缓存和数据库的双写一致"><a href="#3-3-实现缓存和数据库的双写一致" class="headerlink" title="3.3 实现缓存和数据库的双写一致"></a>3.3 实现缓存和数据库的双写一致</h2><p>在单体系统中，更新方法使用<code>@Transactional</code>对方法进行标记</p><h1 id="4-缓存穿透"><a href="#4-缓存穿透" class="headerlink" title="4 缓存穿透"></a>4 缓存穿透</h1><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/ae54cd7944a94a66b442ccccf97e56d3.png" alt="img"></p><h2 id="4-1-解决"><a href="#4-1-解决" class="headerlink" title="4.1 解决"></a>4.1 解决</h2><ol><li><p>缓存null值</p></li><li><p>布隆过滤</p></li><li><p>增强id的复杂度，避免被猜测id规律</p></li><li><p>做好数据的基础格式校验</p></li><li><p>加强用户权限校验</p></li><li><p>做好热点参数的限流</p></li></ol><h3 id="4-1-1-空值解决"><a href="#4-1-1-空值解决" class="headerlink" title="4.1.1 空值解决"></a>4.1.1 空值解决</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/477d7458be374f6da2c101233ee80aac.png" alt="img"></p><p>步骤</p><ol><li>当缓存没有命中的时候，查询数据库</li><li>判断数据库的数据是否存在<ol><li>存在：将数据写入缓存同时返回</li><li>不存在：写入空值到缓存</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>    String key=CACHE_SHOP_KEY+id;<br>    <span class="hljs-comment">//1.从redis查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-comment">//2.判断是否存在</span><br>    <span class="hljs-keyword">if</span>(StrUtil.isNotBlank(shopJson)) &#123;<br>        <span class="hljs-comment">//3.存在，直接返回</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br>    <span class="hljs-comment">//命中的是否为空值</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;&#x27;</span>.equals(shopJson))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺信息不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//4.不存在，根据id查询数据库</span><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-comment">//5.不存在，返回错误</span><br>    <span class="hljs-keyword">if</span>(shop==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//将空值写入redis</span><br>        stringRedisTemplate.opsForValue().set(key,<span class="hljs-string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺信息不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//6.存在，写入redis</span><br>    stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-comment">//7.返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-缓存雪崩"><a href="#5-缓存雪崩" class="headerlink" title="5 缓存雪崩"></a>5 缓存雪崩</h1><p>缓存雪崩是指同一时刻大量的缓存key同时失效或者redis服务宕机，导致大量请求到达数据库，带来巨大压力</p><h2 id="5-1-解决"><a href="#5-1-解决" class="headerlink" title="5.1 解决"></a>5.1 解决</h2><p>给不同的Key的TTL添加随机值</p><p>利用Redis集群提高服务的可用性</p><p>给缓存业务添加降级限流策略</p><p>给业务添加多级缓存</p><h1 id="6-缓存击穿"><a href="#6-缓存击穿" class="headerlink" title="6 缓存击穿"></a>6 缓存击穿</h1><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/c21f331b1b9e45cfb8bc40d960a1c21e.png" alt="img"></p><h2 id="6-1-解决"><a href="#6-1-解决" class="headerlink" title="6.1 解决"></a>6.1 解决</h2><blockquote><p>前言：涉及到互斥锁，使用redis的一个命令：setnx</p></blockquote><h3 id="6-1-1-互斥锁解决"><a href="#6-1-1-互斥锁解决" class="headerlink" title="6.1.1 互斥锁解决"></a>6.1.1 互斥锁解决</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240218202535260.png" alt="image-20240218202535260"></p><p>即：当第一个线程查询缓存的时候，没有实现命中，此时第一个线程开始获取互斥锁，当锁获取成功之后，开始查询数据库进行缓存的重建，查询完成之后写入缓存，最后释放锁</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/f30a477e296542b888949cfcb0d2f356.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(Long id)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY+id;<br>    <span class="hljs-comment">//从redis查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-comment">//判断缓存是否命中</span><br>    <span class="hljs-keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;<br>        <span class="hljs-comment">//命中则直接返回数据</span><br>        <span class="hljs-keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);<br>    &#125;<br>    <span class="hljs-comment">//判断是否是缓存穿透</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;&#x27;</span>.equals(shopJson))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//实现缓存重建</span><br>    <span class="hljs-comment">//1.获取互斥锁</span><br>    String lockKey=LOCK_SHOP_KEY+id;<br>   <span class="hljs-keyword">try</span>&#123;<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>       <span class="hljs-comment">//2.判断是否获取成功</span><br>       <span class="hljs-keyword">if</span>(!isLock) &#123;<br>           <span class="hljs-comment">//3.失败，则休眠并重试</span><br>           Thread.sleep(<span class="hljs-number">50</span>);<br>           queryWithMutex(id);<br>       &#125;<br>      <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 此时锁获取成功之后，应该再查询一下缓存，实现双重检查</span><br>       <span class="hljs-comment">//4.成功，根据id查询数据库</span><br>       <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);<br>       <span class="hljs-comment">//5.不存在，返回错误</span><br>       <span class="hljs-keyword">if</span>(shop==<span class="hljs-literal">null</span>)&#123;<br>           stringRedisTemplate.opsForValue().set(key,<span class="hljs-string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>       <span class="hljs-comment">//6.存在，写入redis</span><br>       stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL,TimeUnit.MINUTES);<br>       <span class="hljs-keyword">return</span> shop;<br>   &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>   &#125;<span class="hljs-keyword">finally</span>&#123;<br>       unlock(lockKey);<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span>&#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, LOCK_SHOP_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag); <span class="hljs-comment">//为防止程序在拆箱的时候出现空指针，要手动拆箱</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span>&#123;<br>    stringRedisTemplate.delete(key);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-1-2-逻辑过期解决"><a href="#6-1-2-逻辑过期解决" class="headerlink" title="6.1.2 逻辑过期解决"></a>6.1.2 逻辑过期解决</h3><ul><li>热点key需要先进行预热，将相关数据先放入缓存中，设定的过期时间不是redis的TTL，而是一个逻辑上认定会过期的时间</li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240218202644763.png" alt="image-20240218202644763"></p><p>即：当缓存命中的时候，判断设定的缓存逻辑时间是否过期，如果没有，那么就直接返回数据信息；如果过期了，先尝试获取互斥锁，当获取到锁，如果获取锁失败了，将旧数据返回即可；如果获取锁成功，那么开启一个独立的线程进行查询数据库，写入缓存，以及设定逻辑过期时间，最后释放互斥锁。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/a44029589bb94df680da373e291c346f.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExecutorService CACHE_REBUILD_EXECUTOR= Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(Long id)</span>&#123;<br>    String key=CACHE_SHOP_KEY+id;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-comment">//缓存未命中</span><br>    <span class="hljs-keyword">if</span>(StrUtil.isBlank(shopJson))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//命中，需要先把json反序列化为对象</span><br>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);<br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);<br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>    <span class="hljs-comment">//判断是否过期</span><br>    <span class="hljs-keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">//未过期,直接返回店铺信息</span><br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br>    <span class="hljs-comment">//已过期，需要缓存重建</span><br>    String lockKey=LOCK_SHOP_KEY+id;<br>    <span class="hljs-comment">//获取互斥锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>    <span class="hljs-comment">//判断是否获取锁成功</span><br>    <span class="hljs-keyword">if</span>(isLock) &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 获取锁成功之后，再尝试获取一下缓存数据，没有就开启独立线程实现缓存重建</span><br>        <span class="hljs-comment">//成功，开启独立线程，实现缓存重建</span><br>        CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                saveShop2Redis(id, CACHE_SHOP_TTL);<br>            &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<span class="hljs-keyword">finally</span>&#123;<br>                unlock(lockKey);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">//返过期的商铺信息</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span>&#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, LOCK_SHOP_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag); <span class="hljs-comment">//为防止程序在拆箱的时候出现空指针，要手动拆箱</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span>&#123;<br>    stringRedisTemplate.delete(key);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveShop2Redis</span><span class="hljs-params">(Long id,Long expireSeconds)</span>&#123;<br>    <span class="hljs-comment">//1.查询店铺数据</span><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-comment">//2.封装逻辑过期时间</span><br>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisData</span>();<br>    redisData.setData(shop);<br>    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));<br>    <span class="hljs-comment">//3.写入Redis</span><br>    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-缓存工具类"><a href="#7-缓存工具类" class="headerlink" title="7 缓存工具类"></a>7 缓存工具类</h1><p>需要满足以下4个要求：</p><ol><li>任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li><li>将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题</li><li>根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li><li>根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheClient</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">CacheClient</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span>&#123;<br>      <span class="hljs-built_in">this</span>.stringRedisTemplate=stringRedisTemplate;<br>  &#125;<br><br>  <span class="hljs-comment">// 任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span>&#123;<br>      stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value),time,unit);<br>  &#125;<br>  <br><br>  <span class="hljs-comment">// 将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWithLogicalExpire</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span>&#123;<br>      <span class="hljs-comment">//设置逻辑过期</span><br>      <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisData</span>();<br>      redisData.setData(value);<br>      redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));<br>      stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));<br>  &#125;<br><br>  <span class="hljs-comment">// 根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</span><br>  <span class="hljs-keyword">public</span> &lt;R,ID&gt; R <span class="hljs-title function_">queryWithPassThrough</span><span class="hljs-params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID,R&gt;dbFallback,Long time,TimeUnit unit)</span>&#123;<br>      String key=keyPrefix+id;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>      <span class="hljs-keyword">if</span>(StrUtil.isNotBlank(json))&#123;<br>          <span class="hljs-keyword">return</span> JSONUtil.toBean(json,type);<br>      &#125;<br>      <span class="hljs-comment">//判断命中的是否为空值</span><br>      <span class="hljs-keyword">if</span>(json!=<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dbFallback.apply(id);<br>      <span class="hljs-keyword">if</span>(r==<span class="hljs-literal">null</span>)&#123;<br>          stringRedisTemplate.opsForValue().set(key,<span class="hljs-string">&quot;&quot;</span>,time,unit);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-built_in">this</span>.set(key,r,time,unit);<br>      <span class="hljs-keyword">return</span> r;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExecutorService CACHE_REBUILD_EXECUTOR= Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>  <span class="hljs-comment">// 根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</span><br>  <span class="hljs-keyword">public</span> &lt;R,ID&gt; R <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(String keyPrefix,ID id,Class&lt;R&gt; type,Function&lt;ID,R&gt;dbFallback,Long time,TimeUnit unit)</span>&#123;<br>      String key=keyPrefix+id;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>      <span class="hljs-keyword">if</span>(StrUtil.isBlank(json))&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, RedisData.class);<br>      <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);<br>      <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>      <span class="hljs-comment">//判断是否过期</span><br>      <span class="hljs-keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;<br>          <span class="hljs-comment">//未过期，直接返回店铺信息</span><br>          <span class="hljs-keyword">return</span> r;<br>      &#125;<br>      <span class="hljs-comment">//已过期，需要缓存重建</span><br>      String lockKey=LOCK_SHOP_KEY+id;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>      <span class="hljs-keyword">if</span>(isLock)&#123;<br>          CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;<br>              <span class="hljs-keyword">try</span>&#123;<br>                  <span class="hljs-comment">//重建缓存</span><br>                  <span class="hljs-comment">//1.查询数据库</span><br>                  <span class="hljs-type">R</span> <span class="hljs-variable">apply</span> <span class="hljs-operator">=</span> dbFallback.apply(id);<br>                  <span class="hljs-comment">//2.存入redis</span><br>                  <span class="hljs-built_in">this</span>.setWithLogicalExpire(key,apply,time,unit);<br>              &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>              &#125;<span class="hljs-keyword">finally</span>&#123;<br>                  unlock(key);<br>              &#125;<br>          &#125;);<br>      &#125;<br>      <span class="hljs-keyword">return</span> r;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span>&#123;<br>      Boolean flag=stringRedisTemplate.opsForValue().setIfAbsent(key,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS);<br>      <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span>&#123;<br>      stringRedisTemplate.delete(key);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis-短信验证登录</title>
    <link href="/redis-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95/6c096f110ba0/"/>
    <url>/redis-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95/6c096f110ba0/</url>
    
    <content type="html"><![CDATA[<h1 id="0-目录"><a href="#0-目录" class="headerlink" title="0 目录"></a>0 目录</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240218210105896.png" alt="image-20240218210105896"></p><h1 id="1-基于session实现登录"><a href="#1-基于session实现登录" class="headerlink" title="1 基于session实现登录"></a>1 基于session实现登录</h1><h2 id="1-1-发送短信验证码"><a href="#1-1-发送短信验证码" class="headerlink" title="1.1 发送短信验证码"></a>1.1 发送短信验证码</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240218210209795.png" alt="image-20240218210209795"></p><p>即：将生成的验证码保存到session中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">//1.校验手机号</span><br>    <span class="hljs-keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;<br>        <span class="hljs-comment">//2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3.符合，生成验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br>    <span class="hljs-comment">//4.保存验证码到session</span><br>    session.setAttribute(<span class="hljs-string">&quot;code&quot;</span>,code);<br>    <span class="hljs-comment">//5.模拟发送验证码</span><br>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>+code);<br>    <span class="hljs-comment">//返回ok</span><br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-短信验证码注册登录"><a href="#1-2-短信验证码注册登录" class="headerlink" title="1.2 短信验证码注册登录"></a>1.2 短信验证码注册登录</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240218210311253.png" alt="image-20240218210311253"></p><p>即：校验完成验证码之后，根据用户手机号去数据库查询，查询用户如果不存在，那么就创建用户，将创建的心用户保存到数据库中；如果查询到用户存在，那么将用户信息保存到session中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginFormDTO</span> &#123;<br>    <span class="hljs-keyword">private</span> String phone;<br>    <span class="hljs-keyword">private</span> String code;<br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">//1.校验手机号</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;<br>        <span class="hljs-comment">//如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//2.校验验证码</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;code&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>    <span class="hljs-keyword">if</span>(cacheCode==<span class="hljs-literal">null</span> ||! cacheCode.toString().equals(code))&#123;<br>        <span class="hljs-comment">//3.不一致，报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br>    <span class="hljs-comment">//5.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//6.不存在，创建新用户并保存</span><br>        user=createUsrWithPhone(phone);<br>    &#125;<br>    <span class="hljs-comment">//7.保存用户信息到session中</span><br>    session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;   <br>&#125;<br><br><span class="hljs-keyword">private</span> User <span class="hljs-title function_">createUsrWithPhone</span><span class="hljs-params">(String phone)</span> &#123;<br>    <span class="hljs-comment">//1.创建用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setPhone(phone);<br>    user.setNickName(USER_NICK_NAME_PREFIX+RandomUtil.randomString(<span class="hljs-number">10</span>));<br>    <span class="hljs-comment">//2.保存用户</span><br>    save(user);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-校验登录状态"><a href="#1-3-校验登录状态" class="headerlink" title="1.3 校验登录状态"></a>1.3 校验登录状态</h2><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240218210437940.png" alt="image-20240218210437940"></p><p>即：从拦截器拦截请求之后，从request中获取到cookie，由cookie获取session进而获取到用户信息，此时判断用户是否存在，如果用户不存在进行拦截，用户存在就将用户数据保存到ThreadLocal中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserHolder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">(UserDTO user)</span>&#123;<br>        tl.set(user);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDTO <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> tl.get();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeUser</span><span class="hljs-params">()</span>&#123;<br>        tl.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-登录校验拦截器"><a href="#2-登录校验拦截器" class="headerlink" title="2 登录校验拦截器"></a>2 登录校验拦截器</h1><h2 id="2-1-拦截器"><a href="#2-1-拦截器" class="headerlink" title="2.1 拦截器"></a>2.1 拦截器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1.获取session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">//2.获取session中的用户</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">//3.判断用户是否存在</span><br>        <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//4.不存在，拦截,返回401状态码，代表未授权</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//5.存在，保存用户信息到ThreadLocal</span><br>        UserHolder.saveUser((UserDTO) user);<br>        <span class="hljs-comment">//6.放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-添加拦截器"><a href="#2-2-添加拦截器" class="headerlink" title="2.2 添加拦截器"></a>2.2 添加拦截器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>                .excludePathPatterns(<span class="hljs-string">&quot;/user/code&quot;</span>,<span class="hljs-string">&quot;/user/login&quot;</span>,<span class="hljs-string">&quot;/blog/hot&quot;</span>,<span class="hljs-string">&quot;/shop/**&quot;</span>,<span class="hljs-string">&quot;/shop-type/**&quot;</span>,<span class="hljs-string">&quot;/voucher/**&quot;</span>,<span class="hljs-string">&quot;/upload/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-session共享问题"><a href="#3-session共享问题" class="headerlink" title="3 session共享问题"></a>3 session共享问题</h1><p>session共享问题：多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/7d7d1467d2fd4e48a88c912e3dfbfaa8.png" alt="img"></p><h1 id="4-Redis替换session业务"><a href="#4-Redis替换session业务" class="headerlink" title="4 Redis替换session业务"></a>4 Redis替换session业务</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/4d931c795aa64ee8b9cfd3b759d0edbc.png" alt="img"></p><h1 id="5-基于Redis实现短信登录"><a href="#5-基于Redis实现短信登录" class="headerlink" title="5 基于Redis实现短信登录"></a>5 基于Redis实现短信登录</h1><h2 id="5-1-发送验证码"><a href="#5-1-发送验证码" class="headerlink" title="5.1 发送验证码"></a>5.1 发送验证码</h2><p>流程修改：生成验证码后，将验证码放入至redis并且设置过期时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">//1.校验手机号</span><br>    <span class="hljs-keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;<br>        <span class="hljs-comment">//2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3.符合，生成验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br>    <span class="hljs-comment">//4.保存验证码到redis中</span><br>    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY+phone,code,LOGIN_CODE_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-comment">//5.发送验证码</span><br>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>+code);<br>    <span class="hljs-comment">//返回ok</span><br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-验证码登录"><a href="#5-2-验证码登录" class="headerlink" title="5.2 验证码登录"></a>5.2 验证码登录</h2><p>修改：校验的时候，客户端传入的验证码和redis中的验证码进行比对，随后需要将用户信息保存到redis中，此时选择使用Hash结构存储用户信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">//1.校验手机号</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;<br>        <span class="hljs-comment">//如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//2.校验验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>    <span class="hljs-keyword">if</span>(cacheCode==<span class="hljs-literal">null</span> ||!cacheCode.equals(code))&#123;<br>        <span class="hljs-comment">//3.不一致，报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br>    <span class="hljs-comment">//5.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span>(user==<span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//6.不存在，创建新用户并保存</span><br>        user=createUsrWithPhone(phone);<br>    &#125;<br>    <span class="hljs-comment">//保存用户信息到redis中</span><br>    <span class="hljs-comment">//1.随机生成token，作为登录令牌</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);  <span class="hljs-comment">//true代表isSimple，即不带中划线</span><br>    <span class="hljs-comment">//2.将User对象转为Hash存储</span><br>    UserDTO userDTO=BeanUtil.copyProperties(user,UserDTO.class);<br>    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), CopyOptions.create().setIgnoreNullValue(<span class="hljs-literal">true</span>).setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString()));<br>    String tokenKey=LOGIN_USER_KEY+token;<br>    <span class="hljs-comment">//7.存储</span><br>    stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);<br>    <span class="hljs-comment">//设置token有效期</span><br>    stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL,TimeUnit.MINUTES);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br><br><span class="hljs-keyword">private</span> User <span class="hljs-title function_">createUsrWithPhone</span><span class="hljs-params">(String phone)</span> &#123;<br>    <span class="hljs-comment">//1.创建用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setPhone(phone);<br>    user.setNickName(USER_NICK_NAME_PREFIX+RandomUtil.randomString(<span class="hljs-number">10</span>));<br>    <span class="hljs-comment">//2.保存用户</span><br>    save(user);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-3-拦截器修改"><a href="#5-3-拦截器修改" class="headerlink" title="5.3 拦截器修改"></a>5.3 拦截器修改</h2><p>修改：此时获取的用户信息是从redis中获取而不是从session获取。查询到用户信息之后将Hash数据转为UserDto对象，再存入ThreadLocal中，同时刷新token的有效期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoginInterceptor</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span>&#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate=stringRedisTemplate;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1.获取请求头中的token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-comment">//判断token是否为空</span><br>        <span class="hljs-keyword">if</span>(StrUtil.isBlank(token))&#123;<br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        String key=LOGIN_USER_KEY+token;<br>        <span class="hljs-comment">//2.基于token获取redis中的用户</span><br>        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);<br>        <span class="hljs-comment">//3.判断用户是否存在</span><br>        <span class="hljs-keyword">if</span>(userMap.isEmpty())&#123;<br>            <span class="hljs-comment">//不存在，拦截，返回401状态码</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//5.存在，将查询到的Hash数据转为UserDTO对象</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//6.保存用户到ThreadLocal</span><br>        UserHolder.saveUser(userDTO);<br>        <span class="hljs-comment">//7.刷新token有效期</span><br>        stringRedisTemplate.expire(key,LOGIN_USER_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-comment">//8.放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-登录状态刷新问题"><a href="#6-登录状态刷新问题" class="headerlink" title="6 登录状态刷新问题"></a>6 登录状态刷新问题</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/98f5c29b1b8b4b0fb9108a4bc4f035ee.png" alt="img"></p><p>即：配置两个拦截器</p><p>拦截器1：拦截一切的请求，同时刷新token的有效期</p><p>拦截器2：拦截登录的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefreshTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>  <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">RefreshTokenInterceptor</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span>&#123;<br>      <span class="hljs-built_in">this</span>.stringRedisTemplate=stringRedisTemplate;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>      <span class="hljs-comment">//1.获取请求头中的token</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>      <span class="hljs-comment">//判断token是否为空</span><br>      <span class="hljs-keyword">if</span>(StrUtil.isBlank(token))&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>      String key=LOGIN_USER_KEY+token;<br>      <span class="hljs-comment">//2.基于token获取redis中的用户</span><br>      Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);<br>      <span class="hljs-comment">//3.判断用户是否存在</span><br>      <span class="hljs-keyword">if</span>(userMap.isEmpty())&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-comment">//5.存在，将查询到的Hash数据转为UserDTO对象</span><br>      <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>      <span class="hljs-comment">//6.保存用户到ThreadLocal</span><br>      UserHolder.saveUser(userDTO);<br>      <span class="hljs-comment">//7.刷新token有效期</span><br>      stringRedisTemplate.expire(key,LOGIN_USER_TTL, TimeUnit.MINUTES);<br>      <span class="hljs-comment">//8.放行</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      UserHolder.removeUser();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-comment">//判断是否需要拦截（ThreadLocal中是否有用户）</span><br>      <span class="hljs-keyword">if</span>(UserHolder.getUser()==<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-comment">//没有，需要拦截，设置状态码</span><br>          response.setStatus(<span class="hljs-number">401</span>);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-comment">//有用户，则放行</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      UserHolder.removeUser();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">MvcConfig</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">WebMvcConfigurer</span></span> </span>&#123;<br><br>  <span class="hljs-meta">@Resource</span><br>  <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> void addInterceptors(InterceptorRegistry registry) &#123;<br>      registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-type">LoginInterceptor</span>())<br>              .excludePathPatterns(<br>                      <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                      <span class="hljs-string">&quot;/user/login&quot;</span>,<br>                      <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                      <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                      <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                      <span class="hljs-string">&quot;/voucher/**&quot;</span>,<br>                      <span class="hljs-string">&quot;/upload/**&quot;</span>).order(<span class="hljs-number">1</span>);<br>      registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-type">RefreshTokenInterceptor</span>(stringRedisTemplate)).order(<span class="hljs-number">0</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拦截器的顺序，order值越小越小执行</strong></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis-基础</title>
    <link href="/redis-%E5%9F%BA%E7%A1%80/be1ba4ac3a84/"/>
    <url>/redis-%E5%9F%BA%E7%A1%80/be1ba4ac3a84/</url>
    
    <content type="html"><![CDATA[<h1 id="0-目录"><a href="#0-目录" class="headerlink" title="0 目录"></a>0 目录</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240218215626001.png" alt="image-20240218215626001"></p><h1 id="1-NoSQL和SQL"><a href="#1-NoSQL和SQL" class="headerlink" title="1 NoSQL和SQL"></a>1 NoSQL和SQL</h1><p>SQL：<strong>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束</strong></p><p>NoSQL：<strong>NoSql对数据库格式没有严格约束，往往形式松散，自由。可以是key-value,可以是文档，或者图格式</strong></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/5c1e0a6741c8868bf4ad9996c03e2589.png" alt="image-20221108154744967"></p><h1 id="2-认识Redis"><a href="#2-认识Redis" class="headerlink" title="2 认识Redis"></a>2 认识Redis</h1><p><strong>特征：</strong></p><ul><li><strong>键值（key-value）型，value支持多种不同数据结构，功能丰富</strong></li><li><strong>单线程，每个命令具备原子性</strong></li><li><strong>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</strong></li><li><strong>支持数据持久化(定期将内存搬运到磁盘)</strong></li><li><strong>支持主从集群、分片集群（数据拆分）</strong></li><li><strong>支持多语言客户端</strong></li></ul><h1 id="3-Redis命令"><a href="#3-Redis命令" class="headerlink" title="3 Redis命令"></a>3 Redis命令</h1><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的KEY</li><li>EXISTS：判断KEY是否存在</li><li>EXPIRE：给一个KEY设置有效期，有效期到期，这个key就会被自动删除（<strong>expire设置存活周期，ttl查看剩余时间，不设置expire的话ttl为-1</strong>）</li></ul><h2 id="3-1-String"><a href="#3-1-String" class="headerlink" title="3.1 String"></a>3.1 String</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ol><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ol><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最 大空间不能超过512m </p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240218220640595.png" alt="image-20240218220640595"></p><h3 id="3-1-1-常见命令"><a href="#3-1-1-常见命令" class="headerlink" title="3.1.1 常见命令"></a>3.1.1 常见命令</h3><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如： incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><h3 id="3-1-2-Key结构"><a href="#3-1-2-Key结构" class="headerlink" title="3.1.2 Key结构"></a>3.1.2 Key结构</h3><p>可以通过给key添加前缀加以区分，前缀规范：Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><blockquote><p>项目名：业务名：类型：id</p></blockquote><h2 id="3-2-Hash"><a href="#3-2-Hash" class="headerlink" title="3.2 Hash"></a>3.2 Hash</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240218220722702.png" alt="image-20240218220722702"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240218220620645.png" alt="image-20240218220620645"></p><h3 id="3-2-1-常见命令"><a href="#3-2-1-常见命令" class="headerlink" title="3.2.1 常见命令"></a>3.2.1 常见命令</h3><ul><li>HSET  key  field  value：添加或者修改hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field的值</li><li>HMSET：批量添加多个hash类型key的field的值</li><li>HMGET：批量获取多个hash类型key的field的值</li><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HVALS：获取一个hash类型的key中的所有的value</li><li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><h2 id="3-3-List"><a href="#3-3-List" class="headerlink" title="3.3 List"></a>3.3 List</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既 可以支持正向检索和也可以支持反向检索。</p><p><strong>特征也与LinkedList类似：</strong>有序、元素可以重复、插入和删除快、查询速度一般</p><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><h3 id="3-3-1-常见命令"><a href="#3-3-1-常见命令" class="headerlink" title="3.3.1 常见命令"></a>3.3.1 常见命令</h3><ul><li>LPUSH key element  ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element  ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li></ul><p>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</p><h2 id="3-4-Set"><a href="#3-4-Set" class="headerlink" title="3.4 Set"></a>3.4 Set</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的 HashMap。因为也是一个hash表，因此具备与HashSet类似的特征： 无序、元素不可重复、查找快、支持交集、并集、差集等功能。</p><h3 id="3-4-1-常见命令"><a href="#3-4-1-常见命令" class="headerlink" title="3.4.1 常见命令"></a>3.4.1 常见命令</h3><ul><li>SADD key member  ：向set中添加一个或多个元素</li><li>SREM key member  : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2  ：求key1与key2的交集</li><li>SDIFF key1 key2  ：求key1与key2的差集</li><li>SUNION key1 key2  ：求key1与key2的并集</li></ul><h2 id="3-5-SortedSet"><a href="#3-5-SortedSet" class="headerlink" title="3.5 SortedSet"></a>3.5 SortedSet</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层 数据结构却差别很大。 SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加  hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性（从小到大排序 ），经常被用来实现排行榜这样的功能。</p><h3 id="3-5-1-常见命令"><a href="#3-5-1-常见命令" class="headerlink" title="3.5.1 常见命令"></a>3.5.1 常见命令</h3><ul><li>ZADD key score member：添加一个或多个元素到sorted set 如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member  :  获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max ：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max ：按照 score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max ：按照 score排序后，获取指定score范围内的元 素</li><li>ZDIFF、 ZINTER、 ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><p> <strong>升序</strong>获取sorted set 中的指定元素的排名：  ZRANK key member</p><p> <strong>降序</strong>获取sorted set 中的指定元素的排名：  ZREVRANK key memeber</p><h1 id="4-Redis的Java客户端"><a href="#4-Redis的Java客户端" class="headerlink" title="4 Redis的Java客户端"></a>4 Redis的Java客户端</h1><h2 id="4-1-Jedis"><a href="#4-1-Jedis" class="headerlink" title="4.1 Jedis"></a>4.1 Jedis</h2><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li><li><p>建立连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisTest</span> &#123;<br>    <span class="hljs-keyword">private</span> Jedis jedis;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//1.建立连接</span><br>        jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">//2.设置密码</span><br>        jedis.auth(<span class="hljs-string">&quot;1234&quot;</span>);<br>        <span class="hljs-comment">//3.选择库</span><br>        jedis.select(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;result= &quot;</span> + result);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name= &quot;</span>+name);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(jedis!=<span class="hljs-literal">null</span>)&#123;<br>            jedis.close();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>Jedis连接池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> JedisPool jedisPool;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">//配置连接池</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        poolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>        poolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>        poolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>        poolConfig.setMaxWait(Duration.ofMillis(<span class="hljs-number">1000</span>));<br>        jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig,<span class="hljs-string">&quot;192.168.200.130&quot;</span>,<span class="hljs-number">6379</span>,<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;1234&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> jedisPool.getResource();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式</p></li><li><p>静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化</p></li><li><p>最后提供返回连接池中连接的方法.</p></li></ol><h2 id="4-2-SpringDataRedis"><a href="#4-2-SpringDataRedis" class="headerlink" title="4.2 SpringDataRedis"></a>4.2 SpringDataRedis</h2><p><strong>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis</strong></p><p><strong>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</strong></p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/Redis/image-20240218221757795.png" alt="image-20240218221757795"></p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Redis依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--连接池依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <br></code></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.130</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">1234</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span> <span class="hljs-comment">#最大连接数</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span> <span class="hljs-comment">#最大空闲连接</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#最小空闲连接</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">100</span> <span class="hljs-comment">#连接等待时间</span><br><br></code></pre></td></tr></table></figure></li><li><p>Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br><span class="hljs-comment">//JSON工具类ObjectMapper,或者可以用fastjson:JSON.toJSONString(), JSON.parseObject()</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setName(<span class="hljs-string">&quot;阿廖莎&quot;</span>);<br>    user.setAge(<span class="hljs-number">21</span>);<br>    <span class="hljs-comment">//手动序列化</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(user);<br><br>    stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:100&quot;</span>,json);<br>    <span class="hljs-comment">//反序列化</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.readValue(stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;user:100&quot;</span>), User.class);<br>    System.out.println(<span class="hljs-string">&quot;user1 = &quot;</span> + user1);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java编程技巧-并发处理-01</title>
    <link href="/Java%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86-01/156a7266de3c/"/>
    <url>/Java%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86-01/156a7266de3c/</url>
    
    <content type="html"><![CDATA[<blockquote><p>背景：公司的项目，自己写了一个接口的时候，请求接口的具体service涉及到异步A+同步B的情况，需要等到同步B方法执行完成之后才会释放资源，因此如何控制好并发是一个问题</p></blockquote><h1 id="1-解决思路"><a href="#1-解决思路" class="headerlink" title="1. 解决思路"></a>1. 解决思路</h1><p>使用队列进行控制</p><h1 id="2-思路："><a href="#2-思路：" class="headerlink" title="2. 思路："></a>2. 思路：</h1><ol><li>分析出真正会并发的一块代码</li><li>将真正会并发的那一块代码抽取出来，单独封装一个方法</li><li>将调用并发代码之前的方法A加锁，保证该方法A不会出现并发情况</li><li>在方法A中使用一个队列将需要执行的任务进行管理</li><li>当有第一个请求进入的时候，此时list为空，那么直接执行并发方法，如果当list不为空，那么将任务添加进去即可。</li><li>最后当第一个请求执行完成需要释放资源的时候，此时将执行的任务移除，判断list中是否有内容，如果有，取出list首位，并执行并发的方法。</li></ol><h1 id="3-具体代码"><a href="#3-具体代码" class="headerlink" title="3. 具体代码"></a>3. 具体代码</h1><p>第一步：等待编译回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/apk/&#123;mode&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">jenkinsCompile</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> RobustReq robustReq, <span class="hljs-meta">@PathVariable(&quot;mode&quot;)</span>Integer mode)</span> &#123;<br>        compileRecordService.saveParamAndStartCompile(robustReq.getLiTaskId(), robustReq, mode, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IJenkinsResultCallback</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResult</span><span class="hljs-params">(String taskId, <span class="hljs-type">boolean</span> isSuccess)</span> &#123;<br>                <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                    robustService.savRobustParam(taskId, robustReq);<br>                    robustService.noticeInstall(taskId);<br>                &#125;<br>            &#125;<br>        &#125;, TaskTypeEnum.ROBUST_TEST.getTaskCode());<br><br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br></code></pre></td></tr></table></figure><p>第二步：回调完成，安装APK</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">noticeInstall</span><span class="hljs-params">(String taskId)</span> &#123;<br>        <span class="hljs-keyword">if</span> (taskIdList.isEmpty()) &#123;<br>            exeInstall(taskId);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            taskIdList.add(taskId);<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exeInstall</span><span class="hljs-params">(String taskId)</span> &#123;<br>      List&lt;Map&lt;String, Object&gt;&gt; envInfoList = getAvaInfoList(rowList);<br><br>      <span class="hljs-comment">// 1~5min</span><br>      <span class="hljs-keyword">while</span> (envInfoList.isEmpty()) &#123;<br>          <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>          <span class="hljs-type">int</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>) + <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;<br><br>          <span class="hljs-keyword">try</span> &#123;<br>              Thread.sleep(delay);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              e.printStackTrace();<br>          &#125;<br>          envInfoList = getAvaInfoList(rowList);<br>      &#125;<br><br>      Map&lt;String, Object&gt; envInfo = envInfoList.get(<span class="hljs-number">0</span>);<br>      List&lt;String&gt; devicesList = (List&lt;String&gt;) envInfo.get(<span class="hljs-string">&quot;deviceIds&quot;</span>);<br>      <span class="hljs-type">String</span> <span class="hljs-variable">deviceId</span> <span class="hljs-operator">=</span> devicesList.get(<span class="hljs-number">0</span>);<br><br>      <span class="hljs-type">Integer</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> (Integer) envInfo.get(<span class="hljs-string">&quot;id&quot;</span>);<br><br>      <span class="hljs-type">String</span> <span class="hljs-variable">installUrl</span> <span class="hljs-operator">=</span> Constants.Win.ADDRESS + Constants.Common.COLON + Constants.Win.JAVA_PORT + Constants.Common.SEPARATOR + Constants.Win.INSTALL_APK_HMI;<br>      HttpUtil.createPost(installUrl)<br>              .header(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>              .body(JSONUtil.toJsonStr(paramMap))<br>              .execute();<br>  &#125;<br></code></pre></td></tr></table></figure><p>第三步：等待另一台服务的响应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/callback&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">installCallback</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> InstallResp resp)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> resp.getTaskId();<br><br>        <span class="hljs-keyword">if</span> (resp.isSuccess()) &#123;<br>            robustService.startRobust(taskId, infoMap -&gt; &#123;<br>            &#125;, emitter);<br>            <span class="hljs-keyword">return</span> Result.ok();<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第四步：执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startRobust</span><span class="hljs-params">(String taskId, ILiATCallback callback, ObservableEmitter&lt;Boolean&gt; emitter)</span> &#123;<br>        executeTask(runTime, returnNum, liTaskId, taskId);<br><br>        startIntervalGetRate(liTaskId, taskId, emitter);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeTask</span><span class="hljs-params">(Integer runtime, Integer returnNum, Integer liTaskId, String taskId)</span> &#123;<br>        List&lt;Map&lt;String, Object&gt;&gt; envList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        Map&lt;String, Object&gt; paramMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><br>        <span class="hljs-type">HttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> HttpUtil.createPost(<span class="hljs-string">&quot;xxx&quot;</span>)<br>                .header(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>                .header(<span class="hljs-string">&quot;authorization&quot;</span>, Constants.LiAT.AUTHORIZATION)<br>                .body(JSONUtil.toJsonStr(paramMap))<br>                .execute();<br><br>        taskIdList.remove(taskId);<br>        <span class="hljs-keyword">if</span> (!taskIdList.isEmpty()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">nextTaskId</span> <span class="hljs-operator">=</span> taskIdList.get(<span class="hljs-number">0</span>);<br>            exeInstall(nextTaskId);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-hot100-双指针</title>
    <link href="/leetcode-hot100-%E5%8F%8C%E6%8C%87%E9%92%88/fa7554c1833c/"/>
    <url>/leetcode-hot100-%E5%8F%8C%E6%8C%87%E9%92%88/fa7554c1833c/</url>
    
    <content type="html"><![CDATA[<h1 id="1-移动零"><a href="#1-移动零" class="headerlink" title="1. 移动零"></a>1. 移动零</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/LeetCode/image-20231202172905894.png" alt="image-20231202172905894"></p><h1 id="2-盛最多水的容器"><a href="#2-盛最多水的容器" class="headerlink" title="2. 盛最多水的容器"></a>2. 盛最多水的容器</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/LeetCode/image-20231202174344254.png" alt="image-20231202174344254"></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-hot100-哈希</title>
    <link href="/leetcode-hot100-%E5%93%88%E5%B8%8C/91774001b143/"/>
    <url>/leetcode-hot100-%E5%93%88%E5%B8%8C/91774001b143/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/LeetCode/image-20231202170319592.png" alt="image-20231202170319592"></p><h1 id="2-字母异位词分组"><a href="#2-字母异位词分组" class="headerlink" title="2. 字母异位词分组"></a>2. 字母异位词分组</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/LeetCode/image-20231202171402767.png" alt="image-20231202171402767"></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java编程技巧-回调函数</title>
    <link href="/Java%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/12bcfab4b0fb/"/>
    <url>/Java%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/12bcfab4b0fb/</url>
    
    <content type="html"><![CDATA[<blockquote><p>背景：<br>开发公司项目的时候，需要用到Jenkins触发编译，打包APK，随后拿到产物地址再进行下一步，但是APK编译时间不确定，但是检测又必须拿到这个产物地址才能进行。</p></blockquote><h1 id="1-回调"><a href="#1-回调" class="headerlink" title="1. 回调"></a>1. 回调</h1><h2 id="1-1-同步回调"><a href="#1-1-同步回调" class="headerlink" title="1.1. 同步回调"></a>1.1. 同步回调</h2><blockquote><p>比如：你去书店买书，进门问老板有书吗？老板说有，同时给你拿出了书，随后，你付钱离开。这一过程，整个流程：</p><ol><li>询问</li><li>等老板给你拿书</li><li>拿到书付钱离开</li></ol></blockquote><p><code>fun(a)</code>调用<code>fun(b)</code>，<code>fun(a)</code><strong>等待</strong><code>fun(b)</code>执行完后再进行下一步。</p><p>同步调用会引起代码的阻塞。</p><h2 id="1-2-异步回调"><a href="#1-2-异步回调" class="headerlink" title="1.2. 异步回调"></a>1.2. 异步回调</h2><blockquote><p>比如：你还是去买书，询问老板有书吗？老板说我去找一下，你回复说那你先找吧，我先去喝一杯奶茶去，我过一会人再来。过了一个小时，老板已经将书放在柜台，你付钱离开。整个过程：</p><ol><li>询问</li><li>老板去招书</li><li>你去喝奶茶</li><li>得到书，付钱离开</li></ol></blockquote><p><code>fun(a)</code>调用<code>fun(b)</code>, <code>fun(a)</code><strong>不等待</strong><code>fun(b)</code>执行完便进行下一步。<br>常见的有Thread、Task等。</p><h2 id="1-3-回调"><a href="#1-3-回调" class="headerlink" title="1.3. 回调"></a>1.3. 回调</h2><blockquote><p>比如：你接着去买书，询问老板有书吗？老板说目前没有，然后你回答说，那我在这儿等，书来了我才走。后面有书了，你得到了书付钱离开。整个过程：</p><ol><li>询问</li><li>老板备货</li><li>等待</li><li>得到书，付钱离开</li></ol></blockquote><p> 回调的机制是：</p><ol><li>类A的<code>a()</code>方法调用类B的<code>b()</code>方法</li><li>类B的<code>b()</code>方法执行完毕主动调用类A的<code>callback()</code>方法</li></ol><p>所以在回调，重要的就是两个类：</p><p>A：调用B后，需要等到B的结果才能继续向下执行。</p><p>B：执行动作。</p><p>设置回调，由于A是需要等到B的结果再向下，所以在A中，需要实现这个接口，或者在调用B方法的参数中，实例化一个Callback对象，B中持有这个回调对象，当B完成之后，就通过这个回调对象发消息。</p><p>比如买书：</p><p>用户需要等书才走，书店老板要备货，那么用户就是A，书店(老板)就是B，用户需要实现一个回调，并且书店要持有这个回调，当备货完成才能通知用户。</p><p>回调：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookAvailableCallback</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBookAvailable</span><span class="hljs-params">(String bookTitle)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buyBook</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;去书店买书&quot;</span>);<br>        <span class="hljs-type">BookStore</span> <span class="hljs-variable">bookStore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookStore</span>();<br>        bookStore.prepareBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BookAvailableCallback</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBookAvailable</span><span class="hljs-params">(String bookTitle)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;买到了书---《&quot;</span> + bookTitle + <span class="hljs-string">&quot;》&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>书店：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookStore</span> &#123;<br>    <span class="hljs-keyword">private</span> BookAvailableCallback callback;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareBook</span><span class="hljs-params">(BookAvailableCallback callback)</span> &#123;<br>        <span class="hljs-built_in">this</span>.callback = callback;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;书店正在备货，请稍候...&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>); <span class="hljs-comment">// 模拟备货过程，等待5秒</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        haveBook();<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">haveBook</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">bookTitle</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java Programming&quot;</span>; <span class="hljs-comment">// 模拟书店有了书</span><br><br>        <span class="hljs-comment">// 当书店有书时，调用回调通知用户</span><br>        <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">null</span>) &#123;<br>            callback.onBookAvailable(bookTitle);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BookStore</span> <span class="hljs-variable">bookStore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookStore</span>();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><br>        user.buyBook();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实回调就是一个很好的面向接口编程的实例，在接口中定义好要做什么事，根据接口定义的职责，实例出来的对象就具备这个接口能力，那么只需要在另一边持有对应的引用就可以通过回调定义的能力将最终结果返回。</p>]]></content>
    
    
    <categories>
      
      <category>Java编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-ThreadLocal</title>
    <link href="/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ThreadLocal/5c8cef3482ea/"/>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ThreadLocal/5c8cef3482ea/</url>
    
    <content type="html"><![CDATA[<h1 id="1、ThreadLocal是什么？"><a href="#1、ThreadLocal是什么？" class="headerlink" title="1、ThreadLocal是什么？"></a>1、ThreadLocal是什么？</h1><ul><li>提供线程内局部变量，不同线程之间不会相互干扰。</li><li>ThreadLocal 实例通常来说都是 <code>private static</code> 修饰的，用于关联线程和线程的上下文。</li><li><code>减少同一个线程内的函数 或 组件之间传递变量的复杂性</code>。</li></ul><p>小结：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 线程并发：在多线程并发的场景<br><span class="hljs-bullet">2.</span> 传递数据：通过ThreadLocal在同一线程不同组件中传递公共变量。<br><span class="hljs-bullet">3.</span> 线程隔离：每个线程的变量都是独立的，不会互相影响<br></code></pre></td></tr></table></figure><h2 id="1-1、举例-线程隔离"><a href="#1-1、举例-线程隔离" class="headerlink" title="1.1、举例-线程隔离"></a>1.1、举例-线程隔离</h2><ul><li><p>不使用ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span> &#123;<br>        <span class="hljs-built_in">this</span>.content= content;<br>    &#125;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    demo.setContent(Thread.currentThread().getName() + <span class="hljs-string">&quot;的数据&quot;</span>);<br>                    System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;----&gt;&quot;</span> + demo.getContent());<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;线程&quot;</span> + i).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/image-20230722155750292.png" alt="image-20230722155750292"></p></li><li><p>使用ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span> &#123;<br>        threadLocal.set(content);<br>    &#125;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> threadLocal.get();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    demo.setContent(Thread.currentThread().getName() + <span class="hljs-string">&quot;的数据&quot;</span>);<br>                    System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;----&gt;&quot;</span> + demo.getContent());<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;线程&quot;</span> + i).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/image-20230722155708884.png" alt="image-20230722155708884"></p></li></ul><h2 id="1-2、对比synchronized"><a href="#1-2、对比synchronized" class="headerlink" title="1.2、对比synchronized"></a>1.2、对比synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">synchronizedDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span> &#123;<br>        <span class="hljs-built_in">this</span>.content= content;<br>    &#125;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">synchronizedDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">synchronizedDemo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">synchronized</span> (synchronizedDemo.class) &#123;<br>                        demo.setContent(Thread.currentThread().getName() + <span class="hljs-string">&quot;的数据&quot;</span>);<br>                        System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;----&gt;&quot;</span> + demo.getContent());<br>                    &#125;<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;线程&quot;</span> + i).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/image-20230722161534672.png" alt="image-20230722161534672"></p><p>虽然 <code>ThreadLocal</code> 和 <code>Synchronized</code> 关键字都是用于处理多线程并发访问变量的问题，不过两者处理问题的角度和思路不同。</p><table><thead><tr><th align="center"></th><th align="center">Synchronized</th><th align="center">ThreadLocal</th></tr></thead><tbody><tr><td align="center">原理</td><td align="center">同步机制采用“以时间换空间”的方式，只提供了一份变量，让不同的线程排队访问。</td><td align="center">采用 “以空间换时间”的方式，为每一个线程都提供了一份变量的副本，从而实现同时访问而不互相干扰。</td></tr><tr><td align="center">侧重点</td><td align="center">多个线程之间访问资源的<strong>同步</strong>。</td><td align="center">并发情况下让每个线程之间数据相互<strong>隔离</strong>。</td></tr></tbody></table><h2 id="1-3、ThreadLocal的好处"><a href="#1-3、ThreadLocal的好处" class="headerlink" title="1.3、ThreadLocal的好处"></a>1.3、ThreadLocal的好处</h2><ol><li>传递数据：保证每个线程保定的数据在需要的地方可以直接使用，这样避免了进行参数传递而带来的代码耦合问题。</li><li>线程隔离：各个线程之间的数据相互隔离但有具备并发性，同事避免了使用synchronized加锁带来的性能损耗问题。</li></ol><h1 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h1><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/image.png" alt="img"></p><p>那么可以看到在service到Dao层的时候，都会使用connection，那么此时将connection对象和当前线程进行绑定，这样就能保证数据的一致性，并且避免传参导致的代码耦合问题。</p><h2 id="2-1、Service层"><a href="#2-1、Service层" class="headerlink" title="2.1、Service层"></a>2.1、Service层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.transfer.service;<br><br><span class="hljs-keyword">import</span> com.itheima.transfer.dao.AccountDao;<br><span class="hljs-keyword">import</span> com.itheima.transfer.utils.JdbcUtils;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String outUser, String inUser, <span class="hljs-type">int</span> money)</span> &#123;<br>        <span class="hljs-type">AccountDao</span> <span class="hljs-variable">ad</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountDao</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> JdbcUtils.getConnection();<br>            <span class="hljs-comment">//开启事务</span><br>            conn.setAutoCommit(<span class="hljs-literal">false</span>);<br>            <span class="hljs-comment">// 转出 ： 这里不需要传参了 ！</span><br>            ad.out(outUser, money);<br>            <span class="hljs-comment">// 模拟转账过程中的异常</span><br><span class="hljs-comment">//            int i = 1 / 0;</span><br>            <span class="hljs-comment">// 转入</span><br>            ad.in(inUser, money);<br>            <span class="hljs-comment">//事务提交</span><br>            JdbcUtils.commitAndClose();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-comment">//事务回滚</span><br>           JdbcUtils.rollbackAndClose();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-2、Dao层"><a href="#2-2、Dao层" class="headerlink" title="2.2、Dao层"></a>2.2、Dao层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.transfer.dao;<br><br><span class="hljs-keyword">import</span> com.itheima.transfer.utils.JdbcUtils;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountDao</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">out</span><span class="hljs-params">(String outUser, <span class="hljs-type">int</span> money)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = money - ? where name = ?&quot;</span>;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> JdbcUtils.getConnection();<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstm</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>        pstm.setInt(<span class="hljs-number">1</span>,money);<br>        pstm.setString(<span class="hljs-number">2</span>,outUser);<br>        pstm.executeUpdate();<br>        <span class="hljs-comment">//照常使用</span><br><span class="hljs-comment">//        JdbcUtils.release(pstm,conn);</span><br>        JdbcUtils.release(pstm);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">in</span><span class="hljs-params">(String inUser, <span class="hljs-type">int</span> money)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = money + ? where name = ?&quot;</span>;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> JdbcUtils.getConnection();<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstm</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>        pstm.setInt(<span class="hljs-number">1</span>,money);<br>        pstm.setString(<span class="hljs-number">2</span>,inUser);<br>        pstm.executeUpdate();<br><span class="hljs-comment">//        JdbcUtils.release(pstm,conn);</span><br>        JdbcUtils.release(pstm);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-3、Utils方法"><a href="#2-3、Utils方法" class="headerlink" title="2.3、Utils方法"></a>2.3、Utils方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.transfer.utils;<br><br><span class="hljs-keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcUtils</span> &#123;<br>    <span class="hljs-comment">//ThreadLocal对象 : 将connection绑定在当前线程中</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br><br>    <span class="hljs-comment">// c3p0 数据库连接池对象属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br><br>    <span class="hljs-comment">// 获取连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-comment">//取出当前线程绑定的connection对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> tl.get();<br>        <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//如果没有，则从连接池中取出</span><br>            conn = ds.getConnection();<br>            <span class="hljs-comment">//再将connection对象绑定到当前线程中</span><br>            tl.set(conn);<br>        &#125;<br>        <span class="hljs-keyword">return</span> conn;<br>    &#125;<br><br>    <span class="hljs-comment">//释放资源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(AutoCloseable... ios)</span> &#123;<br>        <span class="hljs-keyword">for</span> (AutoCloseable io : ios) &#123;<br>            <span class="hljs-keyword">if</span> (io != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    io.close();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commitAndClose</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> getConnection();<br>            <span class="hljs-comment">//提交事务</span><br>            conn.commit();<br>            <span class="hljs-comment">//解除绑定</span><br>            tl.remove();<br>            <span class="hljs-comment">//释放连接</span><br>            conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollbackAndClose</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> getConnection();<br>            <span class="hljs-comment">//回滚事务</span><br>            conn.rollback();<br>            <span class="hljs-comment">//解除绑定</span><br>            tl.remove();<br>            <span class="hljs-comment">//释放连接</span><br>            conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，在Utils方法中，getConnection的时候，此时使用了一个ThreadLocal对象，将当前Connection对象和当前线程进行绑定了；如果是第一次获取connection对象，那么就从连接池中获取，不是的话，那么直接从ThreadLocal中获取。</p><h1 id="3、内部结构探索"><a href="#3、内部结构探索" class="headerlink" title="3、内部结构探索"></a>3、内部结构探索</h1><h2 id="3-1、内部结构"><a href="#3-1、内部结构" class="headerlink" title="3.1、内部结构"></a>3.1、内部结构</h2><p>在JDK8中ThreadLocal的设计：每个<code>Thread</code>维护一个<code>ThreadLocalMap</code>，这个Map的<code>key</code>是<code>ThreadLocal</code>对象本身，而<code>value</code>就是真正需要存储的值。</p><p>具体：</p><blockquote><p>（1） 每个Thread线程内部都有一个Map (ThreadLocalMap)<br>（2） Map里面存储ThreadLocal对象（key）和线程的变量副本（value）<br>（3）Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。<br>（4）对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</p></blockquote><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/image-20230722171217698.png" alt="image-20230722171217698"></p><p>由于每个Thread中维护一个ThreadLocalMap，Map的key为ThreadLocal对象本身，value为设置的值，这样的优势：</p><ol><li>每个<code>Map</code>存储的<code>Entry</code>数量就会变少，JDK7中的存储数量由<code>Thread</code>的数量决定，现在是由<code>ThreadLocal</code>的数量决定。（ThreadLocal的数量远远小于Thread数量）</li><li>当<code>Thread</code>销毁之后，对应的<code>ThreadLocalMap</code>也会随之销毁，能减少内存的使用。</li></ol><h2 id="3-2、核心方法"><a href="#3-2、核心方法" class="headerlink" title="3.2、核心方法"></a>3.2、核心方法</h2><h3 id="3-2-1、set"><a href="#3-2-1、set" class="headerlink" title="3.2.1、set"></a>3.2.1、set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br><span class="hljs-comment">// 1）拿到当前线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-comment">// 2）通过线程内部的 threadLocals 变量，拿到对应 ThreadLocalMap 对象。对应着分析1</span><br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        <span class="hljs-comment">// 3）判断如果不为 null ,则直接调用 ThreadLocalMap 中的 set 方法，传入 当前的 ThreadLocal 对象和要指定修改的值 value，对应着分析2</span><br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>            map.set(<span class="hljs-built_in">this</span>, value);<br>        <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 4）创建 map 为 null，就创建 map, 对应着分析3</span><br>            createMap(t, value);<br>    &#125; <br><br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br><br><span class="hljs-comment">// Thread类中持有一个ThreadLocalMap类型的对象threadLocals</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p>真正进行赋值：</p><blockquote><p>set方法可以进行修改或者新建的操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    <span class="hljs-comment">// 将ThreadLocal对象的存储表table赋值给局部变量tab</span><br>        Entry[] tab = table;<br>    <span class="hljs-comment">// 计算tab的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-comment">// 先找到对应Entry的数组下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 循环查找存储表中能匹配的Entry对象，从索引位置开始一直到链表末尾</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>             e != <span class="hljs-literal">null</span>;<br>             e = tab[i = nextIndex(i, len)]) &#123;<br>            <span class="hljs-comment">// 取出当前的ThreadLocal对象</span><br>            ThreadLocal&lt;?&gt; k = e.get();<br>            <span class="hljs-comment">// 判断与Key，即是否是一个ThreadLocal对象，如果是，那么就进行以及修改</span><br>            <span class="hljs-keyword">if</span> (k == key) &#123;<br>                e.value = value;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当前Entry的ThreadLocal对象为空，说明该Entry无效，可能在之前被GC掉了</span><br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 传入key, value, i创建一个新的Entry，存储在数组tab的位置</span><br>                replaceStaleEntry(key, value, i);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-comment">// 循环找都没有匹配ThreadLocal对象</span><br>    <span class="hljs-comment">// 新建一个Entry，</span><br>        tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br><span class="hljs-comment">// 增加存储表中的Entry数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <span class="hljs-comment">// 判断是否需要清理一些无效的Entry&amp;&amp;是否需要去扩容</span><br>        <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>            <span class="hljs-comment">// 进行扩容</span><br>            rehash();<br>    &#125;<br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>        t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>    &#125;<br>    <br>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>        <span class="hljs-comment">// 创建一个默认长度大小为 16 的 Entry 数组</span><br>        table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>        <span class="hljs-comment">// 计算对应的数组的下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 插入节点</span><br>        table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>        size = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 设置扩容阈值</span><br>        setThreshold(INITIAL_CAPACITY);<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-2-2、get"><a href="#3-2-2、get" class="headerlink" title="3.2.2、get"></a>3.2.2、get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前的线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 获取当前线程的ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 通过 getEntry 找到线程对应着的 Entry 对象, 对应着分析1</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">// 如果不为 null 则直接拿到返回</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// map为空，进行initialValue</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-comment">// 计算出 index 的值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 获取当前tab下表为i的Entry</span><br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-comment">// 如果存在, 判断是不是相同的对象，是就直接返回</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 清空 key 为 null 的对象</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 会进行初始化, 如果我们重写了就会调用我们自己重写的，否则就调用默认的。</span><br>    <span class="hljs-comment">// protected T initialValue() &#123;return null;&#125;</span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>     <span class="hljs-comment">// 如果 map 不为 null ，就直接添加本地变量，key 为当前线程，值为添加的本地变量值</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// 如果 map 为 null，说明首次添加，需要首先创建出对应的 map</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-3、remove"><a href="#3-2-3、remove" class="headerlink" title="3.2.3、remove"></a>3.2.3、remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程绑定的 threadLocals</span><br>     <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>     <span class="hljs-comment">// 如果 map 不为 null，就移除当前线程中指定 ThreadLocal 实例的本地变量</span><br>     <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)<br>         m.remove(<span class="hljs-built_in">this</span>);<br> &#125;<br><br></code></pre></td></tr></table></figure><h1 id="4、ThreadLocal内存泄漏"><a href="#4、ThreadLocal内存泄漏" class="headerlink" title="4、ThreadLocal内存泄漏"></a>4、ThreadLocal内存泄漏</h1><h2 id="4-1、内存泄漏是什么？"><a href="#4-1、内存泄漏是什么？" class="headerlink" title="4.1、内存泄漏是什么？"></a>4.1、内存泄漏是什么？</h2><blockquote><p>不再会使用的对象或者变量占用的内存不能被回收，就是内存泄漏。</p></blockquote><h2 id="4-2、四种引用"><a href="#4-2、四种引用" class="headerlink" title="4.2、四种引用"></a>4.2、四种引用</h2><h3 id="4-2-1、强引用"><a href="#4-2-1、强引用" class="headerlink" title="4.2.1、强引用"></a>4.2.1、强引用</h3><p>一般我们 new 关键字创建的对象就是 Reference（强引用），当内存不足时，JVM 开始垃圾回收，对于强引用对象，就算是出现 OOM 也不会对该对象进行回收。</p><h3 id="4-2-2、软引用"><a href="#4-2-2、软引用" class="headerlink" title="4.2.2、软引用"></a>4.2.2、软引用</h3><p>软引用是一种相对相对于强引用弱化了一些的引用，需要用 SoftReference 类实现，对于软引用来说，当系统内存充足时，软引用对象不会被垃圾回收，不充足时，会被回收。软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收！</p><h3 id="4-2-3、弱引用"><a href="#4-2-3、弱引用" class="headerlink" title="4.2.3、弱引用"></a>4.2.3、弱引用</h3><p>弱引用需要用 WeakReference 类实现，它比软引用的生存期更短，对于弱引用对象来说，只要垃圾回收器运行，不管 JVM 内存空间是否足够，都会回收该对象占用的内存。</p><h3 id="4-2-4、虚引用"><a href="#4-2-4、虚引用" class="headerlink" title="4.2.4、虚引用"></a>4.2.4、虚引用</h3><p>虚引用需要 PhantomReference 类来实现，如果一个对象持有虚引用，那么它就和没有任何引用一样，在任何时候都可能会垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列（ReferenceQueue）联合使用。</p><h2 id="4-3、Entry"><a href="#4-3、Entry" class="headerlink" title="4.3、Entry"></a>4.3、Entry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        Object value;<br><br>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>            <span class="hljs-built_in">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码中可以得知，</p><ul><li>ThreadLocalMap是ThreadLocal的一个内部静态类，用来存储每个线程对应的变量值。Entry类来管理每个线程本地变量的key-value。</li><li><code>Entry</code>是<code>ThreadLocalMap</code>的一个内部静态类，继承自<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>。<code>Entry</code>表示一个键值对，用于将<code>ThreadLocal</code>对象与其对应的变量值关联起来。<ul><li>表明：<code>ThreadLocal</code>对象在没有其他强引用对象的时候会被垃圾回收器进行回收，而<code>Entry</code>的声明周期也会随着结束，进而避免了内存泄漏。</li></ul></li></ul><h3 id="4-3-1、为什么是弱引用"><a href="#4-3-1、为什么是弱引用" class="headerlink" title="4.3.1、为什么是弱引用"></a>4.3.1、为什么是弱引用</h3><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/20210219124533810.png" alt="图一"></p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    ThreadLocal&lt;Integer&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    tl .set(<span class="hljs-number">2021</span>);<br>    tl .get();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当调用method的时候，会向栈中插入一条栈帧。</li><li>new关键字创建一个ThreadLocal对象，此时tl是对象的引用<ul><li>new出的对象是一个强引用，通过set方法进行存储值，Key是ThreadLocal对象本身，Value为需要存储的值。</li><li>Entry继承WeakReference，那么Key是弱引用指向了ThreadLocal对象。</li></ul></li><li>当method方法执行完毕之后，栈帧销毁，此时强引用tl就不存在了。<ul><li>但是Thread的ThreadLocalMap中的某一个Entry的key的引用还指向了ThreadLocal对象</li><li>如果这个Key引用是强引用，会导致Key指向的ThreadLocal对象是强引用对象不能被GC，会造成内存泄漏</li><li>如果这个Key引用是弱引用，会大概率减少内存泄漏的问题。使用了弱引用，就可以使ThreadLocal对象在方法执行完毕之后顺利被回收，并且Key的引用会被指向为null。</li></ul></li></ul><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/20210219131444101.png" alt="图二"></p><blockquote><p>总结：</p><ul><li>new一个ThreadLocal对象的时候，就会有一个强引用指向这个对象。</li><li>调用set方法之后，线程中的ThreadLocalMap中的Entry对象中的Key指向ThreadLocal对象。</li><li>如果Key是强引用的话，当方法执行完，栈帧中的强引用销毁了，对象还不能被回收，此时就会造成内存泄漏。</li></ul></blockquote><h3 id="4-3-2、为什么还是会泄漏"><a href="#4-3-2、为什么还是会泄漏" class="headerlink" title="4.3.2、为什么还是会泄漏"></a>4.3.2、为什么还是会泄漏</h3><p>虽然Entry继承了弱引用，保证了Key指向的ThreadLocal对象能被及时回收，但是此时v指向的Value对象需要再ThreadLocalMap调用get、set的时候发现Key为null的时候才能回收整个的entry、Value。</p><blockquote><p>为什么value还持有引用？</p><p>解答：ThreadLocal作为Thread的一个属性，如果当前线程没有手动销毁，那么ThreadLocalMap也还是存在，同理Entry的引用也持有。</p></blockquote><p><code>所以泄露的根本原因就是因为ThreadLocal的生命周期和Thread的生命周期一样，如果线程没有主动销毁，那么entry就不会被销毁。</code><br><img src="https://workspace-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/image-20230725174415384.png" alt="image-20230725174415384"></p><p>所以：弱引用只是帮助我们降低了内存泄漏的概率，并不能完全避免，在使用完成之后，<code>必须手动remove</code>这个对象。</p><p><img src="https://mypc-1313021454.cos.ap-beijing.myqcloud.com/JUC/ThreadLocal/20210219134347416.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Java多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-线程交替打印</title>
    <link href="/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/4fde684e52ae/"/>
    <url>/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/4fde684e52ae/</url>
    
    <content type="html"><![CDATA[<p>今日复习来自极海Channel的一个面试</p><blockquote><p>如何实现两个线程实现交替打印，线程A打印A，线程B打印B？</p></blockquote><p>讲真当时看到的时候，脑子里面第一反应就是信号量和synchronized解法，那有synchronized就会有ReentrantLock，那就尝试用这三个解法回答一下吧。</p><p>代码地址：<a href="https://github.com/baijiangLai/LearnOfJUC/tree/master/alternatePrint">线程交替打印</a></p><h2 id="1、synchronized实现"><a href="#1、synchronized实现" class="headerlink" title="1、synchronized实现"></a>1、synchronized实现</h2><p>synchronized的方式实现主要是进行加锁，通过一把对象锁，在代码块内只允许一个线程执行后续操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedPrintThread</span>(lock, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>), <span class="hljs-string">&quot;线程A&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedPrintThread</span>(lock, <span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-number">1</span>), <span class="hljs-string">&quot;线程B&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedPrintThread</span>(lock, <span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-number">2</span>), <span class="hljs-string">&quot;线程C&quot;</span>);<br><br>threadA.start();<br>threadB.start();<br>threadC.start();<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedPrintThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String message;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> order;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentOrder</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SynchronizedPrintThread</span><span class="hljs-params">(Object lock, String message, <span class="hljs-type">int</span> order)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lock = lock;<br>        <span class="hljs-built_in">this</span>.message = message;<br>        <span class="hljs-built_in">this</span>.order = order;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                    <span class="hljs-comment">// 打印顺序就是A--&gt;B--&gt;C</span><br>                    <span class="hljs-keyword">while</span> (currentOrder % <span class="hljs-number">3</span> != order) &#123;<br>                        lock.wait(); <span class="hljs-comment">// 当前线程等待，直到轮到自己打印</span><br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;------&quot;</span> + message);<br>                    currentOrder++;<br>                    lock.notifyAll(); <span class="hljs-comment">// 唤醒其他等待的线程</span><br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、ReentrantLock实现"><a href="#2、ReentrantLock实现" class="headerlink" title="2、ReentrantLock实现"></a>2、ReentrantLock实现</h2><p>ReentrantLock实现，同样会传入锁，但是lock和unlock是自己规定，所以当需要判断打印的时候，进行加锁操作，同时每个线程进去之后判断是否是自己需要打印，如果不是，那么就唤醒下一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-type">Condition</span> <span class="hljs-variable">conditionA</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">conditionB</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">conditionC</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLockPrintThread</span>(lock, conditionA, conditionB, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>));<br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLockPrintThread</span>(lock, conditionB, conditionC, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">1</span>));<br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLockPrintThread</span>(lock, conditionC, conditionA, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">2</span>));<br><br>threadA.start();<br>threadB.start();<br>threadC.start();<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockPrintThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition current;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition next;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String message;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> order;<br><br>    <span class="hljs-comment">// 多个线程共享，如果没有static的话，那么会造成只有第一个线程执行了，其余线程还在等待第一个线程执行。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentOrder</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLockPrintThread</span><span class="hljs-params">(Lock lock, Condition currentCondition, Condition nextCondition, String message, <span class="hljs-type">int</span> order)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lock = lock;<br>        <span class="hljs-built_in">this</span>.current = currentCondition; <span class="hljs-comment">//当前线程信号量</span><br>        <span class="hljs-built_in">this</span>.next = nextCondition;      <span class="hljs-comment">//下一个线程信号量</span><br>        <span class="hljs-built_in">this</span>.message = message;<br>        <span class="hljs-built_in">this</span>.order = order;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-comment">// 某个线程持有锁，只有一个线程进入后续部分</span><br>                lock.lock();<br>                <span class="hljs-comment">// 条件判断，如果不满足，当前线程等待，</span><br>                <span class="hljs-keyword">while</span> (currentOrder % <span class="hljs-number">3</span> != order) &#123;<br>                    current.await();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;------&quot;</span> + message);<br>                currentOrder++;<br>                <span class="hljs-comment">// 使用signal()唤醒下一个线程</span><br>                next.signal();<br>                <span class="hljs-comment">// 锁释放</span><br>                lock.unlock();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：Condition对象是与锁（<strong>ReentrantLock</strong>）关联的条件对象，用于线程间的等待和通知机制。因此锁的类型不并不是Object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>lock.newContional();    <span class="hljs-comment">//ConditionalA</span><br>lock.newContional();    <span class="hljs-comment">//ConditionalB</span><br>lock.newContional();    <span class="hljs-comment">//ConditionalC</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="3、信号量实现"><a href="#3、信号量实现" class="headerlink" title="3、信号量实现"></a>3、信号量实现</h2><p>在使用信号量实现的时候，需要指定谁最先拥有许可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphoreA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphoreB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphoreC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SemaphorePrintThread</span>(semaphoreA, semaphoreB, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>));<br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SemaphorePrintThread</span>(semaphoreB, semaphoreC, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">1</span>));<br><span class="hljs-type">Thread</span> <span class="hljs-variable">threadC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SemaphorePrintThread</span>(semaphoreC, semaphoreA, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">2</span>));<br><br>threadA.start();<br>threadB.start();<br>threadC.start();<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphorePrintThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Semaphore current;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Semaphore next;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentOrder</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String message;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> order;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SemaphorePrintThread</span><span class="hljs-params">(Semaphore current, Semaphore next, String message, <span class="hljs-type">int</span> order)</span> &#123;<br>        <span class="hljs-built_in">this</span>.current = current;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.message = message;<br>        <span class="hljs-built_in">this</span>.order = order;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 核心：通过获取当前线程的信号量来确定是否轮到自己执行。</span><br><span class="hljs-comment">                 * 在执行完打印操作后，释放下一个线程的信号量，从而实现线程的交叉打印。</span><br><span class="hljs-comment">                 */</span><br>                current.acquire();      <span class="hljs-comment">// 获取当前线程的信号量</span><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;------&quot;</span> + message);<br>                currentOrder++;<br>                next.release();         <span class="hljs-comment">//释放下一个线程的信号量</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
